{
  "metadata": {
    "specification_id": "ts_23.946",
    "version": "Unknown",
    "title": "3GPP TS 23.946",
    "file_path": "/content/drive/MyDrive/RAG_thesis/data/23_series/23946-i10/23946-i10.docx"
  },
  "export_info": {
    "export_date": "2025-07-26T09:20:55.994224",
    "total_chunks": 30
  },
  "chunks": [
    {
      "chunk_id": "ts_23.946_1",
      "section_id": "1",
      "section_title": "Scope",
      "content": "This TR provides guidelines for CAPIF usage for the benefit of the Application developer and API provider communities. This document also describes the usage and deployment options in CAPIF.\nThe work takes into consideration the work done for CAPIF in 3GPP TS 23.222 [2] and 3GPP TS 29.222 [3] and 3GPP TS 33.122 [4], and other related work outside 3GPP.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222",
        "ts_29.222",
        "ts_33.122"
      ]
    },
    {
      "chunk_id": "ts_23.946_2",
      "section_id": "2",
      "section_title": "References",
      "content": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non‑specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 23.222: \"Common API Framework for 3GPP Northbound APIs; Stage 2\".\n[3]\t3GPP TS 29.222: \"Common API Framework for 3GPP Northbound APIs; Stage 3\".\n[4]\t3GPP TS 33.122: \"Security Aspects of Common API Framework for 3GPP Northbound APIs\".\n[5]\t\tETSI GS MEC 011 (V3.3.1), \"Multi-access Edge Computing (MEC); Edge Platform Application Enablement\".\n[6]\t3GPP TR 23.958: \"Edge Application Standards in 3GPP and Alignment with External Organizations\".\n[7]\tEVOLVED-5G ICT-41 project, \"EVOLVED-5G\", https://evolved-5g.eu.\n[8]\tEVOLVED-5G NEF emulator (V2.2.3), \"EVOLVED-5G NEF emulator\", https://github.com/EVOLVED-5G/NEF_emulator.\n[9]\tETSI Software Development Group OpenCAPIF, \"OpenCAPIF\", https://ocf.etsi.org.\n[10]\tETSI Labs OCF capif, \"capif\", https://labs.etsi.org/rep/ocf/capif.\n[11]\t\tGSMA PRD OPG.02 - \"Operator Platform Telco Edge Requirements Version 7.0\", https://www.gsma.com/solutions-and-impact/technologies/networks/wp-content/uploads/2024/09/OPG.02-v7.0-Operator-Platform-Requirements-and-Architecture.pdf.\n[12]\tOpenCAPIF ETSI SDG OCF Documentation – Postman, \"ETSI SDG OCF Documentation - Postman\", https://ocf.etsi.org/documentation/develop/testing/postman/.\n[13]\tOpenCAPIF ETSI SDG OCF Documentation - Common Operations, \"ETSI SDG OCF Documentation - Common Operations\", https://ocf.etsi.org/documentation/develop/testing/testplan/common_operations/.\n[14]\t\t3GPP TS 29.122: \"T8 reference point for Northbound APIs\".\n[15]\tIETF RFC 6749 (October 2012): \"The OAuth 2.0 Authorization Framework\".\n[16]\t\t3GPP TS 29.500: \"5G System; Technical Realization of Service Based Architecture; Stage 3\".",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905",
        "ts_23.222",
        "ts_29.222",
        "ts_33.122",
        "ts_23.958",
        "ts_29.122",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_23.946_3.1",
      "section_id": "3.1",
      "section_title": "Terms",
      "content": "For the purposes of the present document, the terms given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\nFor the purposes of the present document, the terms given in clause 3 of 3GPP TS 23.222 [2] and clause 3 of 3GPP TS 29.222 [3] shall also apply.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_3",
        "ts_29.222_clause_3",
        "ts_21.905",
        "ts_23.222",
        "ts_29.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_3.2",
      "section_id": "3.2",
      "section_title": "Symbols",
      "content": "For the purposes of the present document, the following symbols apply:\n<symbol>\t<Explanation>",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.946_3.3",
      "section_id": "3.3",
      "section_title": "Abbreviations",
      "content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\nFor the purposes of the present document, the abbreviations given in clause 3 of 3GPP TS 23.222 [2] and clause 3 of 3GPP TS 29.222 [3] shall also apply.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_3",
        "ts_29.222_clause_3",
        "ts_21.905",
        "ts_23.222",
        "ts_29.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.1",
      "section_id": "4.1",
      "section_title": "Introduction",
      "content": "3GPP specifies multiple northbound API-related specifications. To avoid duplication and inconsistency of approaches between different API specifications and to specify common services (e.g. authorization), 3GPP developed a common API framework (CAPIF) that includes aspects applicable to any northbound service APIs. The key CAPIF specifications are:\n-\t3GPP TS 23.222 [2] defines the CAPIF architecture and procedures;\n-\t3GPP TS 29.222 [3] defines the API messages and protocol for CAPIF APIs; and\n-\t3GPP TS 33.122 [4] defines CAPIF security procedures.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222",
        "ts_29.222",
        "ts_33.122"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.2",
      "section_id": "4.2",
      "section_title": "Functional Architecture",
      "content": "The CAPIF functional architecture is specified in 3GPP TS 23.222 [2] and consists of CAPIF core function, API Provider Domain Functions and API invoker. CAPIF architecture is based on the well-known Service Oriented Architecture (SOA) design paradigm, where a Service producer (i.e. API provider) is able to publish (1) the offered service APIs which can be discovered (2) by the Service consumers (e.g. API invokers) and further can invoke (3) the discovered service APIs as per the authorization.\nFigure 4.2-1: CAPIF based on SOA\nFigure 4.2-1 provides an illustration of CAPIF based on SOA with the following relationship:\n1.\tThe functionalities related to Service Access Controller are supported by CAPIF core function.\n2.\tThe Service producer is the API Provider Domain Functions.\n3.\tThe Service consumer is the API Invoker.\nMost CAPIF APIs are provided by a CAPIF core function entity and can be consumed by applications (API invokers) and application providers (CAPIF defines an API provider as three functions: API exposure, API publishing, and API management). CAPIF core function APIs enable onboarding, publishing, discovery, authentication, registration, authorization, logging, charging, monitoring, configuration, topology hiding, and other procedures. One CAPIF API (AEF security) is provided by the API exposure function.\nFigure 4.2-2: Functional model for the CAPIF to support 3rd party API providers\n(adapted from 3GPP TS 23.222 [2] Figure 6.2.1-1: Functional model for the CAPIF to support 3rd party API providers).\nThe CAPIF architecture includes multiple deployment models e.g. centralized vs. distributed, single vs. multiple API providers (see 3GPP TS23.222 [2] clause 7).",
      "chunk_type": "general",
      "cross_references": [
        "clause_7",
        "figure_4.2-1",
        "figure_4.2-2",
        "ts_23.222_figure_6.2.1-1",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.3",
      "section_id": "4.3",
      "section_title": "Functional Entities",
      "content": "API invoker: Typically provided by a 3rd party application provider who has service agreement with the PLMN operator.\nThe API invoker supports several CAPIF capabilities such as supporting authentication, obtaining authorization, and discovering service APIs and invoking service APIs.\nCAPIF core function (CCF): Supports capabilities used by other functional entities, for example the following:\n-\tFor the API invoker: authenticating the API invoker, providing authorization information, and service API discovery.\n-\tFor the API exposing function: (AEF) providing the service API access policy, providing API routing information, and charging of service API invocations.\n-\tFor the API publishing function: publishing and storing the service APIs information.\n-\tFor the API management function: providing the service API invocation log for auditing, storing configurations of the API provider policies, and updating registration information of API provider domain functions.\nA CAPIF core function can also interact with another CAPIF core function for API publishing and discovery.\nAPI exposing function (AEF): The API exposing function (AEF) is the provider of the Service APIs and is also the service communication entry point of the Service API to API invokers.\nAPI publishing function (APF): The API publishing function (APF) enables the API provider to publish the Service APIs information to enable the discovery of Service APIs by the API invoker.\nAPI management function (AMF): The API management function (AMF) enables the API provider to manage service APIs such as querying the Service API invocation log for auditing, monitoring the events, and configuring the API provider policies.\nAuthorization function: The authorization function enables receiving authorization from the resourse owner function and providing the API invoker with the authorization information which is needed to access the resource owner’s resources. This function is used in RNAA scenarios.\nResource owner function (ROF): The resource owner function enables the authorization for resource access and managing and revoking authorization for resource access. This function is used in RNAA scenarios.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.946_4.4",
      "section_id": "4.4",
      "section_title": "RNAA and CAPIF",
      "content": "RNAA (Resource owner-aware Northbound API Access) is an OAuth 2.0-based authorization mechanism for CAPIF and enables API invokers to have authorized access to resources of a resource owner provided by service APIs offered by the API exposing function.\nThe relationship between the RNAA and CAPIF is described in this clause. The CAPIF architecture given in clause 6.2.0 of 3GPP TS 23.222 [2] can use OAuth 2.0 token's mechanism to authorize API invokers. As per OAuth 2.0, API invoker performs the function of the client, the CAPIF core function performs the function of the authorization server, and the API exposing function performs the exposure of the protected resources. The API invoker is authorized with an authorization grant type of client credentials described in clause 6.5 of 3GPP TS 33.122 [4].\nThe RNAA architecture given in clause 6.2.3 of 3GPP TS 23.222 [2] supports an authorization grant type of authorization code grant. The resource owner function in the RNAA architecture has the role of the resource owner, authorizing the API invoker to invoke the API exposing function.\nFigure 4.4-1 shows the architectural model for the RNAA which allows the resource owner to provide authorization to the API invocation. The authorization function and the resource owner function are used in RNAA scenarios.\nFigure 4.4-1: High level functional architecture for CAPIF supporting RNAA",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_6.2.0",
        "ts_33.122_clause_6.5",
        "ts_33.122_clause_6.2.3",
        "figure_4.4-1",
        "ts_23.222_clause_6.2.3",
        "ts_23.222",
        "ts_33.122"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.5",
      "section_id": "4.5",
      "section_title": "Relationship between RNAA and OAuth 2.0",
      "content": "This clause shows the relationship between RNAA and OAuth 2.0. The Table 4.5-1 shows the mapping of OAuth 2.0 and RNAA. The details of OAuth 2.0 are specified in IETF RFC 6749 [15] and the details of RNAA are in 3GPP TS 23.222 [2].\nTable 4.5-1: RNAA relationship with OAuth 2.0\nRole\nOAuth 2.0\nRNAA\nThe entity capable of granting access to a protected resource.\nResource Owner\nResource owner via Resource owner function\nThe server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.\nResource Server\nAPI exposing function\nThe application making protected resource requests on behalf of the resource owner and with its authorization.\nClient\nAPI invoker\nThe server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.\nAuthorization Server\nAuthorization function\nThe software agent responsible for retrieving and facilitating end-user interaction for authorization.\nUser Agent\nResource owner function hosting environment",
      "chunk_type": "general",
      "cross_references": [
        "table_4.5-1",
        "ts_23.222_table_4.5-1",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.6.1",
      "section_id": "4.6.1",
      "section_title": "General",
      "content": "This clause provides the overview of CAPIF operations from the perspective of an Application (API invoker) and API provider. The detail of the CAPIF overall operations is shown in Annex A of 3GPP TS 23.222 [2].",
      "chunk_type": "definition",
      "cross_references": [
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.6.2",
      "section_id": "4.6.2",
      "section_title": "Usage of CAPIF by API invoker",
      "content": "Figure 4.6.2-1 describes the usage of CAPIF by API invoker for APIs which does not involve resource owner authorization.\nFigure 4.6.2-1: Usage of CAPIF by API invoker for APIs which does not involve resource owner\n1.\tAPI invoker onboards to the CAPIF core function, as specified in clause 8.1 of 3GPP TS 23.222 [2].\n2.\tThe API invoker authenticates with the CAPIF core function, as specified in clause 8.10 of 3GPP TS 23.222 [2].\n3.\tThe API invoker discovers the service API, as specified in clause 8.7 of 3GPP TS 23.222 [2].\n4.\tTo access the service API, the API invoker obtains authorization with the CAPIF core function, as specified in clause 8.11 of 3GPP TS 23.222 [2].\n5.\tThe API invoker performs service API invocation, as specified in clause 8.16 of 3GPP TS 23.222 [2].\nFigure 4.6.2-2 describes the usage of CAPIF by API invoker for APIs which involves resource owner authorization.\nFigure 4.6.2-2: Usage of CAPIF by API invoker for APIs which involve resource owner\n1.\tAPI invoker onboards to the CAPIF core function, as specified in clause 8.1 of 3GPP TS 23.222 [2].\n2.\tThe API invoker authenticates with the CAPIF core function, as specified in clause 8.10 of 3GPP TS 23.222 [2].\n3.\tThe API invoker discovers the service API, as specified in clause 8.7 of 3GPP TS 23.222 [2].\n4.\tTo access the service API, the API invoker obtains authorization with the CAPIF core function, and then requests service API invocation as specified in clause 8.31 of 3GPP TS 23.222 [2].\n5.\tThe API invoker performs service API invocation, as specified in clause 8.16 of 3GPP TS 23.222 [2].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_8.1",
        "ts_23.222_clause_8.10",
        "ts_23.222_clause_8.7",
        "ts_23.222_clause_8.11",
        "ts_23.222_clause_8.16",
        "ts_23.222_clause_8.31",
        "figure_4.6.2-1",
        "ts_23.222_figure_4.6.2-2",
        "figure_4.6.2-2",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_4.6.3",
      "section_id": "4.6.3",
      "section_title": "Usage of CAPIF by API provider",
      "content": "Figure 4.6.3-1 describes the usage of CAPIF by API provider for APIs which does not involve resource owner authorization.\nFigure 4.6.3-1: Usage of CAPIF by API provider for APIs which does not involve resource owner\n1.\tThe API publishing function sends service API publish request to the CAPIF core function, as specified in clause 8.3 of 3GPP TS 23.222 [2].\n2.\tThe API provider authenticates the API invoker prior to the service API invocation, utilizes the API exposing function, as specified in clause 8.14 of 3GPP TS 23.222 [2].\n3.\tThe API provider authenticates the API invoker upon invocation of the service APIs, utilizes the API exposing function, as specified in clause 8.15 of 3GPP TS 23.222 [2].\n4.\tThe API provider authorizes the API invoker to access, as specified in clause 8.16 of 3GPP TS 23.222 [2].\n5.\tThe API provider controls the access of the service API by the API invoker based on policy or usage limits, as specified in clause 8.16 and 8.17 of 3GPP TS 23.222 [2].\n6.\tThe API provider maintains the log of the API invocations at the CAPIF core function for services such as charging, invocation history, utilizes the API exposing function, as specified in clause 8.19 of 3GPP TS 23.222 [2].\n7.\tThe API provider facilitates charging of the API invocations, utilizes the API exposing function, as specified in clause 8.20 of 3GPP TS 23.222 [2].\n8.\tThe API provider facilitates monitoring such as API invoker's ID and IP address, utilizes the API management function, as specified in clause 8.21 of 3GPP TS 23.222 [2].\n9.\tThe API provider utilizes the API management function for auditing, as specified in clause 8.22 of 3GPP TS 23.222 [2].\nFigure 4.6.3-2 describes the usage of CAPIF by API provider for APIs which involves resource owner authorization.\nFigure 4.6.3-2: Usage of CAPIF by API provider for APIs which involve resource owner\n1.\tThe API publishing function sends service API publish request to the CAPIF core function, as specified in clause 8.3 of 3GPP TS 23.222 [2].\n2.\tThe API provider authenticates the API invoker prior to the service API invocation, utilizes the API exposing function, as specified in clause 8.14 of 3GPP TS 23.222 [2].\n3.\tThe API provider authenticates the API invoker upon invocation of the service APIs, utilizes the API exposing function, as specified in clause 8.15 of 3GPP TS 23.222 [2].\n4.\tAPI authorization is based on the authorization information obtained from the resource owner function, as specified in clause 8.31 of 3GPP TS 23.222 [2].\n5.\tThe API provider authorizes the API invoker to access, as specified in clause 8.16 of 3GPP TS 23.222 [2].\n6.\tThe API provider controls the access of the service API by the API invoker based on policy or usage limits, as specified in clause 8.16 and 8.17 of 3GPP TS 23.222 [2].\n7.\tThe API provider maintains the log of the API invocations at the CAPIF core function for services such as charging, invocation history, utilizes the API exposing function, as specified in clause 8.19 of 3GPP TS 23.222 [2].\n8.\tThe API provider facilitates charging of the API invocations, utilizes the API exposing function, as specified in clause 8.20 of 3GPP TS 23.222 [2].\n9.\tThe API provider facilitates monitoring such as API invoker's ID and IP address, utilizes the API management function, as specified in clause 8.21 of 3GPP TS 23.222 [2].\n10.\tThe API provider utilizes the API management function for auditing, as specified in clause 8.22 of 3GPP TS 23.222 [2].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_8.3",
        "ts_23.222_clause_8.14",
        "ts_23.222_clause_8.15",
        "ts_23.222_clause_8.16",
        "ts_23.222_clause_8.19",
        "ts_23.222_clause_8.20",
        "ts_23.222_clause_8.21",
        "ts_23.222_clause_8.22",
        "ts_23.222_clause_8.31",
        "figure_4.6.3-1",
        "ts_23.222_figure_4.6.3-2",
        "figure_4.6.3-2",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.1",
      "section_id": "5.1",
      "section_title": "Stakeholders in CAPIF",
      "content": "Several stakeholders are considered to interact within the API exposure ecosystem, for instance: MNO, NPN owners, channel aggregators, application service developers, application service providers (ASP), authorization service providers, identity service providers, resource owners, API invokers.\nThe functional model description for CAPIF is given in clause 6.2.0 of 3GPP TS 23.222 [2]. Different business relationships are considered for CAPIF as follows:\n-\tBasic CAPIF business relationships are given in clause 5.1 of 3GPP TS 23.222 [2].\n-\tCAPIF business relationships for RNAA are provided in clause 5.2 of 3GPP TS 23.222 [2].\n-\tIn case of interconnection among CAPIF providers, CAPIF business relationships are given in clause 4.12 of 3GPP TS 23.222 [2].\nSome exemplary business relationships are reproduced in Figure 5.1-1.\nFigure 5.1-1: Basic business relationships in CAPIF\nCAPIF has three main stakeholder roles (CAPIF provider, API provider, and API invoker) and RNAA has resource owner role.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_6.2.0",
        "ts_23.222_clause_5.1",
        "ts_23.222_clause_5.2",
        "ts_23.222_clause_4.12",
        "figure_5.1-1",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.2.1",
      "section_id": "5.2.1",
      "section_title": "CAPIF provider",
      "content": "The CAPIF provider contains an instance of CAPIF core function, and API provider, and API invokers and it could be a PLMN, SNPN or 3rd party. The CAPIF provider and the API provider can be part of the same organization (e.g. PLMN operator), in which case the business relationship between the two is internal to a single organization. The CAPIF provider and the API provider can be part of different organizations, in which case the business relationship between the two must exist in clause 5.1 of 3GPP TS 23.222 [2].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_5.1",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.2.2",
      "section_id": "5.2.2",
      "section_title": "Service API provider",
      "content": "The service API provider hosts one or more service APIs and has a service API arrangement with CAPIF provider to offer the service APIs to the API invoker.\nRequirements for enabling API invoker is given in clause 4.1.2 of 3GPP TS 23.222 [2].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_4.1.2",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.2.3",
      "section_id": "5.2.3",
      "section_title": "API invoker",
      "content": "The API invoker is typically provided by a 3rd party application provider who has service agreement with PLMN operator and consumes the CAPIF APIs and service APIs. The API invoker may reside within the same trust domain as the PLMN operator network. There are various API invokers like application management client (used by application developers, application service provider), hosted applications (on cloud, edge or UE), and channel aggregator (who aggregates the CAPIF APIs and/or the service APIs).\nRequirements for supporting 3rd party API providers is given in clause 4.1.3 of 3GPP TS 23.222 [2].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_4.1.3",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.2.4",
      "section_id": "5.2.4",
      "section_title": "Resource owner",
      "content": "The resource owner is a UE user or an MNO subscriber capable of granting access to a protected resource related to the resource exposed by the API provider. In the current release, it is a user of the UE hosting the API invoker that can authorize the API access in clause 6.3.8 of 3GPP TS 23.222 [2].\nRequirements for supporting RNAA is given in clause 4.17.2 of 3GPP TS 23.222 [2].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_6.3.8",
        "ts_23.222_clause_4.17.2",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.3",
      "section_id": "5.3",
      "section_title": "Mapping of stakeholders to CAPIF roles",
      "content": "The figure 5.3-1 provides the mapping of the stakeholders to CAPIF roles and illustrates the usage of CAPIF capabilities.\nThe following examples of API invoker roles are illustrated:\n1.\tApplication management client: The application developers utilize the CAPIF APIs using an Application management client as an API invoker to obtain the service APIs information to implement the application program. Such application programs are hosted on cloud, edge or on a UE.\n2.\tHosted applications: The Hosted applications (which are programmed to utilize the service APIs) as an API invoker invoke the CAPIF APIs and service APIs as per the application business logic.\n3.\tChannel Aggregator Platform: The Channel Aggregator aggregates the APIs from one or more southbound CAPIF providers with the intention to re-expose such APIs or expose value-added APIs developed using the APIs from the southbound CAPIF providers to the northbound side Application management client or Hosted applications. The Channel Aggregator Platform as API invoker invokes the CAPIF APIs and service APIs as per its business logic.\n4.\tBSS/OSS System: The BSS/OSS system of MNO enables the business relationship with the Application Service Providers (the consumers of the service APIs exposed by the MNO's exposure platform). The BSS/OSS system as an API invoker invoke the CAPIF APIs as per its business logic.\nFigure 5.3-1: Mapping of the stakeholders to CAPIF roles",
      "chunk_type": "general",
      "cross_references": [
        "figure_5.3-1"
      ]
    },
    {
      "chunk_id": "ts_23.946_5.4",
      "section_id": "5.4",
      "section_title": "Usage of CAPIF in different phases of an application business lifecycle",
      "content": "This clause shows an example of CAPIF usage in application service system. In this example, there are following stakeholders/roles: application service provider, application developer, and CAPIF provider and service API provider as defined in 3GPP TS 23.222 [2].\nFigure 5.4-1 shows the whole service flow of CAPIF usage by the 3rd party during the application business lifecycle. The application business lifecycle includes 3 phases:\nPhase 1.\tApplication development preparation phase: Before the application developer develops the application, the developer determines the candidate service APIs to be used for the application. The developer selects the CAPIF provider and the service API provider. As part of the service agreement with the CAPIF provider, the developer needs to ensure the API invoker is pre-provisioned with the required onboarding enrolment information and security credentials. This enables the API invoker to establish a secure connection with the CAPIF core function over which an onboarding API invoker request can be initiated, as specified in clause 8.1 in 3GPP TS 23.222 [2]. Then the developer searches the interested service API(s) information, e.g. available service API, service API name, and so on via the utilizes the application management client (act as API invoker), which invokes the CAPIF_Discover_Service_API to obtain that service API information from the CCF. The developer may find the service API provider at any time later.\nPhase 2.\tApplication development and testing phase: The application developer obtains the detailed service API information including API usage instructions which enables the application developer to program the service API into the application. In addition, the developer may also obtain the security credential of the service API before programming it (option #1). Later, the application developer can test the application which invokes the corresponding CAPIF API and service API (e.g. in a sandbox mode).\nPhase 3.\tApplication deployment and execution phase: After the development, the application is commercial released. The host application (acting as API invoker) obtains the authorization from CAPIF core function to invoke the service API as specified in clause 8.11 of 3GPP TS 23.222 [2]. The host application may obtain the security credential of the service API invocation (Option #2). Upon receiving the access token from CAPIF core function, the application initiates the service API invocation, as specified in clause 8.16 in 3GPP TS 23.222 [2]. In RNAA scenario, the API invoker obtains authorization with the CAPIF core function as specified in clause 8.31 of 3GPP TS 23.222 [2], and then requests service API invocation.\nNOTE 1:\tThere are two options about obtaining the security credential of the service API invocation. Option #1 is fetching it during phase 1 or phase 2 and program it into the host application. In this option, the security can not be dynamically refreshed at any time and a security credential obtained during the preparation and testing phase might not be appropriate for deployment. Option #2 is fetching it during the host application is running. In this option, the security can be dynamically refreshed at any time.\nNOTE 2:\tBeyond 3GPP Release 18, the CAPIF continues to evolve and new features offering enhancement to the different phases of an application business lifecycle are under consideration.\nFigure 5.4-1: Usage of CAPIF in different phases of an application business lifecycle",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_8.1",
        "ts_23.222_clause_8.11",
        "ts_23.222_clause_8.16",
        "ts_23.222_clause_8.31",
        "ts_23.222_figure_5.4-1",
        "figure_5.4-1",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_6.1",
      "section_id": "6.1",
      "section_title": "The deployment of the API Invoker as AF on the UE for RNAA",
      "content": "Several RNAA deployments are described in clause 7.5 of 3GPP TS 23.222 [2], and the following is an example of a RNAA deployment in which API invoker is deployed as AF on the UE.\nIn this deployment scenario, UE, which functions as both the API Invoker (AF) and the resource owner function, requests resource owner consent from the resource owner function through CAPIF core function to obtain the resource (e.g., QoS).\nFigure 6.1-1 illustrates integrated fundamental deployment of the API Invoker as AF on the UE for RNAA.\nFigure 6.1-1: The deployment of the API Invoker as AF on the UE for RNAA\nFigure 6.1-2 illustrates the procedure for the deployment of the API Invoker as AF on the UE for RNAA.\nFigure 6.1-2: The deployment of the API Invoker as AF on the UE for RNAA\nThe following procedure is for the deployment of the API Invoker as AF on the UE for RNAA:\n1.\tThe API invoker triggers onboard API invoker request towards the CAPIF core function. The CAPIF core function then verifies the request and responds to the API invoker with the result.\n2.\tThe API invoker sends an obtain service API authorization request to the CAPIF core function for obtaining permission to access the service API. The CAPIF core function validates the authentication of the API invoker and checks whether the API invoker is permitted to access the requested service API. Then, the CAPIF core function responds to the API invoker with the authorization information required to access the service APIs.\n3.\t The API invoker sends a service API discover request to the CAPIF core function and the CAPIF core function verifies the identity of the API invoker. Then the CAPIF core function sends a service API discover response to the API invoker with the list of service API information for which the API invoker has the required authorization.\n4.\tThe AEF sends an obtain access control policy request to the CAPIF core function for obtaining the policy to perform the access control on service API invocations. The CAPIF core function checks whether the AEF is authorized to receive the access control policy corresponding to the service APIs requested. The AEF is provided the access control policy for the service API via an obtain access control policy response.\n5.\tThe API invoker requests the resource owner's authorization information to invoke the service API, exposed by the API exposing function. The authorization function facilitates this request by involving the resource owner. Then, the API invoker sends a service API invocation request to the API exposing function, which in turn sends a response back to the API invoker.\n6.\tThe API invoker (UE) sends service API invocation request to the and the AEF checks whether the API invoker is authorized to invoke that service API, based on the authorization information. The API invoker receives the service API invocation response as a result of the service API invocation.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.222_clause_7.5",
        "figure_6.1-1",
        "figure_6.1-2",
        "ts_23.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_6.2",
      "section_id": "6.2",
      "section_title": "The deployment of the API Invoker as AF on the network for RNAA",
      "content": "In this deployment scenario, the UE, which functions as both the application and the resource owner function, initiates the application's requests. The API Invoker then requests resource owner consent from the resource owner function through CAPIF core function to obtain the resource (e.g., QoS).\nFigure 6.6-1 illustrates integrated fundamental deployment of the API Invoker as AF on the network for RNAA.\nFigure 6.6-1: The deployment of the API Invoker as AF on the network for RNAA\nFigure 6.6-2 illustrates the procedure for the deployment of the API Invoker as AF on the network for RNAA.\nFigure 6.2-2: The procedure for the deployment of the API Invoker as AF on the network for RNAA\nThe following procedure is for API Invoker deployment on the network as AF for RNAA:\n1.\tThe API invoker triggers onboard API invoker request towards the CAPIF core function. The CAPIF core function then verifies the request and responds to the API invoker with the result.\n2.\tThe API invoker sends an obtain service API authorization request to the CAPIF core function for obtaining permission to access the service API. The CAPIF core function validates the authentication of the API invoker and checks whether the API invoker is permitted to access the requested service API. Then, the CAPIF core function responds to the API invoker with the authorization information required to access the service APIs.\n3.\tThe API invoker sends a service API discover request to the CAPIF core function and the CAPIF core function verifies the identity of the API invoker. Then the CAPIF core function sends a service API discover response to the API invoker with the list of service API information for which the API invoker has the required authorization.\n4.\tThe AEF sends an obtain access control policy request to the CAPIF core function for obtaining the policy to perform the access control on service API invocations. The CAPIF core function checks whether the AEF is authorized to receive the access control policy corresponding to the service APIs requested. The AEF is provided the access control policy for the service API via an obtain access control policy response.\n5.\tThe API exposing function obtains the resource owner consent from the resource owner. The API invoker requests the resource owner's authorization information to invoke the service API, exposed by the API exposing function. The authorization function facilitates this request by involving the resource owner. Then, the API invoker sends a service API invocation request to the API exposing function, which in turn sends a response back to the API invoker.\n6.\tFrom the application’s request on UE, the API invoker sends service API invocation request to the AEF and the AEF checks whether the API invoker is authorized to invoke that service API, based on the authorization information. The API invoker receives the service API invocation response as a result of the service API invocation.",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.6-1",
        "figure_6.6-2",
        "figure_6.2-2"
      ]
    },
    {
      "chunk_id": "ts_23.946_6.3",
      "section_id": "6.3",
      "section_title": "GSMA Operator Platform deployment via CAPIF",
      "content": "The GSMA Operator Platform defines a common platform exposing operator services / capabilities to customers / application providers in the 5G-era. The requirement that an Operator Platform’s SBI-NR can work with CAPIF when available is specified in clause 5.1.4.2.2 of GSMA PRD OPG.02 [11] and application session continuity support for handovers between 4G and 5G based on combined SCEF+NEF via CAPIF is described in clause 5.2.2.6.7 of GSMA PRD OPG.02 [11].\nFigure 6.3-1 illustrates integrated fundamental GSMA Operator Platform deployment of the SCEF and the NEF with the CAPIF. In this deployment model, the GSMA Operator Platform functions as the API invoker.\nNOTE:\tAn Operator Platform's SBI-NR can work without CAPIF. If CAPIF is not supported, the SBI-NR API will provide an alternate means of providing these functions.\nFigure 6.3-1: Integrated GSMA Operator Platform deployment of the SCEF and the NEF with the CAPIF",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.1.4.2.2",
        "clause_5.2.2.6.7",
        "figure_6.3-1"
      ]
    },
    {
      "chunk_id": "ts_23.946_6.4",
      "section_id": "6.4",
      "section_title": "CAPIF Vendor Extensibility",
      "content": "Vendor extensibility is a CAPIF feature that enables third-party API frameworks to re-use CAPIF functionality, adapted to their requirements, by extending either CAPIF APIs or CAPIF data models. A detailed description of vendor extensibility mechanisms is provided on 3GPP TS 29.122 [14] and 3GPP TS 29.500 [16]. The CAPIF APIs supporting this feature are the following:\n-\tCAPIF_Publish_Service_API, including “VendorExt” option in the supported feature list (see Table 8.1.6-1 of 3GPP TS 29.222 [3], which lists 3 features), indicating the support for CAPIF vendor specific extensions on the ServiceAPIDescription data model.\n-\tCAPIF_Discover_Service_API, including “VendSpecQueryParams” option in the supported feature list (see Table 8.2.6-1 of 3GPP TS 29.222 [3], which lists 9 features), indicating the support of vendor specific query parameters in API discovery requests.\nAnnex B provides more details of CAPIF vendor extensibility and illustrates ETSI MEC leveraging the CAPIF vendor extensibility feature.",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.222_table_8.1.6-1",
        "ts_29.222_table_8.2.6-1",
        "ts_29.122",
        "ts_29.500",
        "ts_29.222"
      ]
    },
    {
      "chunk_id": "ts_23.946_6.5",
      "section_id": "6.5",
      "section_title": "ETSI MEC deployment based on CAPIF",
      "content": "The ETSI MEC platform is the collection of essential functionalities required to run MEC applications on a particular Virtualisation infrastructure and enable them to provide and consume MEC services. In clause 9 of ETSI GS MEC 011 V3.3.1 [5], a description is provided on how the MEC service management APIs can be realized by CAPIF APIs. The clause describes how MEC deployments can reuse CAPIF functionality to harmonize between MEC and CAPIF, e.g., to integrate MEC applications into a joint 3GPP-MEC deployment. To enable such harmonization, a variant of the MEC service management functionality is defined that leverages the CAPIF Publish Service API, CAPIF Discover Service API and CAPIF Events API. The variant is referred to as the \"MEC profile of CAPIF\".\nThis deployment option for ETSI MEC based on CAPIF is also depicted at a high-level in clause 7.2 of 3GPP TR 23.958 [6].",
      "chunk_type": "general",
      "cross_references": [
        "clause_9",
        "ts_23.958_clause_7.2",
        "ts_23.958"
      ]
    },
    {
      "chunk_id": "ts_23.946_6.6.1",
      "section_id": "6.6.1",
      "section_title": "Introduction",
      "content": "This clause outlines the registration process for the MEC platform as an API provider within the CAPIF framework, describing the necessary steps and requirements for API publication and management.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.946_6.6.2",
      "section_id": "6.6.2",
      "section_title": "Registering the MEC Platform as an API Provider in CAPIF",
      "content": "To register the MEC platform as an API provider in CAPIF, an access token (access_token) is required to authorize the provider’s onboarding. Once the required information is available, the provider submits an HTTP POST request to the following URI:\nPOST {apiRoot}/api-provider-management/v1/registrations\nRequest Headers:\n•\tAuthorization: Bearer {access_token}\n•\tContent-Type: application/json\nIn the request body, include the regSec field (holding the token) and provide a Certificate Signing Request (CSR) along with relevant details for each provider function: Application Management Function (AMF), API Publishing Function (APF), and API Exposing Function (AEF). Additionally, a domain name and other provider-related information can be specified.\nExample Request Body:\nHTTP POST https://capif.mec.example.com/api-provider-management/v1/registrations\nRequest headers:\nAuthorization: Bearer eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\nContent-Type: application/json\nRequest body:\n{\n\"regSec\": \"eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\",\n\"apiProvFuncs\": [\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nCSR Body\\n-----END CERTIFICATE REQUEST-----\\n\"\n},\n\"apiProvFuncRole\": \"AEF\",\n\"apiProvFuncInfo\": \"AEF for MEC Platform\"\n},\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nCSR Body\\n-----END CERTIFICATE REQUEST-----\\n\"\n},\n\"apiProvFuncRole\": \"APF\",\n\"apiProvFuncInfo\": \"APF for MEC Platform\"\n},\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nCSR Body\\n-----END CERTIFICATE REQUEST-----\\n\"\n},\n\"apiProvFuncRole\": \"AMF\",\n\"apiProvFuncInfo\": \"AMF for MEC Platform\"\n}\n],\n\"apiProvDomInfo\": \"MEC Platform\",\n\"apiProvName\": \"OCF_MEC\"\n}\nUpon successful registration, CAPIF returns the location of the newly created resource in the Location field of the header. The response body includes signed certificates and IDs for each provider function, as well as the domain ID.\nResponse headers:\nLocation: https://capif.mec.example.com/api-provider-management/v1/registrations/3a4df5f6e30a5ee34de346004ee6bb\nResponse body:\n{\n\"apiProvDomId\": \"3a4df5f6e30a5ee34de346004ee6bb\",\n\"regSec\": \"eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\",\n\"apiProvFuncs\": [\n{\n\"apiProvFuncId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nCSR\\n-----END CERTIFICATE REQUEST-----\\n\",\n\"apiProvCert\": \"-----BEGIN CERTIFICATE -----\\nAEF CERTIFICATE\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiProvFuncRole\": \"AEF\",\n\"apiProvFuncInfo\": \"AEF for MEC Platform \"\n},\n{\n\"apiProvFuncId\": \"APF54f49ee44f67c81fc7d7f321195531\",\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nCSR\\n-----END CERTIFICATE REQUEST-----\\n\",\n\"apiProvCert\": \"-----BEGIN CERTIFICATE -----\\nAPF CERTIFICATE\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiProvFuncRole\": \"APF\",\n\"apiProvFuncInfo\": \"APF for MEC Platform\"\n},\n{\n\"apiProvFuncId\": \"AMFOdbe115f6759f0fec943321dc2184d\",\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nCSR\\n-----END CERTIFICATE REQUEST-----\\n\",\n\"apiProvCert\": \"-----BEGIN CERTIFICATE -----\\nAMF CERTIFICATE\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiProvFuncRole\": \"AMF\",\n\"apiProvFuncInfo\": \"AMF for MEC Platform\"\n}\n],\n\"apiProvDomInfo\": \"MEC Platform\",\n\"apiProvName\": \"OCF_MEC\"\n}",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.946_6.6.3",
      "section_id": "6.6.3",
      "section_title": "Publishing an API for the MEC Platform",
      "content": "To publish an API, the MEC platform uses mutual TLS authentication with the APF certificate to make an HTTP POST request to the following URI:\nPOST {apiRoot}/published-apis/v1/{apfId}/service-apis\nThe request body should specify details of the API to be published, including name, status, version, resources, and protocol details.\nExample Request Body:\nHTTP POST https://capif.mec.example.com/published-apis/v1/APF54f49ee44f67c81fc7d7f321195531/service-apis\nRequest body:\n{\n\"apiName\": \"Application Instance Registration\",\n\"apiStatus\": {\n\"aefIds\": [\"AEFb1a522967511fd6d6def0cbb3b5f05\"]\n},\n\"aefProfiles\": [\n{\n\"aefId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"versions\": [\n{\n\"apiVersion\": \"v1\",\n\"expiry\": \"2100-11-30T10:32:02.004Z\",\n\"resources\": [\n{\n\"resourceName\": \"MEC RESOURCE NAME\",\n\"commType\": \"REQUEST_RESPONSE\",\n\"uri\": \"/mec_app_support/v2/registrations\",\n\"custOpName\": \"http_post\",\n\"operations\": [\n\"POST\"\n],\n\"description\": \"App Registration Resource\"\n},]\n}],\n\"protocol\": \"HTTP_1_1\",\n\"dataFormat\": \"JSON\",\n\"securityMethods\": [\n\"OAUTH\",\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\":”X.X.X.X\",\n\"port\": NNNN,\n\"securityMethods\": [\n\"OAUTH\"\n]\n}\n]\n}\n],\n\"description\": \"MEC App Registration API\",\n\"supportedFeatures\": \"1ff\",\n\"shareableInfo\": {\n\"isShareable\": true,\n\"capifProvDoms\": [\n\"MEC Platform\"\n]\n},\n\"serviceAPICategory\": \"MEC Service Management\",\n\"apiProvName\": \"OCF_MEC\"\n}\nUpon successful API publication, CAPIF returns the location of the created resource in the Location field of the header and provides the service API ID of the published API in the response body.\nThis contribution provides a structured approach for onboarding and publishing APIs for the MEC platform within CAPIF, ensuring alignment with CAPIF’s standard onboarding and security procedures.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.946_6.7",
      "section_id": "6.7",
      "section_title": "Open-source implementation of CAPIF",
      "content": "As stated in Annex B.2.2.3 of 3GPP TS 23.222 [2], the NEF can implement the functionalities of the API provider domain functions, as reproduced in Figure 6.7-1.\nFigure 6.7-1: NEF implements the service specific aspect compliant with the CAPIF architecture\nEvolved-5G [7] (ICT-41-2020 project from call H2020-ICT-2018-2020) developed an open-source project of the CAPIF Release 17 under the Apache-2.0 license. EVOLVED-5G implementation of CAPIF works with an open-source implementation of a NEF emulator available in [8]. The NEF emulator used for Evolved-5G implementation supports two services, namely Nnef_EventExposure and Nnef_AFsessionWithQoS [8].\nEvolved-5G implementation has been used as the seed code for OpenCAPIF SDG [9] created by ETSI in January 2024.\nOpenCAPIF has adopted the following APIs from CAPIF:\n-\tCAPIF API Invoker Management API\n-\tCAPIF API Provider Management API\n-\tCAPIF Publish Service API\n-\tCAPIF Discover Service API\n-\tCAPIF Security API, including obtaining the OAuth 2.0 authorization information with JWT access tokens\n-\tCAPIF Access Control Policy API\n-\tCAPIF Logging API Invocation API\n-\tCAPIF Events API\n-\tCAPIF Auditing API\nThe implementation also includes a Testing Suite of the above services.\nEvery CAPIF API is implemented in a separate container for future scalability adaptation. All APIs are exposed and support mutual TLS authentication as specified in 3GPP TS 33.122 [4].\nThe Source Code of OpenCAPIF and the instructions to deploy it are included in the ETSI GitLab repository [10].\nAnnex C provides more details of Open-source implementation of CAPIF for NEF publishing API and API consumption from an API Invoker.",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.7-1",
        "ts_23.222",
        "ts_33.122"
      ]
    },
    {
      "chunk_id": "ts_23.946_7",
      "section_id": "7",
      "section_title": "Summary",
      "content": "This guide presents a number of use cases and adoption strategies for CAPIF. Several stakeholders (e.g., developers, aggregators, CSPs, etc.) can compare them with their own use cases to understand how to apply/map CAPIF capabilities to their own needs.\nAnnex A:Examples from OpenCAPIF\nAll the requests shown in this document for OpenCAPIF can be tested using the OpenCAPIF Postman collection [12]. The collection includes a guide on its use and how to correctly test each of the requests. The following table shows the mapping between each of the requests presented in this document to the corresponding request in the OpenCAPIF Postman collection.\nTable A-1: The OpenCAPIF Postman collection\nRequest\nSection\nOCF Postman Example\nCAPIF_API_Invoker_Management_API\n6.8.1\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#07-onboard_invoker\nCAPIF_API_Provider_Management_API\n6.4.1\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#04-onboard_provider\nCAPIF_Publish_Service_API\n6.4.3\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#05-publish_api\nCAPIF_Discover_Service_API\n6.8.3\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#08-discover\nCAPIF_Security_API create context\n6.8.5\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#09-security_context\nCAPIF_Security_API authorization info\n6.8.7\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#10-get_token\nAPI Invocation\n6.8.9\nhttps://ocf.etsi.org/documentation/develop/testing/postman/#11-call_service\nAnnex B:CAPIF Vendor Extensibility\nB.1\tInclude Vendor Specific information\nAn API provider can include a vendor specific attribute in the ServiceAPIDescription model by enabling “VendorExt” supported feature option and adding the field in the following manner (see clause 5.2.13.2 of 3GPP TS 29.122 [14]):\n\"vendorSpecific-<vendor-identification>\": {\n...\n}\nwhere “vendor-identification” represents a unique name of the vendor publishing the API, using one of the following structures:\nB.2\tQuery for Vendor Specific information\nAn API invoker can discover API services including vendor specific attributes by adding the following query parameters (see clause 5.2.13.3 of 3GPP TS 29.122 [14]):\n\"target\": \"...\",\"value\": \"...\"\n}\nwhere “query-parameter-name” represents the actual name of the query parameter, “target” is a JSON pointer towards the targeted attribute in the targeted resource representation and “value” is the actual value of the query parameter to be used for filtering.\nB.3\tETSI MEC extensibility to CAPIF\nAccording to ETSI GS MEC 011 V3.3.1 [5] specification, MEC framework, leveraging CAPIF extensibility feature, can engage CAPIF and re-use its functionalities. A concrete example is presented in Table B.3-1 and Table B.3-4, describing the request that a MEC platform has to send towards CAPIF to publish an API, as well as a request of an invoker searching an API with MEC specific attributes.\nETSI MEC supports two extensibility attributes on CAPIF:\nBoth attributes are included on the following API Publish request.\nTable B.3-1: Publish MEC API with vendor specific attributes in CAPIF (schema)\nHTTP POST {apiRoot}/published-apis/v1/{apfId}/service-apis\nRequest body:\n{\n\"apiName\": \"string\",\n\"aefProfiles\": [\n{\n\"aefId\": \"string\",\n\"versions\": [\n{\n\"apiVersion\": \"string\",\n\"expiry\": \"string\",\n\"resources\": [\n{\n\"resourceName\": \"string\",\n\"commType\": \"string\",\n\"uri\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\"string\"],\n\"description\": \"string\"\n}\n],\n\"custOperations\": [\n{\n\"commType\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\n\"string\"\n],\n\"description\": \"string\"\n}\n]\n}\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"string\",\n\"port\": \"int\",\n\"securityMethods\": [\n\"string\"\n]\n}\n],\n\"vendorSpecific-urn:etsi:mec:capifext:transport-info\": {\n\"name\": \"string\",\n\"description\": \"string\",\n\"type\": \"string\",\n\"protocol\": \"string\",\n\"version\": \"string\",\n\"security\": {\n\"grantTypes\": \"string\",\n\"tokenEndpoint\": \"string\"\n}\n}\n}\n],\n\"vendorSpecific-urn:etsi:mec:capifext:service-info\": {\n\"serializer\": \"string\",\n\"state\": \"string\",\n\"scopeOfLocality\": \"string\",\n\"consumedLocalOnly\": \"boolean\",\n\"isLocal\": \"boolean\",\n\"category\": {\n\"href\": \"string\",\n\"id\": \"string\",\n\"name\": \"string\",\n\"version\": \"string\"\n}\n},\n\"description\": \"string\",\n\"supportedFeatures\": \"string\",\n\"apiProvName\": \"string\"\n}\nWhen APIs are published including Vendor Specific information, API Invokers can filter the Discovery of APIs including query parameters to filter by vendor specific information. Here we show some examples of CAPIF Discover API including vendor specific filtering.\nThe schema for discovering APIs using vendor specific information is shown in Table B.3-2 and Table B.3-3:\nTable B.3-2: Discover APIs with vendor specific query parameters (schema for transport-info)\nHTTP GET {apiRoot}/service-apis/v1/allServiceAPIs?    api-invoker-id=\"string\"&\nsupported-features=\"string\"&\nvend-spec-type={\"target\": \"...\", \"value\": \"string\"}\nTable B.3-3: Discover APIs with vendor specific query parameters (schema for service-info)\nHTTP GET {apiRoot}/service-apis/v1/allServiceAPIs?    api-invoker-id=\"string\"&\nsupported-features=\"string\"&\nvend-spec-state={\"target\": \"...\", \"value\": \"string\"}\nBased in these schemas, the following examples show how to use CAPIF Extensibility. Table B.3-4 shows an API Publication that includes both transport-info and service-info as part of the API description published.\nTable B.3-4: Publish MEC API with vendor specific attributes in CAPIF (OCF example)\nHTTP POST https://capif.mobilesandbox.cloud:37211/published-apis/v1/{apfId}/service-apis\nRequest body:\n{\n\"apiName\": \"api_demo_v2\",\n\"aefProfiles\": [\n{\n\"aefId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"versions\": [\n{\n\"apiVersion\": \"v2\",\n\"expiry\": \"2021-11-30T10:32:02.004Z\",\n\"resources\": [\n{\n\"resourceName\": \"endpoint_1\",\n\"commType\": \"REQUEST_RESPONSE\",\n\"uri\": \"/endpoint\",\n\"custOpName\": \"string\",\n\"operations\": [\n\"GET\"\n],\n\"description\": \"Endpoint to receive a welcome message\"\n}\n],\n\"custOperations\": [\n{\n\"commType\": \"REQUEST_RESPONSE\",\n\"custOpName\": \"string\",\n\"operations\": [\n\"GET\"\n],\n\"description\": \"string\"\n}\n]\n}\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"localhost\",\n\"port\": 8089,\n\"securityMethods\": [\"Oauth\"]\n}\n],\n\"vendorSpecific-urn:etsi:mec:capifext:transport-info\": {\n\"name\": \"trasport1\",\n\"description\": \"Transport Info 1\",\n\"type\": \"REST_HTTP\",\n\"protocol\": \"HTTP\",\n\"version\": \"2\",\n\"security\": {\n\"grantTypes\": \"OAUTH2_CLIENT_CREDENTIALS\",\n\"tokenEndpoint\": \"https://token-endpoint.example.com/\"\n}\n}\n}\n],\n\"vendorSpecific-urn:etsi:mec:capifext:service-info\": {\n\"serializer\": \"JSON\",\n\"state\": \"ACTIVE\",\n\"scopeOfLocality\": \"MEC_SYSTEM\",\n\"consumedLocalOnly\": \"True\",\n\"isLocal\": \"True\",\n\"category\": {\n\"href\": \"https://location.example.com\",\n\"id\": \"Location\",\n\"name\": \"Location\",\n\"version\": \"1.0\"\n}\n},\n\"description\": \"Hello api services\",\n\"supportedFeatures\": \"1ff\",\n\"apiProvName\": \"OCF_MEC\"\n}\nThe next example in Table B.3-5 shows how to query CAPIF using transport-info to query for APIs which vend-spec-type is “REST_HTTP”.\nTable B.3-5: Discover APIs with vendor specific query parameters (OCF example for transport-info)\nHTTP GET https://capif.mobilesandbox.cloud:37211/service-apis/v1/allServiceAPIs?    api-invoker-id=INVd4d70e16c52bace2b8f40ed6f6badS&\nsupported-features=7&\nvend-spec-type={\"target\": \"/vendorSpecific-urn:etsi:mec:capifext:transport-info\", \"value\": \"REST_HTTP\"}\nSimilarly, the next example in Table B.3-6 shows how to query CAPIF for APIs that contains service-info which vend-spec-state is “ACTIVE”.\nTable B.3-6: Discover APIs with vendor specific query parameters (OCF example for service-info)\nHTTP GET https://capif.mobilesandbox.cloud:37211/service-apis/v1/allServiceAPIs?    api-invoker-id=INVd4d70e16c52bace2b8f40ed6f6badS&\nsupported-features=7&\nvend-spec-state={\"target\": \"/vendorSpecific-urn:etsi:mec:capifext:service-info\", \"value\": \"ACTIVE\"}\nAnnex C:Open-source implementation of CAPIF\nC.1\tNEF Publishes an API\nThe 5GS network exposure function (NEF) can use CAPIF capabilities to publish and manage its APIs, including managing charging. One of several possible deployment arrangements is shown in Figure C.1-1.\nFigure C.1-1: NEF implements the CAPIF API provider domain functions\nSignalling for the NEF to publish its APIs to the CAPIF core function is shown in Figure C.1-2, followed by tables detailing the mandatory attributes of the associated request and response schema and example content for those requests and responses, which is based on publicly available examples provided by the OpenCAPIF [9].\nA pre-condition is that the NEF (API management function) has been made aware of the appropriate CAPIF core function endpoint (apiRoot) with which to initiate the registration, as well as having been provided with a token to access the CAPIF core function.\nFigure C.1-2: Publish a service API\nDetails of the signalling flow in Figure C.1-2 are as follows:\nNOTE 1:\tThe JSON schema and example snippets provided in the following clauses are aligned with 3GPP TS 29.222 [3], in which apiVersion is specified as \"v1\". The example snippets themselves can be tested using the OpenCAPIF Postman collection presented in Annex A and also in the OpenCAPIF Postman documentation [12].\n1. CAPIF_API_Provider_Managment_API\nThe API provider includes:\n-\tAuthorization HTTP header (access token)\n-\tSecurity information enabling the CCF to validate the registration (regSec)\n-\tAn array (apiProvFuncs) of at least one API provider domain function profiles\n-\tOptionally API provider domain information (apiProvDomInfo) and the API provider name (apiProvName)\nTable C.1-1: Register API_provider request (schema)\nHTTP POST {apiRoot}/api-provider-management/v1/registrations\nRequest headers:\nAuthorization: \"string\"\nRequest body:\n{\n\"regSec\": \"string\",\n\"apiProvFuncs\": [\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"string\",\n},\n\"apiProvFuncRole\": \"string\",\n\"apiProvFuncInfo\": \"string\"\n}\n],\n\"apiProvDomInfo\": \"string\",\n\"suppFeat\": \"string\",\n\"apiProvName\": \"string\"\n}\nGiven the schema provided in Table C.1-1, an example of the API Provider registration process using OpenCAPIF open-source implementation is now described and then provided in Table C.1-1-OCF. The presented traces contain actual values to illustrate the usage of the information elements in the JSON schema.\nNOTE 2:\tThe security related information provided in the examples are truncated for readability, e.g., the value associated with regSec and apiProvPubKey.\nBefore carrying out onboarding, the provider requires the:\n-\tOpenCAPIF access token, that will allow the creation of the provider.\n-\tCA_ROOT certificate, necessary to validate the Certificates in all requests.\n-\tURL to which to make the request, i.e., <{apiRoot}/api-provider-management/v1/registrations>.\nNOTE 3:\tIn OpenCAPIF, all this information is obtained in a dedicated user registration process [13].\nIn the presented example, the OpenCAPIF instance is deployed at capif.mobilesandbox.cloud:37211. This instance URL is assumed throughout the presented example traces.\nTo carry out the onboarding of a provider, the API Provider is required to provide the following fields:\n-\tregSec: Contains the OpenCAPIF access token obtained during registration process for the creation of the provider. The Token is also provided in the Authorization HTTP Header.\n-\tapiProvFuncRole: Type of provider function to be created. It can be AMF, APF or AEF.\n-\tapiProvPubKey: It is the certificate signing request (CSR) of the Provider’s function that OpenCAPIF will use to issue the provider’s valid certificates. Each function needs to include its own CSR to request a valid Certificate.\n-\tapiProvFuncInfo: Information about the provider function that is being created.\n-\tapiProvDomInfo: Information about the provider domain that is being created.\nThe API Provider onboarding request example is shown in Table C.1-1-OCF. The example request is to onboards an API Provider with three functions: AEF, APF and AMF. Therefore, 3 CSRs are provided to obtain 3 Certificates.\nTable C.1-1-OCF: Register API provider request (OCF example)\nHTTP POST https://capif.mobilesandbox.cloud:37211/api-provider-management/v1/registrations\nRequest headers:\nAuthorization: Bearer eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\nContent-Type: application/json\nRequest body:\n{\n\"regSec\": \"eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\",\n\"apiProvFuncs\": [\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIICeTCCAWECAQAWNDEMMAoGA1UEAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST-----\\n\"\n},\n\"apiProvFuncRole\": \"AEF\",\n\"apiProvFuncInfo\": \"AEF for NEF example\"\n},\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIICeTCCAWECAQAWNDEMMAoGA1UEAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST-----\\n\"\n},\n\"apiProvFuncRole\": \"APF\",\n\"apiProvFuncInfo\": \"APF for NEF example\"\n},\n{\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIICeTCCAWECAQAWNDEMMAoGA1UEAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST-----\\n\"\n},\n\"apiProvFuncRole\": \"AMF\",\n\"apiProvFuncInfo\": \"AMF for NEF example\"\n}\n],\n\"apiProvDomInfo\": \"NEF example\",\n\"apiProvName\": \"OCF_NEF\"\n\"suppFeat\": \"3\",\n}\nUpon getting this Request, Open CAPIF core function assigns identity IDs for the API provider (apiProvDomId) and each of its functions (apiProvFuncId) and returns them in the response (see next section). Furthermore, it provides certificates (apiProvCert) for each of the API provider functions based on each function’s CSR (apiProvPubKey).\n2. 201 Created\nThe API provider domain has been registered successfully. The URI of the created resource is returned in the \"Location\" HTTP header, including the assigned registration identifier (registrationId).\nTable C.1-2: Register API provider response (schema)\n201\nResponse headers:\nLocation: {apiRoot}/api-provider-management/v1/registrations/{registrationId}\nResponse body:\n{\n\"apiProvDomId\": \"string\",\n\"regSec\": \"string\",\n\"apiProvFuncs\": [\n{\n\"apiProvFuncId\": \"string\",\n\"regInfo\": {\n\"apiProvPubKey\": \"string\",\n\"apiProvCert\": \"string\"\n},\n\"apiProvFuncRole\": \"string\",\n\"apiProvFuncInfo\": \"string\"\n}\n],\n\"apiProvDomInfo\": \"string\",\n\"suppFeat\": \"string\",\n\"apiProvName\": \"string\"\n}\nThe response received from the successful onboarding request using OpenCAPIF project for the creation of a new API Provider includes the following fields:\n-\tapiProvDomId: Identifier of the created provider, which is also the ID returned as part of the ‘Location’ header.\n-\tapiProvCert: Certificate of the provider function created from the CSR sent in the onboarding request, which will be used for subsequent requests from the provider towards OpenCAPIF. Each function is provided with its own Certificate (i.e., one each for the AEF, APF and AMF functions).\n-\tapiProvFuncId: Identifier of the provider function created.\nThe example Register API provider response is shown in Table C.1-2-OCF.\nTable C.1-2-OCF: Register API provider response (OCF example)\nResponse headers:\nLocation: https://capif.mobilesandbox.cloud:37211/api-provider-management/v1/registrations/3a4df5f6e30a5ee34de346004ee6bb\nResponse body:\n{\n\"apiProvDomId\": \"3a4df5f6e30a5ee34de346004ee6bb\",\n\"regSec\": \"eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\",\n\"apiProvFuncs\": [\n{\n\"apiProvFuncId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIICeTCCAWECAQAWNDEMMAoGA1UEAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST-----\\n\",\n\"apiProvCert\": \"-----BEGIN CERTIFICATE -----\\nMIIDRTCCA12gAwIBAgIUC2D11wSISz1CjKiFXJ3vwKxVhREwDQYJKoZ\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiProvFuncRole\": \"AEF\",\n\"apiProvFuncInfo\": \"AEF for NEF example\"\n},\n{\n\"apiProvFuncId\": \"APF54f49ee44f67c81fc7d7f321195531\",\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIICeTCCAWECAQAWNDEMMAoGA1UEAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST-----\\n\",\n\"apiProvCert\": \"-----BEGIN CERTIFICATE -----\\nMIIDRTCCA12gAwIBAgIUC2D11wSISz1CjKiFXJ3vwKxVhREwDQYJKoZ\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiProvFuncRole\": \"APF\",\n\"apiProvFuncInfo\": \"APF for NEF example\"\n},\n{\n\"apiProvFuncId\": \"AMFOdbe115f6759f0fec943321dc2184d\",\n\"regInfo\": {\n\"apiProvPubKey\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIICeTCCAWECAQAWNDEMMAoGA1UEAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST-----\\n\",\n\"apiProvCert\": \"-----BEGIN CERTIFICATE -----\\nMIIDRTCCA12gAwIBAgIUC2D11wSISz1CjKiFXJ3vwKxVhREwDQYJKoZ\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiProvFuncRole\": \"AMF\",\n\"apiProvFuncInfo\": \"AMF for NEF example\"\n}\n],\n\"apiProvDomInfo\": \"NEF example\",\n\"apiProvName\": \"OCF_NEF\"\n\"suppFeat\": \"3\",\n}\n3. CAPIF_Publish_Service_API\nThe API publishing function sends information on the offered APIs by providing the API exposing function profiles array (aefProfiles). The published APIs resource created in response to the request represents all published service APIs of the NEF.\nNOTE 4:\tThe example content in Table C.1.3, the attribute apiStatus is omitted, implying the Service API is active at all AEF(s) present in the aefProfiles attribute. Furthermore, it is assumed the exchange is over CAPIF-4, rather than CAPIF-6/6e. As a consequence, the pubApiPath and ccfId attributes are omitted.\nTable C.1-3: Publish API request (schema)\nHTTP POST {apiRoot}/published-apis/v1/{apfId}/service-apis\nRequest body:\n{\n\"apiName\": \"string\",\n\"apiStatus\": {\n\"aefIds\": [\n\"string\"\n]\n},\n\"aefProfiles\": [\n{\n\"aefId\": \"string\",\n\"versions\": [\n{\n\"apiVersion\": \"string\",\n\"expiry\": \"string\",\n\"resources\": [\n{\n\"resourceName\": \"string\",\n\"commType\": \"string\",\n\"uri\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\"string\"],\n\"description\": \"string\"\n},\n{\n\"resourceName\": \"string\",\n\"commType\": \"string\",\n\"uri\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\"string\"],\n\"description\": \"string\"\n}\n],\n\"custOperations\": [\n{\n\"commType\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\n\"string\"\n],\n\"description\": \"string\"\n}\n]\n}\n],\n\"protocol\": \"string\",\n\"dataFormat\": \"string\",\n\"securityMethods\": [\n\"string\",\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"string\",\n\"port\": \"int\",\n\"securityMethods\": [\n\"string\"\n]\n}\n]\n}\n],\n\"description\": \"string\",\n\"supportedFeatures\": \"string\",\n\"shareableInfo\": {\n\"isShareable\": \"boolean\",\n\"capifProvDoms\": [\n\"string\"\n]\n},\n\"serviceAPICategory\": \"string\",\n\"apiSuppFeats\": \"string\",\n\"pubApiPath\": {\n\"ccfIds\": [\n\"string\"\n]\n},\n\"ccfId\": \"string\",\n\"apiProvName\": \"string\"\n}\nTo publish a service using OpenCAPIF, it is necessary to specify the following fields:\n-\tapiName: Name of the API to be published, which must be unique in CAPIF.\n-\tapiStatus: Represents the API status. In addition, if this attribute is omitted, it is understood that the API is available in all AEFs of aefProfiles. It contains the aefIds field which is a list of the AEFs that expose the API. If this list is empty or the attribute is omitted, it is understood that the API is inactive in all aefProfiles.\n-\taefProfiles: List of Information about AEFs that expose the API. This information contains the following fields:\nOnly domainName or interfaceDescription can be specified.\n-\tsupportedFeatures: Indicates the one or more CAPIF Publish Service API specific supported features (from the nine features specified in 3GPP TS 29.222 [3], clause 8.2.6), e.g., support for API status monitoring in the CAPIF layer as part of the SEAL framework, support for RNAA functionality.\n-\tshareableinfo: Indicates whether the service API and/or the service API category can be shared to the list of CAPIF provider domains.\n-\tserviceAPICategory: The service API category to which the service API belongs to.\n-\tapiSuppFeats: Indication provided by the consumer (i.e., related to the AEF) which optional features are supported by the service API.\n-\tapiProvName: API provider Name that publishes the API.\nThe example API Publish request to publish “3gpp-as-session-with-qos” API from NEF is shown in Table C.1-3-OCF, for which there are twenty-nine optional service specific features (apiSuppFeats) specified in 3GPP TS 29.122 [14], where it is indicated that all features are supported by setting \"apiSuppFeats\" to hexadecimal \"1FFFFFFF\". For the CAPIF Publish Service API, the example hexadecimal \"EF\" (binary “0 1110 1111”) provided for \"supportedFeatures\" indicates that all features are supported, other than feature #5 (ProtocDataFormats_Ext1) and #9 (VendorExt).\nTable C.1-3-OCF: Publish API request (OCF example)\nHTTP POST https://capif.mobilesandbox.cloud:37211/published-apis/v1/APF54f49ee44f67c81fc7d7f321195531/service-apis\nRequest body:\n{\n\"apiName\": \"3gpp-as-session-with-qos\",\n\"apiStatus\": {\n\"aefIds\": [\"AEFb1a522967511fd6d6def0cbb3b5f05\"\n]\n},\n\"aefProfiles\": [\n{\n\"aefId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"versions\": [\n{\n\"apiVersion\": \"v1\",\n\"expiry\": \"2100-11-30T10:32:02.004Z\",\n\"resources\": [\n{\n\"resourceName\": \"QOS_SUBSCRIPTIONS\",\n\"commType\": \"SUBSCRIBE_NOTIFY\",\n\"uri\": \"/{scsAsId}/subscriptions\",\n\"operations\": [\n\"GET\",\n\"POST\"\n],\n\"description\": \"Endpoint to manage monitoring subscriptions\"\n},\n{\n\"resourceName\": \"QOS_SUBSCRIPTION_SINGLE\",\n\"commType\": \"SUBSCRIBE_NOTIFY\",\n\"uri\": \"/{scsAsId}/subscriptions/{subscriptionId}\",\n\"operations\": [\n\"GET\",\n\"PUT\",\n\"DELETE\"\n],\n\"description\": \"Endpoint to manage single subscription\"\n}\n],\n}\n],\n\"protocol\": \"HTTP_1_1\",\n\"dataFormat\": \"JSON\",\n\"securityMethods\": [\n\"OAUTH\",\n\"PSK\"\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"127.0.0.1\",\n\"port\": 4443,\n\"securityMethods\": [\n\"OAUTH\"\n]\n}\n]\n}\n],\n\"description\": \"3gpp-as-session-with-qos NEF API\",\n\"supportedFeatures\": \"ef\",\n\"shareableInfo\": {\n\"isShareable\": true,\n\"capifProvDoms\": [\n\"mobilesandbox.cloud\"\n]\n},\n\"serviceAPICategory\": \"NEF\",\n\"apiSuppFeats\": \"1fffffff\",\n\"apiProvName\": \"OCF_NEF\"\n}\n4. 201 Created\nThe service API has been published successfully The URI of the created resource is returned in the \"Location\" HTTP header, including the assigned service API identifier (serviceApiId) that is also equal to the API identifier (apiId) in the response body.\nTable C.1-4: Publish API response (schema)\n{\n201\nResponse headers:\nLocation: {apiRoot}/published-apis/v1/{apfId}/service-apis/{serviceApiId}\nResponse body:\n{\n\"apiName\": \"string\",\n\"apiId\": \"string\",\n\"apiStatus\": {\n\"aefIds\": [\n\"string\"\n]\n},\n\"aefProfiles\": [\n\"object\"\n],\n\"description\": \"string\",\n\"supportedFeatures\": \"string\",\n\"shareableInfo\": {\n\"isShareable\": \"boolean\",\n\"capifProvDoms\": [\n\"string\"\n]\n},\n\"serviceAPICategory\": \"string\",\n\"apiSuppFeats\": \"string\",\n\"pubApiPath\": {\n\"ccfIds\": [\n\"string\"\n]\n},\n\"ccfId\": \"string\"\n\"apiProvName\": \"string\"\n}\nThe response to a successful API Publish request using OpenCAPIF contains the following information:\n-\tLocation: URL with the resource created for the API Published.\n-\tapiId: The assigned Identifier to the Published API. It is required for the UPDATE or DELETE API procedures once the API has been published.\nThe information from the API that was sent in the request will be obtained as a response with a new field, the \"apiId\", which is the identifier of the API that has been created and will enable subsequent modify or delete procedures.\nTable C.1-4-OCF: Publish API response (OCF example)\nResponse headers:\nLocation: https://capif.mobilesandbox.cloud:37211/published-apis/v1/APF54f49ee44f67c81fc7d7f321195531/service-apis/f55731ec5f8ce703ac1f69605ad095\nResponse body:\n{\n\"apiName\": \"3gpp-as-session-with-qos\",\n\"apiId\": \"f55731ec5f8ce703ac1f69605ad095\",\n\"aefProfiles\": [\n{\n\"aefId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"versions\": [\n{\n\"apiVersion\": \"v1\",\n\"expiry\": \"2100-11-30T10:32:02.004Z\",\n\"resources\": [\n{\n\"resourceName\": \"QOS_SUBSCRIPTIONS\",\n\"commType\": \"SUBSCRIBE_NOTIFY\",\n\"uri\": \"/{scsAsId}/subscriptions\",\n\"custOpName\": \"http_post\",\n\"operations\": [\n\"GET\",\n\"POST\"\n],\n\"description\": \"Endpoint to manage monitoring subscriptions\"\n},\n{\n\"resourceName\": \"QOS_SUBSCRIPTION_SINGLE\",\n\"commType\": \"SUBSCRIBE_NOTIFY\",\n\"uri\": \"/{scsAsId}/subscriptions/{subscriptionId}\",\n\"operations\": [\n\"GET\",\n\"PUT\",\n\"DELETE\"\n],\n\"description\": \"Endpoint to manage single subscription\"\n}\n],\n}\n],\n\"protocol\": \"HTTP_1_1\",\n\"dataFormat\": \"JSON\",\n\"securityMethods\": [\n\"OAUTH\",\n\"PSK\"\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"127.0.0.1\",\n\"port\": 4443,\n\"securityMethods\": [\n\"OAUTH\"\n]\n}\n]\n}\n],\n\"description\": \"3gpp-as-session-with-qos NEF API\",\n\"supportedFeatures\": \"ef\",\n\"shareableInfo\": {\n\"isShareable\": true,\n\"capifProvDoms\": [\n\"mobilesandbox.cloud\"\n]\n},\n\"serviceAPICategory\": \"NEF\",\n\"apiSuppFeats\": \"1fffffff\"\n\"apiProvName\": \"OCF_NEF\"\n}\n5. CAPIF administrator creates policy\nThe procedures for creation of the access control policy at the CAPIF core function by the CAPIF administrator is outside the scope of 3GPP TS 23.222 [2] and can be triggered because of the API management function issuing the \"Register API provider\" request or prior to that. Either way, sufficient information must be provided to enable the AEF specific access control policy list resource for the service API to be created. Specifically, each policy must include the CCF assigned API invoker identifier (apiInvokerId) and can include allowed total invocations (allowedTotalInvocations), invocations per second (allowedInvocationsPerSecond), invocation time range list (allowedInvocationTimeRangeList). Since an API invoker identifier is mandatory, it is a prerequisite that API invoker has been onboarded prior to invoking the highlighted access control policy procedures.\n6. CAPIF_Access_Control_Policy_API\nThe Access Control List (ACL) service allows the provider to use AEF to obtain the access control list from invokers for an exposing API. The provider is in charge of making the request to the CAPIF Core Function and using the list received to control an invoker's access to one of its APIs.\nTable C.1-6: GET access control policy request (schema)\nHTTP GET {apiRoot}/access-control-policy/v1/accessControlPolicyList/{serviceApiId}?aef-id=\"string\"\nThe AEF may make a request to OpenCAPIF to obtain all the ACLs of a service that it is exposing, for this it must specify in the URL of the request the identifier of the service (apiId received in the API Publish response) for which it wants the list of ACLs, in addition to the AEF’s own identifier to check that it has access to that list.\nTable C.1-6-OCF: ACL Request (OCF example)\nHTTP GET https://capif.mobilesandbox.cloud:37211/access-control-policy/v1/accessControlPolicyList/f55731ec5f8ce703ac1f69605ad095?aef-id=AEFb1a522967511fd6d6def0cbb3b5f05\n7. 200 OK\nThe request has been successfully received and the CAPIF Core Function returns the invoker access control information for the requested API. The AEF will use this information to allow or not the use of the API by the invoker.\nTable C.1-7: GET access control policy response (schema)\n200\nResponse body:\n{\n\"apiInvokerPolicies\": [\n{\n\"apiInvokerId\": \"string\",\n\"allowedTotalInvocations\": \"integer\",\n\"allowedInvocationsPerSecond\": \"integer\",\n\"allowedInvocationTimeRangeList\": [\n{\n\"startTime\": \"string\",\n\"stopTime\": \"string\"\n}\n]\n}\n]\n}\nOpenCAPIF provides the access control policy information for the NEF API Published \"3gpp-as-session-with-qos\" containing the following information:\n-\tapiInvokerId: identifier of the invoker to which the access policy belongs.\n-\tallowedTotalInvocations: Total number of invocations allowed on the service API by the API invoker.\n-\tallowedInvocationsPerSecond: invocations per second allowed on the service API by the API invoker.\n-\tallowedInvocationTimeRangeList: the time ranges during which the invocations are allowed on the service API by the API invoker.\nTable C.1-7-OCF: GET access control policy response (OCF example)\n200\nResponse body:\n{\n\"apiInvokerPolicies\": [\n{\n\"apiInvokerId”: \"INVd4d70e16c52bace2b8f40ed6f6badS\",\n\"allowedTotalInvocations\": 1200,\n\"allowedInvocationsPerSecond\": 2,\n\"allowedInvocationTimeRangeList\": [\n{\n\"startTime\": \"2024-08-19T09:00:00.000000+02:00\",\n\"stopTime\": \"2024-08-23T16:00:00.000000+02:00\"\n}\n]\n}\n]\n}\n8. Offboarding API Provider\nThe provider can request its deletion from CAPIF using the offboarding service. By using this service, all information stored in the CAPIF Core Function related to the provider will be deleted, including APIs published by the provider, security contexts of those APIs, ACLs, etc.\nTable C.1-8: DELETE API provider request (schema)\nHTTP DELETE {apiRoot}/api-provider-management/v1/registrations/{registrationId}\nFor the process of deleting a Provider in OpenCAPIF, you will need the AMF certificate and the identifier of the provider that you want to delete. This data is obtained in the provider creation process and by simply making the corresponding request we will eliminate the provider.\nTable C.1-8-OCF: DELETE API provider request (OCF example)\nHTTP DELETE https://capif.mobilesandbox.cloud:37211/api-provider-management/v1/registrations/3a4df5f6e30a5ee34de346004ee6bb\n9. 204 No Content\nThe response will be a 204 No Content, which indicates that the provider has been successfully deleted along with everything related to it, APIs Published, security contexts associated with its services, ACLs of its services, etc.\nC.2\tAPI consumption from an API Invoker\nThis section explains how an API Invoker can use OpenCAPIF [9] to discover and consume APIs, based on 3GPP TS 23.222 [2] and 3GPP TS 29.222 [3] for the schema. The API Invoker application needs to obtain the following information from OpenCAPIF during user registration, similarly to the API Provider onboarding:\n-\tCA_ROOT: Root certificate from the OpenCAPIF Certificate Authority to validate Certificates.\n-\tToken: Token for the API Invoker onboarding request.\n-\tOnboarding URL: URL for requesting the API Invoker onboarding.\nThis section explains:\n-\thow to onboard an API Invoker in OpenCAPIF, to be able to discover all the APIs published in the CAPIF Core Function.\n-\trequest the creation of a security context, which is necessary to consume an API.\n-\trequest the required OAuth token to consume the API; and finally, how to make the request directly to the published API.\nAll the requests shown in this document can be tested using the OpenCAPIF Postman collection found in Annex A and in the OpenCAPIF Postman documentation [12].\nBefore carrying out onboarding, the invoker will need the CAPIF access token that will allow the creation of the invoker, the CA_ROOT certificate necessary to validate all the requests, and the URL to which to make the request <{apiRoot}/api-invoker-management/v1/onboardedInvokers>.\nIn OpenCAPIF, all this information is obtained in the user registration process [13].\nTo onboard an API Invoker in CAPIF, it is necessary to utilize the token received in the Authentication HTTP header. In addition, a Certificate Signing Request (CSR) will have to be created with two keys so that the CAPIF Core Function can issue a valid certificate that will be used by the invoker to be able to make the subsequent requests. In the following example, the {apiList} field has been omitted, as it will discover the APIs that can be used with the discover service.\nTable C.2-1: Register API Invoker request (schema)\nHTTP POST {apiRoot}/api-invoker-management/v1/onboardedInvokers\nRequest headers:\nAuthorization: \"string\"\nRequest body:\n{\n\"onboardingInformation\": {\n\"apiInvokerPublicKey\": \"string\"\n},\n\"notificationDestination\": \"string\",\n\"apiInvokerInformation\": \"string\",\n\"websockNotifConfig\": {\n\"websocketUri\": \"string\",\n\"requestWebsocketURI\": \"boolean\"\n}\n}\nTo perform the onboarding of an API Invoker, the following data will have to be specified:\n-\tapiInvokerPublicKey: It is the certificate signing request of the invoker that CAPIF will use to issue the invoker’s valid certificate.\n-\tapiInvokerInformation: Generic information related to the API invoker such as details of the device or the application\n-\tnotificationDestination: URL where the API invoker can receive CAPIF notifications.\nTable C.2-1-OCF: Register API Invoker request (OCF example)\nHTTP POST https://capif.mobilesandbox.cloud:37211/api-invoker-management/v1/onboardedInvokers/\nRequest headers:\nAuthorization: Bearer eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9\nContent-Type: application/json\nRequest body:\n{\n\"onboardingInformation\": {\n\"apiInvokerPublicKey\": \"-----BEGIN CERTIFICATE REQUEST----- \\nMIICeTCCAWECAQAHISNoGA1ERGAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST----\\n\"\n},\n\"notificationDestination\": \" http://nef_notification_destination:8080/\",\n\"apiInvokerInformation\": \"NEF Invoker\",\n\"websockNotifConfig\": {\n\"websocketUri\": \"websocketUri\",\n\"requestWebsocketURI\": true\n}\n}\nThe CAPIF Core Function assigns an identity for the API invoker (apiInvokerId) and a certificate (apiInvokerCertificate) based on provided public key(apiInvokerPublicKey).\n2. 201 Created\nThe API Invoker has been registered successfully. The URI of the created resource is returned in the “Location” HTTP header including the assigned registration identifier (apiInvokerId).\nTable C.2-2: Register API-Invoker response (schema, then example content)\n201\nResponse headers:\nLocation: {apiRoot}/api-invoker-management/v1/onboardedInvokers/{apiInvokerId}\nResponse body:\n{\n\"apiInvokerId\": \"string\",\n\"onboardingInformation\": {\n\"apiInvokerPublicKey\": \"string\",\n\"apiInvokerCertificate\": \"string\",\n\"onboardingSecret\": \"string\"\n},\n\"notificationDestination\": \"string\",\n\"apiInvokerInformation\": \"string\",\n\"websockNotifConfig\": {\n\"websocketUri\": \"string\",\n\"requestWebsocketURI\": \"boolean\"\n}\n}\nThe fields that are returned when onboarding an invoker, that are populated by the CCF, are:\n-\tapiInvokerId: Identifier of the invoker created.\n-\tapiInvokerCertificate: Certificate of the Invoker created from the CSR sent in the onboarding request, which will be used for the following requests from the Invoker to CAPIF Core Function.\nTable C.2-2-OCF: Register API-Invoker response (OCF example)\nResponse headers:\nLocation: https://capif.mobilesandbox.cloud:37211/api-invoker-management/v1/onboardedInvokers/INVaa03f9911db37be051b243ce3caad9\nResponse body:\n{\n\"apiInvokerId\": \"INVaa03f9911db37be051b243ce3caad9\",\n\"onboardingInformation\": {\n\"apiInvokerPublicKey\": \"-----BEGIN CERTIFICATE REQUEST----- \\nMIICeTCCAWECAQAHISNoGA1ERGAwwDQUGMRcwFQYDVQQ\\n-----END CERTIFICATE REQUEST----\\n\",\n\"apiInvokerCertificate\": \"-----BEGIN CERTIFICATE-----\\nMIIDgjCCAmqgAwIBAgIUS18nvjZYU5B+ptuAw/ x3gQWYEJVxDha9112mP7lclNg5yd5o1Xwj1Imbht2z33ZJ4jxA=\\n-----END CERTIFICATE-----\\n\"\n},\n\"apiInvokerInformation\": \"NEF Invoker\",\n\"websockNotifConfig\": {\n\"websocketUri\": \"websocketUri\",\n\"requestWebsocketURI\": true\n}\n}\n3. CAPIF_Discovery_Service_API\nAfter onboarding the API Invoker, the API Discovery function is used by invokers to obtain all the APIs published in CAPIF, providing all the necessary information that an API Invoker needs to be able to make a request to each such API.\nTable C.2-3: Discover APIs request (schema, then example content)\nHTTP GET {apiRoot}/service-apis/v1/allServiceAPIs?api-invoker-id={apiInvokerId}\nThe API Invoker must make the request to CAPIF using its identifier {apiInvokerId} in order to verify that the invoker is registered in CAPIF.\nTable C.2-3-OCF: Discover APIs request (OCF example)\nHTTP GET https://capif.mobilesandbox.cloud:37211/service-apis/v1/allServiceAPIs?api-invoker-id=INVaa03f9911db37be051b243ce3caad9\n4. OK 200\nUpon successful request, the API Invoker will receive the 200 OK code and all the information about the APIs published in the CAPIF Core Function containing the AEF profiles exposing the APIs. Using this information, the API Invoker can decide which APIs it wants to use.\nTable C.2-4-OCF: Discover APIs response (schema)\n200\nResponse body:{\n\"serviceAPIDescription\":[    {\n\"apiName\": \"string\",\n\"apiId\": \"string\",\n\"apiStatus\": {\n\"aefIds\": [\n\"string\"\n]\n},\n\"aefProfiles\": [\n{\n\"aefId\": \"string\",\n\"versions\": [\n{\n\"apiVersion\": \"string\",\n\"expiry\": \"string\",\n\"resources\": [\n{\n\"resourceName\": \"string\",\n\"commType\": \"string\",\n\"uri\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\"string\"],\n\"description\": \"string\"\n},\n{\n\"resourceName\": \"string\",\n\"commType\": \"string\",\n\"uri\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\"string\"],\n\"description\": \"string\"\n}\n],\n\"custOperations\": [\n{\n\"commType\": \"string\",\n\"custOpName\": \"string\",\n\"operations\": [\n\"string\"\n],\n\"description\": \"string\"\n}\n]\n}\n],\n\"protocol\": \"string\",\n\"dataFormat\": \"string\",\n\"securityMethods\": [\n\"string\",\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"string\",\n\"port\": \"int\",\n\"securityMethods\": [\n\"string\"\n]\n}\n]\n}\n],\n\"description\": \"string\",\n\"supportedFeatures\": \"string\",\n\"shareableInfo\": {\n\"isShareable\": \"boolean\",\n\"capifProvDoms\": [\n\"string\"\n]\n},\n\"serviceAPICategory\": \"string\",\n\"apiSuppFeats\": \"string\",\n\"pubApiPath\": {\n\"ccfIds\": [\n\"string\"\n]\n},\n\"ccfId\": \"string\"\n\"apiProvName\": \"string\"    }\n]\n}\nThe API Invoker will receive a list with the APIs published in CAPIF, including the following information:\n-\tapiName: Name of the published API, which will be unique in CAPIF.\n-\tapiStatus: Represents the API status, in addition, if this attribute is omitted, it is understood that the API is available in all AEFs of aefProfiles. It contains the aefIds field which is a list of the AEFs that expose the API. If this list is empty or the attribute is omitted, it is understood that the API is inactive in all aefProfiles.\n-\taefProfiles: List of Information about AEFs that expose the API. This information contains the following fields:\nOnly domainName or interfaceDescription can be specified.\n-\tsupportedFeatures: Indicates the one or more CAPIF Discover Service API specific supported features (from the three features specified in 3GPP TS 29.222 [3], clause 8.1.6), e.g., support for RNAA functionality.\n-\tshareableinfo: Indicates whether the service API and/or the service API category can be shared to the list of CAPIF provider domains.\n-\tserviceAPICategory: The service API category to which the service API belongs to.\n-\tapiSuppFeats: Indication provided by the consumer (i.e., related to the AEF) which optional features are supported by the service API.\n-\tapiProvName: API provider Name that publishes the API.\nAn example for the Discover APIs response for an NEF that exposes the “3gpp-as-session-with-qos” API is shown in Table C.2-4-OCF, for which there are twenty-nine optional service specific features (apiSuppFeats) specified in 3GPP TS 29.122 [14].\nTable C.2-4-OCF: Discover APIs response (OCF example)\n200\nResponse body:\n{  \"serviceAPIDescription\":[\n{\n\"apiName\": \"3gpp-as-session-with-qos\",\n\"apiId\": \"f55731ec5f8ce703ac1f69605ad095\",\n\"aefProfiles\": [\n{\n\"aefId\": \"string\",\n\"versions\": [\n{\n\"apiVersion\": \"v1\",\n\"expiry\": \"2100-11-30T10:32:02.004Z\",\n\"resources\": [\n{\n\"resourceName\": \"QOS_SUBSCRIPTIONS\",\n\"commType\": \"SUBSCRIBE_NOTIFY\",\n\"uri\": \"/{scsAsId}/subscriptions\",\n\"operations\": [\n\"GET\",\n\"POST\"\n],\n\"description\": \"Endpoint to manage monitoring subscriptions\"\n},\n{\n\"resourceName\": \"QOS_SUBSCRIPTION_SINGLE\",\n\"commType\": \"SUBSCRIBE_NOTIFY\",\n\"uri\": \"/{scsAsId}/subscriptions/{subscriptionId}\",\n\"operations\": [\n\"GET\",\n\"PUT\",\n\"DELETE\"\n],\n\"description\": \"Endpoint to manage single subscription\"\n}\n],\n}\n],\n\"protocol\": \"HTTP_1_1\",\n\"dataFormat\": \"JSON\",\n\"securityMethods\": [\n\"OAUTH\",\n\"PSK\"\n],\n\"interfaceDescriptions\": [\n{\n\"ipv4Addr\": \"127.0.0.1\",\n\"port\": 4443,\n\"securityMethods\": [\n\"OAUTH\"\n]\n}\n]\n}\n],\n\"description\": \"3gpp-as-session-with-qos NEF API\",\n\"supportedFeatures\": \"7\",\n\"shareableInfo\": {\n\"isShareable\": true,\n\"capifProvDoms\": [\n\"mobilesandbox.cloud\"\n]\n},\n\"serviceAPICategory\": \"NEF\",\n\"apiSuppFeats\": \"1fffffff\",\n\"apiProvName\": \"OCF_NEF\"\n}\n]\n}\n5. CAPIF_Security_API\nThis request is responsible for requesting the creation of a security context to be able to use an API. If this step were not carried out, even if the API invoker had the information on an API it wished to use, the token giving access to the API would be missing, which can only be obtained once the security context has been created.\nTable C.2-5: Create Security Context request (schema)\nHTTP PUT {apiRoot}/capif-security/v1/trustedInvokers/{apiInvokerId}\nRequest body:\n{\n\"securityInfo\": [\n{\n\"prefSecurityMethods\": [\n\"string\"\n],\n\"aefId\": \"string\",\n\"apiId\": \"string\",\n\"authenticationInfo\": \"string\",\n\"authorizationInfo\": \"string\"\n}\n],\n\"notificationDestination\": \"string\",\n\"supportedFeatures\": \"string\"\n}\nIn this request we find the following fields:\n-\tsecurityInfo: List of information that represents the details of the interfaces and security methods of the APIs the API invoker wishes to use.\n-\tprefSecurityMethods: List of preferred security methods for using an API. In the examples, OAuth tokens are used.\n-\taefId: Identifier of the API exposing function that expose the API.\n-\tapiId: Identifier of the API that that the API invoker wishes to use.\n-\tnotificationDestination: Address where the notifications should be delivered to.\nThe following example asks for OAUTH as the preferred security method. When this method is selected by the CAPIF Core Function, the API invoker must make another request to obtain the necessary security access token to consume the API.\nTable C.2-5-OCF: Create Security Context request (OCF example)\nHTTP PUT https://capif.mobilesandbox.cloud:37211/capif-security/v1/trustedInvokers/INVaa03f9911db37be051b243ce3caad9\nRequest body:\n{\n\"securityInfo\": [\n{\n\"prefSecurityMethods\": [\"OAUTH\"],\n\"selSecurityMethod\": \"OAUTH\",\n\"aefId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"apiId\": \"f55731ec5f8ce703ac1f69605ad095\",\n\"authenticationInfo\": \"authenticationinfo\",\n\"authorizationInfo\": \"authorizationInfo\"\n}\n],\n\"notificationDestination\": \"http://nef_notification_destination:8080/\",\n\"supportedFeatures\": \"f\"\n}\nOpenCAPIF selects one of the preferred methods to make requests to the API based in AEF profile. In this example, only one Security Method is requested by the API Invoker, so OpenCAPIF checks that this Security Method is supported by the API Exposer.\n6. 201 Created\nThe security context has been created successfully and the security context created with the selected security method is returned in the response body.\nTable C.2-6: Create Security Context response (schema)\n201\nResponse headers:\nLocation: {apiRoot}/capif-security/v1/trustedInvokers/{apiInvokerId}\nResponse body:\n{\n\"securityInfo\": [\n{\n\"prefSecurityMethods\": [\n\"string\"\n],\n\"selSecurityMethod\": \"string\",\n\"aefId\": \"string\",\n\"apiId\": \"string\",\n\"authenticationInfo\": \"string\",\n\"authorizationInfo\": \"string\"\n}\n],\n\"notificationDestination\": \"string\",\n\"supportedFeatures\": \"string\"\n}\nThe {selSecurityMethod} is returned, which specifies the security method that will be used so that the API Invoker can consume the API and the URI of the created resource in the “Location” HTTP header that includes the {apiInvokerId}.\nTable C.2-6-OCF: Create Security Context response (OCF example)\n201\nResponse headers:\nLocation: https://capif.mobilesandbox.cloud:3721/capif-security/v1/trustedInvokers/INVaa03f9911db37be051b243ce3caad9\nResponse body:\n{\n\"securityInfo\": [\n{\n\"prefSecurityMethods\": [\"OAUTH\"],\n\"selSecurityMethod\": \"OAUTH\",\n\"aefId\": \"AEFb1a522967511fd6d6def0cbb3b5f05\",\n\"apiId\": \"f55731ec5f8ce703ac1f69605ad095\",\n\"authenticationInfo\": \"authenticationinfo\",\n\"authorizationInfo\": \"authorizationInfo\"\n}\n],\n\"notificationDestination\": \"http://nef_notification_destination:8080/\",\n\"supportedFeatures\": \"f\"\n}\n7. CAPIF_Security_API (Obtain Token)\nWhen the security method selected is OAUTH in the security context created by the API Invoker, the API Invoker must make a request to the CAPIF Core Function to obtain the access token to consume the API.\nTable C.2-7: Obtain Access Token request (schema, then example content)\nHTTP POST {apiRoot}/capif-security/v1/trustedInvokers/{apiInvokerId}/token\nRequest body:\n{\n\"grantType\": \"string\",\n\"clientId\": \"string\",\n\"scope\": \"string\"\n}\nThe fields necessary to request the access token are:\n-\tgrantType: It is used to specify whether the token request is made by the API Invoker themselves (client_credentials) or for the use of RNAA (authorization_code)\n-\tclientId: Identifier of the invoker that is requesting the token.\n-\tscope: a String that contains a list of AEF identifiers and its associated API names for which the access token is authorized for use. It takes the format of: 3gpp#aefId1:apiName1,apiName2;aefId2:apiName1,apiName2\nThe request to obtain the OAuth token in OpenCAPIF is displayed in the following table:\nTable C.2-7-OCF: Obtain Access Token request (OCF example)\nHTTP POST https://capif.mobilesandbox.cloud:37211/capif-security/v1/trustedInvokers/INVaa03f9911db37be051b243ce3caad9/token\nRequest body:\n{\n\"grantType\": \"client_credentials\",\n\"clientId\": \"INVaa03f9911db37be051b243ce3caad9\",\n\"scope\": \"3gpp#AEFb1a522967511fd6d6def0cbb3b5f05:/nef/api/v1/3gpp-as-session-with-qos\"\n}\n8. 200 OK\nIn response, the API Invoker will obtain the token that is needed to consume the API that was specified in the request.\nTable C.2-8: Obtain Access Token response (schema)\n200\nResponse body:\n{\n\"access_token\": \"string\",\n\"token_type\": \"string\",\n\"expires_in\": \"integer\",\n\"scope\": \"string\"\n}\nThe fields returned in the response are:\n-\taccess_token: OAuth access token necessary to make the request to the selected API.\n-\ttoken_type: Contains the type of token that is returned (i.e. “Bearer”).\n-\texpires_in: Contains the number of seconds after which the access_token expires.\n-\tscope: It is the scope requested in the request and that uses the token to enable the use of an API. It takes the following format: 3gpp#aefId1:apiName1,apiName2;aefId2:apiName1,apiName2\nTable C.2-8-OCF: Obtain Access Token response (OCF example)\n200\nResponse body:\n{\n\"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9\",\n\"token_type\": \"Bearer\",\n\"expires_in\": 600,\n\"scope\": \"3gpp#AEFb1a522967511fd6d6def0cbb3b5f05:3gpp-as-session-with-qos\"\n}\n9. CAPIF_API_Invocation\nThe API invoker’s request to the consuming API does not go through CAPIF, rather it is made directly to the API Exposer. For this request, the data obtained from AEF Profile in the Discover request is used (IP/hostname, port, endpoint, method, etc...), it is also necessary to use the access token obtained from CAPIF that will be in the header of the request.\nAs an example, the request is to the API that has been published as a NEF provider and the OAuth token that has been obtained as an API Invoker.\nTable C.2-9: Invoke API request (schema)\nHTTP {operation} {ipv4Addr}:{port}{uri}\nRequest headers:\nAuthorization: \"string\"Content-Type: \"string\"\nRequest body:\n{\nAPI BODY\n}\nTo make the request to the API, the access token obtained from the CAPIF Core Function must be entered in the Authorization header, from there, everything depends on the description of the published API.\nEach description contains either the ipv4Addr or the domainName, both along with the port to which the request can be made. Also, depending on the resource to be called, the appropriate operation and uri specific to that resource. This is in addition to having to pass data and use the format according to the dataFormat field and also specifying this format in the header.\nThe following example shows how an invoker would use the NEF API that has been published:\nTable C.2-9-OCF: Invoke API request (OCF example)\nHTTP POST https://127.0.0.1:4443/nef/api/3gpp-as-session-with-qos/v1/{scsAsId}/subscriptions\nRequest headers:\nAuthorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9Content-Type: \"application/json\"\nRequest body:\n{\n\"ipv4Addr\": \"10.0.0.3\",\n\"notificationDestination\": \"http://localhost:80/api/v1/utils/session-with-qos/callback\",\n\"snssai\": {\n\"sst\": 1,\n\"sd\": \"000001\"\n},\n\"dnn\": \"province1.mnc01.mcc202.gprs\",\n\"qosReference\": 9,\n\"altQoSReferences\": [0],\n\"qosMonInfo\": {\n\"reqQosMonParams\": [\"DOWNLINK\"],\n\"repFreqs\": [\"EVENT_TRIGGERED\"],\n\"repThreshDl\": 20,\n\"repThreshUl\": 20,\n\"repThreshRp\": 50,\n\"waitTime\": 2,\n\"repPeriod\": 3\n}\n}\nThis would make a request to the NEF API that was used as an example. In this case, the API Invoker would receive the code 201 Created as it is used to create a subscription to the AsSessionWithQoS.\n10. CAPIF_API_Invoker_Management (Deregistration)\nThe invoker can request its deletion from CAPIF using the offboarding service. By using this service, all information stored in the CAPIF Core Function related to the invoker will be deleted, including all the security contexts created for the APIs, ACLs, events subscriptions, etc.\nTable C.2-10: DELETE API Invoker request (schema, then example content)\nHTTP DELETE {apiRoot}/api-invoker-management/v1/onboardedInvokers/{apiInvokerId}\nFor the process of deleting an invoker in CAPIF, the certificate and identifier of the invoker to be deleted is required. That information is obtained through the invoker creation process. Then by making the following request, the invoker is eliminated.\nTable C.2-10-OCF: DELETE API Invoker request (OCF example)\nHTTP DELETE https://capif.mobilesandbox.cloud:37211/api-invoker-management/v1/onboardedInvokers/INVaa03f9911db37be051b243ce3caad9\n11. 204 No Content\nThe successful response will be a 204 No Content, which indicates that the invoker has been successfully deleted along with everything related to it: security context of the APIs; ACLs of the services; events subscriptions etc.\nAnnex D:CAPIF Test cases\nD.1\tGeneral\nThis Annex contains CAPIF test cases including the expected responses from CCF. The test cases defined enable testing not only the success responses (200, 201, 204) but also error codes as defined in 3GPP TS 29.222 [3] Annex A (normative) OpenAPI specification. These test cases are aligned with 3GPP TS 29.222 [3].\nThe annex defines tests for the following CAPIF APIs:\nD.2\tTest Plan for CAPIF API Invoker Management\nThis section list test cases for the CAPIF_API_Invoker_Management_API.\nTest Case 1: Onboard Invoker\nTest ID\ncapif_api_invoker_management-1\nDescription\nThis test will try to register a new Invoker at CAPIF Core\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Onboard Invoker Already onboarded\nTest ID\ncapif_api_invoker_management-2\nDescription\nThis test will check second onboard of same Invoker is not allowed.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Update Onboarded Invoker\nTest ID\ncapif_api_invoker_management-3\nDescription\nThis test will try to update information of previous onboard Invoker at CAPIF Core.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was onboarded previously with {onboardingId}\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Update Not Onboarded Invoker\nTest ID\ncapif_api_invoker_management-4\nDescription\nThis test will try to update information of not onboarded Invoker at CAPIF Core.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Offboard Invoker\nTest ID\ncapif_api_invoker_management-5\nDescription\nThis test case will check that a Registered Invoker can be deleted.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: Offboard Not previously Onboarded Invoker\nTest ID\ncapif_api_invoker_management-6\nDescription\nThis test case will check that a Non-Registered Network App cannot be deleted.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 7: Update Onboarded Invoker Certificate\nTest ID\ncapif_api_invoker_management-7\nDescription\nThis test will try to update public key and get a new signed certificate by CAPIF Core.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Invoker was onboarded previously with {onboardingId}\nExecution Steps\nInformation of Test\nExpected Result\nD.3\tTest Plan for CAPIF API Provider Management\nThis section list test cases for the CAPIF_API_Provider_Management_API.\nTest Case 1: Onboard API Provider\nTest ID\ncapif_api_provider_management-1\nDescription\nThis test case will check that Api Provider can be registered at CCF\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Onboard API Provider Already Onboarded\nTest ID\ncapif_api_provider_management-2\nDescription\nThis test case will check that an API Provider previously registered cannot be re-registered\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Update Onboarded API Provider\nTest ID\ncapif_api_provider_management-3\nDescription\nThis test case will check that a Registered API Provider can be updated\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Update API Provider Not Onboarded\nTest ID\ncapif_api_provider_management-2\nDescription\nThis test case will check that a Non-Registered API Provider cannot be updated\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Partially Update Onboarded API Provider\nTest ID\ncapif_api_provider_management-5\nDescription\nThis test case will check that a Registered API Provider can be partially updated\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: Partially Update API Provider Not Onboarded\nTest ID\ncapif_api_provider_management-6\nDescription\nThis test case will check that a Non-Registered API Provider cannot be partially updated\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 7: Delete Onboarded API Provider\nTest ID\ncapif_api_provider_management-7\nDescription\nThis test case will check that a Registered API Provider can be deleted\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 8: Delete not Onboarded API Provider\nTest ID\ncapif_api_provider_management-8\nDescription\nThis test case will check that a Non-Registered API Provider cannot be deleted\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was not onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nD.4\tTest Plan for CAPIF API Publish Service\nThis section list test cases for the CAPIF_Publish_Service_API.\nTest Case 1: Publish API by Authorised API Publisher\nTest ID\ncapif_api_publish_service-1\nDescription\nThis test case will check that an API Publisher can Publish an API\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previously\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Publish API by NON-Authorised API Publisher\nTest ID\ncapif_api_publish_service-2\nDescription\nThis test case will check that an API Publisher cannot Publish an API without valid apfId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was not onboarded\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Retrieve all APIs Published by Authorised API Publisher\nTest ID\ncapif_api_publish_service-3\nDescription\nThis test case will check that an API Publisher can Retrieve all API published\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyAt least 2 services APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Retrieve all APIs Published by NON Authorised API Publisher\nTest ID\ncapif_api_publish_service-4\nDescription\nThis test case will check that an API Publisher cannot Retrieve API published when apfId is not authorised\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was not onboarded previouslyAt least 2 services APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Retrieve single APIs Published by Authorised API Publisher\nTest ID\ncapif_api_publish_service-5\nDescription\nThis test case will check that an API Publisher can Retrieve API published one by one\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyAt least 2 services APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: Retrieve single APIs NON Published by Authorised API Publisher\nTest ID\ncapif_api_publish_service-6\nDescription\nThis test case will check that an API Publisher try to get detail of not published API.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyNo published API.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 7: Retrieve single APIs Published by NON Authorised API Publisher\nTest ID\ncapif_api_publish_service-7\nDescription\nThis test case will check that an API Publisher cannot Retrieve detailed API published when apfId is not authorised\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.The user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Provider was onboarded Invoker was onboarded\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 8: Update API Published by Authorised API Publisher with valid serviceApiId\nTest ID\ncapif_api_publish_service-8\nDescription\nThis test case will check that an API Publisher can Update published API with a valid serviceApiId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyA service APIs is published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 9: Update API Published by Authorised API Publisher with invalid serviceApiId\nTest ID\ncapif_api_publish_service-9\nDescription\nThis test case will check that an API Publisher cannot Update published API with a invalid serviceApiId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyA service API is published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 10: Update API Published by NON Authorised API Publisher\nTest ID\ncapif_api_publish_service-10\nDescription\nThis test case will check that an API Publisher cannot Update API published when apfId is not authorised\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.The user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Provider was onboarded Invoker was onboarded\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 11: Delete API Published by Authorised API Publisher with valid serviceApiId\nTest ID\ncapif_api_publish_service-11\nDescription\nThis test case will check that an API Publisher can Delete published API with a valid serviceApiId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyA service API is published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 12: Delete API Published by Authorised API Publisher with invalid serviceApiId\nTest ID\ncapif_api_publish_service-12\nDescription\nThis test case will check that an API Publisher cannot Delete with invalid serviceApiId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyA service API is published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 13: Delete API Published by NON Authorised API Publisher with valid serviceApiId\nTest ID\ncapif_api_publish_service-12\nDescription\nThis test case will check that an API Publisher cannot Delete with invalid serviceApiId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard a Provider.Provider was onboarded previouslyA service APIs is published\nExecution Steps\nInformation of Test\nExpected Result\nD.5\tTest Plan for CAPIF Discover Service API\nThis section list test cases for the CAPIF_Discover_Service_API.\nTest Case 1: Discover Published Service Apis by Authorised Invoker\nTest ID\ncapif_api_discover _service-1\nDescription\nThis test case will check if Invoker can discover published service APIs.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Service APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Discover Published Service APIs by Non Authorised Invoker\nTest ID\ncapif_api_discover _service-2\nDescription\nThis test case will check that an API Publisher can't discover published APIs because is not authorized.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Service APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Discover Published Service APIs by Not Registered API Invoker\nTest ID\ncapif_api_discover _service-3\nDescription\nThis test case will check that a not registered invoker is forbidden to discover published APIs.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.Service APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Discover Published Service APIs by Authorised Invoker with 1 result filtered\nTest ID\ncapif_api_discover _service-4\nDescription\nThis test case will check if Invoker can discover published service APIs\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.At least 2 Service APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Discover Published Service APIs by Authorised Invoker with no match\nTest ID\ncapif_api_discover _service-5\nDescription\nThis test case will check if Invoker can discover published service APIs.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.At least 2 Service APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: Discover Published Service APIs by Authorised Invoker not filtered\nTest ID\ncapif_api_discover _service-6\nDescription\nThis test case will check if Invoker can discover published service APIs.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.At least 2 Service APIs are published\nExecution Steps\nInformation of Test\nExpected Result\nD.6\tTest Plan for CAPIF API Security Service\nThis section list test cases for the CAPIF_Security_API.\nTest Case 1: Creates a Security Context for an API Invoker\nTest ID\ncapif_api_security-1\nDescription\nThis test case will check that an API Invoker can create a Security context\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Creates a Security Context for an API Invoker with provider role\nTest ID\ncapif_api_security-2\nDescription\nThis test case will check that a Provider cannot create a Security context with valid apiInvokerId.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Creates a Security Context for an API Invoker with provider role and invalid apiInvokerId\nTest ID\ncapif_api_security-3\nDescription\nThis test case will check that a Provider cannot create a Security context with invalid apiInvokerID.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Creates a Security Context for an API Invoker with Invoker role and invalid apiInvokerId\nTest ID\ncapif_api_security-4\nDescription\nThis test case will check that an Invoker cannot create a Security context with valid apiInvokerId.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: retrieve the Security Context of an API Invoker\nTest ID\ncapif_api_security-5\nDescription\nThis test case will check that a provider can retrieve the Security context of an API Invoker\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: retrieve the Security Context of an API Invoker with invalid apiInvokerId\nTest ID\ncapif_api_security-6\nDescription\nThis test case will check that a provider can retrieve the Security context of an API Invoker\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 7: Retrieve the Security Context of an API Invoker with invalid apfId\nTest ID\ncapif_api_security-7\nDescription\nThis test case will check that a provider cannot retrieve the Security context of an API Invoker without valid apfId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 8: Delete the Security Context of an API Invoker\nTest ID\ncapif_api_security-8\nDescription\nThis test case will check that a provider can delete a Security context\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 9: Delete the Security Context of an API Invoker with Invoker entity role\nTest ID\ncapif_api_security-9\nDescription\nThis test case will check that an Invoker cannot delete a Security context\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 10: Delete the Security Context of an API Invoker with Invoker entity role and invalid apiInvokerId\nTest ID\ncapif_api_security-10\nDescription\nThis test case will check that an Invoker cannot delete a Security context with invalid apiInvokerId.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 11: Delete the Security Context of an API Invoker with invalid apiInvokerId\nTest ID\ncapif_api_security-11\nDescription\nThis test case will check that an Provider cannot delete a Security context of invalid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 12: Update the Security Context of an API Invoker\nTest ID\ncapif_api_security-12\nDescription\nThis test case will check that an API Invoker can update a Security context\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 13: Update the Security Context of an API Invoker with provider entity role\nTest ID\ncapif_api_security-13\nDescription\nThis test case will check that a provider cannot update a Security context\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 14: Update the Security Context of an API Invoker with provider entity role and invalid apiInvokerId\nTest ID\ncapif_api_security-14\nDescription\nThis test case will check that a provider cannot update a Security context of invalid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 15: Update the Security Context of an API Invoker with invalid apiInvokerId\nTest ID\ncapif_api_security-15\nDescription\nThis test case will check that an API Invoker cannot update a Security context not valid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 16: Revoke the authorization of the API Invoker for APIs\nTest ID\ncapif_api_security-16\nDescription\nThis test case will check that a Provider can revoke the authorization for APIs\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 17: Revoke the authorization of the API Invoker for APIs without valid apfId\nTest ID\ncapif_api_security-17\nDescription\nThis test case will check that an Invoker can't revoke the authorization for APIs\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 18: Revoke the authorization of the API Invoker for APIs with invalid apiInvokerId\nTest ID\ncapif_api_security-18\nDescription\nThis test case will check that an API Exposure Function cannot revoke the authorization for APIs for invalid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 19: Retrieve access token\nTest ID\ncapif_api_security-19\nDescription\nThis test case will check that an API Invoker can retrieve a security access token OAuth 2.0.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 20: Retrieve access token by provider\nTest ID\ncapif_api_security-20\nDescription\nThis test case will check that an API Provider cannot retrieve a security access token OAuth 2.0.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 21: Retrieve access token by provider with invalid apiInvokerId\nTest ID\ncapif_api_security-21\nDescription\nThis test case will check that an API Exposure Function cannot retrieve a security access token without valid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 22: Retrieve access token with invalid apiInvokerId\nTest ID\ncapif_api_security-22\nDescription\nThis test case will check that an API Invoker can't retrieve a security access token without valid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 23: Retrieve access token with invalid client_id\nTest ID\ncapif_api_security-23\nDescription\nThis test case will check that an API Exposure Function cannot retrieve a security access token without valid client_id at body\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 24: Retrieve access token with unsupported grant_type\nTest ID\ncapif_api_security-24\nDescription\nThis test case will check that an API Exposure Function cannot retrieve a security access token with unsupported grant_type\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 25: Retrieve access token with invalid scope\nTest ID\ncapif_api_security-25\nDescription\nThis test case will check that an API Exposure Function cannot retrieve a security access token with complete invalid scope\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 26: Retrieve access token with invalid aefId at scope\nTest ID\ncapif_api_security-26\nDescription\nThis test case will check that an API Exposure Function cannot retrieve a security access token with invalid aefId at scope\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 27: Retrieve access token with invalid apiName at scope\nTest ID\ncapif_api_security-27\nDescription\nThis test case will check that an API Exposure Function cannot retrieve a security access token with invalid apiName at scope\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nAPI Invoker has created a valid Security Context\nExecution Steps\nInformation of Test\nExpected Result\nD.7\t\tTest Plan for CAPIF API Access Control Policy Service\nThis section list test cases for the CAPIF_Access_Control_Policy_API.\nTest Case 1: Retrieve ACL\nTest ID\ncapif_api_acl -1\nDescription\nThis test case will check that an API Provider can retrieve ACL from CAPIF\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Retrieve ACL with 2 Service APIs published\nTest ID\ncapif_api_acl-2\nDescription\nThis test case will check that an API Provider can retrieve ACL from CAPIF for 2 different serviceApis published.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nServices API published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Retrieve ACL with security context created by two different Invokers\nTest ID\ncapif_api_acl-3\nDescription\nThis test case will check that an API Provider can retrieve ACL from CAPIF containing 2 objects.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService API published in CAPIF\nSecurity context created by two API Invokers for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Retrieve ACL filtered by api-invoker-id\nTest ID\ncapif_api_acl-4\nDescription\nThis test case will check that an API Provider can retrieve ACL filtering by apiInvokerId from CAPIF containing 1 objects.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService API published in CAPIF\nSecurity context created by two API Invokers for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Retrieve ACL filtered by supported-features\nTest ID\ncapif_api_acl-5\nDescription\nThis test case will check that an API Provider can retrieve ACL filtering by supportedFeatures from CAPIF containing 1 objects.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService API published in CAPIF\nSecurity context created by two API Invokers for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: Retrieve ACL with aef-id not valid\nTest ID\ncapif_api_acl -6\nDescription\nThis test case will check that an API Provider can't retrieve ACL from CAPIF if aef-id is not valid\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 7: Retrieve ACL with service-id not valid\nTest ID\ncapif_api_acl -7\nDescription\nThis test case will check that an API Provider can't retrieve ACL from CAPIF if service-api-id is not valid\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 8: Retrieve ACL with service-id and aef-id not valid\nTest ID\ncapif_api_acl -8\nDescription\nThis test case will check that an API Provider can't retrieve ACL from CAPIF if service-api-id and aef-id are not valid\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 9: Retrieve ACL without Security Context created previously by Invoker\nTest ID\ncapif_api_acl -9\nDescription\nThis test case will check that an API Provider can't retrieve ACL if no invoker had requested Security Context to CAPIF\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context not created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 10: Retrieve ACL filtered by api-invoker-id not present\nTest ID\ncapif_api_acl -10\nDescription\nThis test case will check that an API Provider get not found response if filter by not valid api-invoker-id doesn't match any registered ACL.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 11: Retrieve ACL with APF Certificate\nTest ID\ncapif_api_acl -11\nDescription\nThis test case will check that an API Provider can't retrieve ACL from CAPIF using APF Certificate\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 12: Retrieve ACL with AMF Certificate\nTest ID\ncapif_api_acl -12\nDescription\nThis test case will check that an API Provider can't retrieve ACL from CAPIF using AMF Certificate\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 13: Retrieve ACL with Invoker Certificate\nTest ID\ncapif_api_acl -13\nDescription\nThis test case will check that an API Provider can't retrieve ACL from CAPIF using Invoker Certificate\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 14: No ACL for invoker after being removed\nTest ID\ncapif_api_acl -14\nDescription\nThis test case will check that ACLs are removed after invoker is removed.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nSecurity context created for Service API published\nExecution Steps\nInformation of Test\nExpected Result\nD.8\tTest Plan for CAPIF API Logging Service\nThis section list test cases for the CAPIF_Logging_API_Invocation_API.\nTest Case 1: Creates a new individual CAPIF Log Entry\nTest ID\ncapif_api_logging -1\nDescription\nThis test case will check that a CAPIF AEF can create log entry to Logging Service\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Creates a new individual CAPIF Log Entry with invalid aefId\nTest ID\ncapif_api_logging -2\nDescription\nThis test case will check that a CAPIF subscriber (AEF) cannot create Log Entry without valid aefId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Creates a new individual CAPIF Log Entry with invalid serviceAPI\nTest ID\ncapif_api_logging-3\nDescription\nThis test case will check that a CAPIF subscriber (AEF) cannot create Log Entry without valid aefId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Creates a new individual CAPIF Log Entry with invalid apiInvokerId\nTest ID\ncapif_api_logging-4\nDescription\nThis test case will check that a CAPIF subscriber (AEF) cannot create Log Entry without valid apiInvokerId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Creates a new individual CAPIF Log Entry with invalid aefId in body\nTest ID\ncapif_api_logging-5\nDescription\nThis test case will check that a CAPIF subscriber (AEF) cannot create Log Entry without valid aefId in body\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nD.9\tTest Plan for CAPIF API Events Service\nThis section list test cases for the CAPIF_Events_API.\nTest Case 1: Creates a New Individual CAPIF Event Subscription\nTest ID\ncapif_api_events-1\nDescription\nThis test case will check that a CAPIF subscriber (Invoker or Provider) can Subscribe to Events\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker or Provider.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Creates a New Individual CAPIF Event Subscription with invalid subscriberId\nTest ID\ncapif_api_events-2\nDescription\nThis test case will check that a CAPIF subscriber (Invoker or Publisher) cannot Subscribe to Events without valid SubcriberId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker or Provider.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Delete an Individual CAPIF Event Subscription\nTest ID\ncapif_api_events-3\nDescription\nThis test case will check that a CAPIF subscriber (Invoker or Publisher) can Delete an Event Subscription\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker or Provider.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Delete an Individual CAPIF Event Subscription with an Invalid subscriberId\nTest ID\ncapif_api_events-4\nDescription\nThis test case will check that a CAPIF subscriber (Invoker or Publisher) cannot Delete to Events without valid SubcriberId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker or Provider.CAPIF subscriber is subscribed to Events.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Delete an Individual CAPIF Event Subscription with an Invalid subscriptionId\nTest ID\ncapif_api_events-5\nDescription\nThis test case will check that a CAPIF subscriber (Invoker or Publisher) cannot Delete an Event Subscription without valid SubscriptionId\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker or Provider.\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 6: Invoker receives Service API invocation Events\nTest ID\ncapif_api_events-6\nDescription\nThis test case will check that a CAPIF Invoker subscribed to SERVICE_API_INVOCATION_SUCCESS and SERVICE_API_INVOCATION_FAILURE, receive the notification when AEF Send TO logging service result of invocations to their APIs.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 7: Invoker subscribe to Service API Available and Unavailable events\nTest ID\ncapif_api_events-7\nDescription\nThis test case will check that a CAPIF Invoker subscribed to SERVICE_API_AVAILABLE and SERVICE_API_UNAVAILABLE, receive the notification when AEF publish and remove it.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 8: Invoker subscribe to Service API Update\nTest ID\ncapif_api_events-8\nDescription\nThis test case will check that a CAPIF Invoker subscribed to SERVICE_API_UPDATE, receive the notification when AEF Update some information on API Published.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 9: Provider subscribe to API Invoker Events\nTest ID\ncapif_api_events-9\nDescription\nThis test case will check that a CAPIF Provider subscribed to API Invoker events (API_INVOKER_ONBOARDED, API_INVOKER_UPDATED and API_INVOKER_OFFBOARDED), receive the notifications when Invoker is onboarded, updated and removed respectively.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 10: Provider subscribe to ACL Update event\nTest ID\ncapif_api_events-10\nDescription\nThis test case will check that a CAPIF Provider subscribed to ACCESS_CONTROL_POLICY_UPDATE receive a notification when ACL Changes.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFAPI Invoker had a Security Context for the Service API published by ProviderMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 11: Provider receives an ACL unavailable event when invoker removes Security Context\nTest ID\ncapif_api_events-11\nDescription\nThis test case will check that a CAPIF Invoker subscribed to ACCESS_CONTROL_POLICY_UNAVAILABLE will receive the notification when AEF remove Security Context created previously.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFAPI Invoker had a Security Context for the Service API published by ProviderMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 12: invoker receives an invoker Authorization Revoked and ACL unavailable event when Provider revoke Invoker Authorization\nTest ID\ncapif_api_events-12\nDescription\nThis test case will check that a CAPIF Invoker subscribed to API_INVOKER_AUTHORIZATION_REVOKED and ACCESS_CONTROL_POLICY_UNAVAILABLE receive both notification when AEF revoke invoker's authorization.\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker and Provider.Provider had a Service API published on CAPIFAPI Invoker had a Security Context for the Service API published by ProviderMock Server is up and running to receive requests.Mock Server is clean\nExecution Steps\nInformation of Test\nExpected Result\nD.10\tTest Plan for CAPIF API Auditing Service\nThis section list test cases for the CAPIF_Auditing_API.\nTest Case 1: Get CAPIF Log Entry\nTest ID\ncapif_api_auditing-1\nDescription\nThis test case will check that a CAPIF AMF can get log entry to Logging Service\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nLog Entry exist in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 2: Get CAPIF Log Entry With no Log entry in CAPIF\nTest ID\ncapif_api_auditing-2\nDescription\nThis test case will check that a CAPIF AEF cannot get log entry to Logging Service\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 3: Get CAPIF Log Entry without aef-id and api-invoker-id\nTest ID\ncapif_api_auditing-3\nDescription\nThis test case will check that a CAPIF AMF cannot get log entry to Logging Service\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nLog Entry exist in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 4: Get CAPIF Log Entry with filter api-version\nTest ID\ncapif_api_auditing-4\nDescription\nThis test case will check that a CAPIF AMF can get log entry to Logging Service with filter api-version\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nLog Entry exist in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nTest Case 5: Get CAPIF Log Entry with filter api-version but not exist in log entry\nTest ID\ncapif_api_auditing-5\nDescription\nThis test case will check that a CAPIF AMF cannot get log entry to Logging Service with filter api-version\nPre-conditions\nThe Administrator must have previously registered the UserThe user must have the access token, the ca root certificate and the URLs to onboard an Invoker.\nService published in CAPIF\nLog Entry exist in CAPIF\nExecution Steps\nInformation of Test\nExpected Result\nAnnex E:Change history\nChange history\nDate\nMeeting\nTDoc\nCR\nRev\nCat\nSubject/Comment\nNew version\n2023-10\nSA6#57\nTR Initial Version as per S6-233407\n0.0.0\n2023-10\nSA6#57\nImplementation of the following pCRs approved by SA6:\nS6-233386\n0.1.0\n2023-11\nSA6#58\nImplementation of the following pCRs approved by SA6:\nS6-233904, S6-233908, S6-233909, S6-233910.\n0.2.0\n2024-03\nSA6#59\nImplementation of the following pCRs approved by SA6:\nS6-240528, S6-240529, S6-240531, S6-240533, S6-240582.\n0.3.0\n2024-04\nSA6#60\nImplementation of the following pCRs approved by SA6:\nS6-241358, S6-241351.\n0.4.0\n2024-05\nSA6#61\nImplementation of the following pCRs approved by SA6:\nS6-242323, S6-242703, S6-242704, S6-242705.\n0.5.0\n2024-08\nSA6#62\nImplementation of the following pCRs approved by SA6:\nS6-243646, S6-243061, S6-243062, S6-243724, S6-243518, S6-243628, S6-243629, S6-243067, S6-243519, S6-243069, S6-243631, S6-243265, S6-243510, S6-243633.\n0.6.0\n2024-10\nSA6#63\nImplementation of the following pCRs approved by SA6:\nS6-244167, S6-244198, S6-244557, S6-244558, S6-244559, S6-244560, S6-244561.\n0.7.0\n2024-11\nSA6#64\nImplementation of the following pCRs approved by SA6:\nS6-245431, S6-245434, S6-245645, S6-245665.\n0.8.0\n2024-11\nSA6#64\nImplementation of the following pCR approved by SA6 on email approval:\nS6-245722, restructuring prior to initial publication.\n0.9.0\n2024-12\nSA#106\nSP-241701\nSubmitted to SA#106 for information and approval\n1.0.0\n2024-12\nSA#106\nSP-241701\nMCC Editorial update for publication after TSG SA approval (SA#106)\n18.0.0\n2025-03\nSA#107\nSP-250200\n0001\n2\nF\nCAPIF supported features\n18.1.0\n2025-03\nSA#107\nSP-250200\n0002\n1\nF\nCorrection to obtaining CAPIF credentials\n18.1.0",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.122_clause_5.2.13.2",
        "ts_29.122_clause_5.2.13.3",
        "ts_29.222_clause_8.2.6",
        "ts_29.222_clause_8.1.6",
        "ts_29.122",
        "ts_29.222",
        "ts_23.222"
      ]
    }
  ]
}