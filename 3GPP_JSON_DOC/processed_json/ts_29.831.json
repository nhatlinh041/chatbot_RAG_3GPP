{
  "metadata": {
    "specification_id": "ts_29.831",
    "version": "Unknown",
    "title": "3GPP TS 29.831",
    "file_path": "/content/drive/MyDrive/RAG_thesis/data/29_series/29831-i00/29831-i00.docx"
  },
  "export_info": {
    "export_date": "2025-07-26T08:49:42.235958",
    "total_chunks": 79
  },
  "chunks": [
    {
      "chunk_id": "ts_29.831_1",
      "section_id": "1",
      "section_title": "Scope",
      "content": "The present document identifies deficiencies of the NRF APIs as specified in 3GPP TS 29.510 [2] and studies potential optimization solutions. The document will focus on the following aspects:\n-avoid data storage overhead in the NRF due to many NFs (especially NFs from the same NF set) registering with identical information,\n-avoid signalling overhead (both in terms of payload size and number of HTTP requests) due to discovery responses containing lots of duplicate information and due to the number of data change notification sent when duplicated data are changed one by one.\n-avoid processing overhead (both at NRF and its consumers) resulting e.g. from signalling overhead.",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.510"
      ]
    },
    {
      "chunk_id": "ts_29.831_2",
      "section_id": "2",
      "section_title": "References",
      "content": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non‑specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 29.510: \"Network Function Repository Services; Stage 3\".\n[3]\t3GPP TS 23.501: \"System Architecture for the 5G System; Stage 2\".",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905",
        "ts_29.510",
        "ts_23.501"
      ]
    },
    {
      "chunk_id": "ts_29.831_3.1",
      "section_id": "3.1",
      "section_title": "Terms",
      "content": "For the purposes of the present document, the terms given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\nvoid",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905"
      ]
    },
    {
      "chunk_id": "ts_29.831_3.2",
      "section_id": "3.2",
      "section_title": "Symbols",
      "content": "For the purposes of the present document, the following symbols apply:\nvoid",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_3.3",
      "section_id": "3.3",
      "section_title": "Abbreviations",
      "content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\nvoid",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905"
      ]
    },
    {
      "chunk_id": "ts_29.831_4.1",
      "section_id": "4.1",
      "section_title": "General",
      "content": "In order to assist mobile network’s needs of service governance (e.g. topology selection, signalling routing), the NRF API system is designed to support mechanisms including service registration, discovery, subscription, and notification. However, in current NRF framework, duplicated network-level attribute values and UE ranges are separately maintained between different NFs, and transmissions of full NF profiles are repeatedly performed, resulting in overhead of data storage, signalling, and processing. See Section 4.2, 4.3, and 4.4 for details.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.2"
      ]
    },
    {
      "chunk_id": "ts_29.831_4.2",
      "section_id": "4.2",
      "section_title": "Data Storage Overhead",
      "content": "Firstly, in the mobile network, to achieve load balancing and high availability, it is common that multiple NFs serving the same geographical region (e.g., NFs within a same NF Set) are assigned by O&M with identical network-level service attribute values (e.g. TAI-list, DNN). In this case, the NFs’ registration to a same NRF introduces redundant storage of many partially or fully duplicated NF profiles.\nSecondly, current NRF API system maintains UE identifier ranges in NFs, although the attribute of the ranges is a global concept rather than per-NF’s. In large-scale network, the attribute can contain millions of UEs and achieve several million bytes, resulting in NFs’ storage overhead. Moreover, when these NFs perform registration, multiple copies of the same ranges will occur simultaneously in the NRF’s storage.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_4.3",
      "section_id": "4.3",
      "section_title": "Signalling Overhead",
      "content": "Data size is the first reason for signalling overhead. The current NRF API system supports only single-layer query view. During registration, discovery and notification processes, full NF profiles with huge size have to be submitted or retrieved at one time. Take signalling routing in some large-scale network as an example, huge full information is provided, containing millions of UE ranges, leading to huge-size (typically several million bytes) frame overhead. Moreover, as stated in Section 4.2, these huge NF profiles can contain a lot of duplicated data, which further makes the overhead unnecessary.\nTransmission range and frequency is another two reasons for signalling overhead. In current NRF framework, even the tiny change of a subscribed network element can trigger large-scale notifications. To distribute the full NF profile to all related subscribers simultaneously, the NRF can easily trigger a push storm and become a performance bottleneck.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.2"
      ]
    },
    {
      "chunk_id": "ts_29.831_4.4",
      "section_id": "4.4",
      "section_title": "Processing Overhead",
      "content": "The receiving, parsing, and handling of redundant information as stated in Section 4.2 and 4.3 apparently increase processing overhead. Moreover, when network elements are pulled up in batches and concurrent registration or discovery happens, the intensive transmission of many full NF profiles will make not only the NRF but also NFs suffer from performance fluctuations.",
      "chunk_type": "procedure",
      "cross_references": [
        "clause_4.2"
      ]
    },
    {
      "chunk_id": "ts_29.831_5.1.1",
      "section_id": "5.1.1",
      "section_title": "Description of the use case",
      "content": "In existing NF profile stored in the NRF, operator may configure same data part of the NF profile with same value to multiple NFs, as per network management requirement.\nFor example, multiple NFs (e.g. AUSF/UDM/PCF/BSF/CHF) may be configured to serve same range of UEs and thus be configured with same UE identifier ranges (e.g. SUPI/GPSI/External ID ranges) in each NF profile. These UE identifier ranges configured in the NF profile may have large volume, and operator needs to configure such large volume data to those indicated multiple NFs (e.g. same type of NFs in a NF Set, or even different type of NFs).\nAs another example, NFs of an NF set share typically a significant set of common data. Common information include the authorization parameters (“allowedxxx parameters”), the served PLMN or SNPN, the supported S-NSSAIs, SCP information, part or all of NF specific data such as amfInfo (e.g. list of TAIs), udminfo (e.g. subscriber identity ranges), smfinfo (e.g. all S-NSSAIs/DNNs configuration supported by the SMF set).\nSuch duplicate data (e.g. UE identifier ranges or NF instance profiles) introduces complexity to the NRF API and OAM system (e.g. to manage the configuring, updating, and downloading of duplicate data (e.g. UE identifier ranges or NF instance profiles). Meanwhile, this duplicate data (e.g. UE identifier ranges or NF instance profiles) reduces the signaling efficiency of NRF API, especially when the duplicate data (e.g. UE identifier ranges or NF instance profiles) have large volume e.g. upper to x million octets.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_5.1.2",
      "section_id": "5.1.2",
      "section_title": "Key issue definition",
      "content": "This key issue will study the following aspects:\n-\tWhich data part in the NF profile can be organized as shared data and used by multiple NFs and whether such categorization needs to be standardized?\n-\tHow to configure/register shared data (e.g. UE identifier ranges) in the NRF so that multiple NF profiles can share the same data (e.g. UE identifier ranges) and avoid duplicate storage/configuration/registration;\n-\tHow to optimize download of shared data (e.g. UE identifier ranges) to the requesting NF during NF discovery procedure or NF profile change notification procedure;\n-\tHow to handle the download shared data (e.g. UE identifier ranges) with large data volume, e.g. upper to x million octets (extremely upper to 16 million octets exceeding the maximum data size of JSON object).\n-\tHow to leverage the NF (Service) Set concept to avoid duplicate configuration and storage of NF profiles within the NFs belonging to the same NF set, and to avoid duplicate transmission of NF profiles for NFs belonging to the same NF set.\n-\tHow the shared data can be obtained by the NRF in case the shared data corresponding to the shared-data ID is not available in the NRF.\n-\tHow to avoid sending multiple NF profile change notifications from/to NF-Instances which may or may not be within an NF-Set, when a common configuration parameter changes in the NF-Profile.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_5.2.1",
      "section_id": "5.2.1",
      "section_title": "Description of the use case",
      "content": "In the NF discovery response, NRF will return the NF profiles matching the search criteria indicated by the query parameters of the discovery request, e.g. all the list of ranges of SUPIs whose profile data is available in the UDM instance, etc.\nTake SUPI as an example.\nThe AMF carries SUPI as one of the main query parameters in the NF discovery request, and initiates NF discovery to the NRF to obtain the information of the UDMs where the SUPI profile is stored. If the query parameters match successfully, the NRF will return the correct UDMs, and will carry all the list of ranges of SUPIs whose profile data is available in the UDM instance. That results in large response messages, even exceeding 2 million octets in some network deployments.\nThe AMF completely stores the data in the response message in the cache, therefore other SUPIs can be searched locally in the subsequent service discovery procedure, avoiding excessive signaling interaction with the NRF.\nHowever, if the AMF and NRF belong to different PLMNs, the ranges of SUPIs in the cache of AMF might not work. Because there are relatively few users of different SUPI accessing the network from different PLMN. Additionally, the storage costs of saving NF profiles of PLMNs around the world would be high.\nIn another scenario, when AMF in VPLMN queries SMF in HPLMN, NRF will include all “taiList” and “taiRangeList” served by the H-SMF in the NF discovery response message. However, these TAIs are useless for the AMF in VPLMN.\nConsequently, these large response messages between different PLMNs might cause unnecessary signaling overhead and data storage overhead.\nIt’s recommended considering how to simplify these numerous parameters in NF discovery response of roaming scenarios, e.g., plmnList, sNssais, perPlmnSnssaiList, nsiList, supiRanges, gpsiRanges, routingIndicators, externalGroupIdentifiersRanges, internalGroupIdentifiersRanges, suciInfos, taiList, taiRangeList, dnnList, etc.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_5.2.2",
      "section_id": "5.2.2",
      "section_title": "Key Issue definition",
      "content": "This key issue will study the following aspects:\n-\tWhich parameters of NF discovery responses between PLMNs can be simplified and how to simplify them.\n-\tHow the NRF processes requests from different PLMNs differently, e.g. AMF of some PLMNs might need the whole supiRanges UDM served.\n-\tHow the NF processes simplified response from NRF.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.1.1",
      "section_id": "6.1.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nDuplicate configuration may exist in various data types (e.g. UE identifier ranges) among different NF (or NF service) profiles. Possible shareable data in NF (or NF service) profile are listed in clause 6.7.\nEditor’s Note:\tIt is FFS that whether and which data types need to be defined as standardized shared data types.\nTo avoid duplicate configuration and transmission of shareable data (e.g. UE identifier ranges), the shareable data  can be organized as shared data which is separately stored outside of the NF profile. One NF profile using the shared data (e.g. UE identifier ranges) should carry a reference (i.e. shared data identifier) pointing to that shared data. An NF may be associate with multiple shared data with different types, thus multiple instance of shared data identifiers may be registered in one NF profile.\nThe following enhancements to data structure of the NRF API are proposed:\n-\tDefine individual data structures for each type of shared data;\n-\tFor example, define a SharedIdRanges data structure, which carries the identifier of the SharedIdRanges and a list of IMSI/MSISDN/SUPI/GPSI/External-Group-ID/Internal-Group-ID ranges, etc;\n-\tDefine a SharedDataIdentifier data type as identifier of each type of shared data;\n-\tFor example, the SharedIdRanges data structure includes an \"sharedDataId\" attribute of type SharedDataIdentifier, to indicate the unique identifier of that SharedIdRanges;\n-\tAdd attribute in the NF profile to refer to the separately stored shared data;\n-\tFor example, add \"sharedDataReferences\" attribute in the NFProfile of an NF to contain a list of shared data identifiers to multiple types of shared data, and within the \"sharedDataReferences\" container a \"sharedIdRangeRef\" attribute refers to one SharedIdRanges. Or, add one attribute \"sharedIdRangeRef\" directly in the AusfInfo/UdmInfo/PcfInfo/BsfInfo/ChfInfo/etc. to indicate the reference to a SharedIdRanges;\nThe following enhancements to resource tree of the NRF API are proposed:\n-\tDefine individual resources in the resource tree of the NRF API, to provide creation/update/deletion/retrieval operation to each type of shared data;\n-\tFor example, a separate resource \"/shared-id-ranges\" is defined to represent the collection of SharedIdRages. A POST operation to the \"/shared-id-ranges\" resource will create an instance of SharedIdRanges. A GET operation to the \"/shared-id-ranges/{sharedDataRef}\" will retrieve the content of the SharedIdRanges identified by the {sharedDataRef}.\n-\tA parent resource \"/shared-data\" may be used to umbrella all kinds of shared data types. In this case, the resource \"/shared-data/shared-id-ranges\" represents the collection of SharedIdRanges.\nTo configure the shared data in the NRF, the following methods should be used:\n-\tAn operator should arrange those shareable data (e.g. UE identifier ranges) to shared data in well-organized manner, and register those shared data to the NRF;\n-\tThe registration of shared data to the NRF may be done by the operator management system, or by an operator granted NF (e.g. a special UDR). In the latter case, the granted NF invokes POST method to the resource representing the collection of that type of shared data (e.g. to the resource \"/shared-id-ranges\") to register the shared data.\n-\tAn NF can register a reference (i.e. the shared data identifier) to one shared data in its own NF profile, if the NF is configured to share some data with other NFs and is aware of the shared data identifier. Multiple shared data identifiers may be registered in the NF profile to refer to different type of shared data;\nTo download NF profiles with shared data from the NRF, the following methods should be used:\n-\tA request NF should indicate its support for the SharedData feature to the NRF, in the NF discovery procedure or subscription to NF profile change notification.\n-\tDuring NF discovery or NF profile change notification procedure, the NRF and the request NF behaves as the following:\n-\tFor a request NF supporting the SharedData feature, the NRF only indicates the shared data identifier(s) referring to the shared data (e.g. shared data identifier to a SharedIdRanges) in the NF profile, when sending NF profile the request NF.\n-\tFor a request NF not supporting SharedData feature, the NRF shall translate the shared data identifier included in the NF profile to the content of existing attributes in the NF profile, when sending NF profile to the request NF.\n-\tWhen receiving NF profile with shared data identifier(s), the request NF shall separately invoke GET operation to the NRF resource representing the shared data to retrieval the shared data, if not yet get the shared data.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.7"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.1.2",
      "section_id": "6.1.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\textend the existing NRF API to separately organize the shared data, and provide individual operations to the resource representing the shared UE identifier ranges.\nNF:\n-\tinvoke separate retrieval to the resource representing the shared data, after receiving NF profile indicating a reference to the shared data from the NRF.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.1.3",
      "section_id": "6.1.3",
      "section_title": "Pros",
      "content": "This solution provides an efficient way to configure the shared data to multiple NF profiles, and avoid duplicate transmission of same data configured in multiple NF profiles.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.1.4",
      "section_id": "6.1.4",
      "section_title": "Cons",
      "content": "The NRF needs to differentiate the handling to a request NF supporting or not supporting SharedData feature.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.2.1.1",
      "section_id": "6.2.1.1",
      "section_title": "General",
      "content": "This solution is to address Key Issue #1 with a focus on leveraging the NF (Service) Set concept to avoid duplicate configuration, storage and transmission of NF profiles for NFs belonging to the same NF set.\nThis solution proposes optional optimizations to the Nnrf_NFManagement and Nnrf_NFDiscovery APIs to be controlled by a new feature \"NF Set Profile Support\".Consumers of the Nnrf_NFManagement service should discover the NRF's support of the new feature \"NF Set Profile Support\" using the HTTP OPTION method as already defined in 3GPP TS 29.510 [2] clause 5.2.2.2.2.Consumers of the Nnrf_NFDiscovery service shall indicate in discovery request messages whether they support the new feature \"NF Set Profile Support\".\nThis solution proposes two alternative options with regard to NF Set profile provisioning at the NRF:\nA)\tNF Set profiles are registered at the NRF by any NF instance that belongs to the corresponding NF set.\nB)\tNF Set profiles are configured at the NRF by OAM.\nIt is a PLMN operator choice to deploy option A) or B).\nThis solution proposes two alternatives with regard to NF discovery:\n1)\tThe NF Set profile is conveyed from NRF to the consumer within the discovery response message that conveys NF instance profiles which contain the corresponding NF Set Profile ID.\n2)\tThe NF Set profile is separately retrieved by the NRF consumer when needed.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.510_clause_5.2.2.2.2",
        "ts_29.510"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.1.2",
      "section_id": "6.2.1.2",
      "section_title": "NFManagement API Resources",
      "content": "This solution proposes to extend the NFManagement API with new resources \"nf-set\" allowing NF consumers to retrieve (applicable only for alternative 2, see clause 6.2.1.1) NF Profile Set information from the NRF. In addition (only for option A, see clause 6.2.1.1) the new resource \"nf-set\" allows NF consumers (i.e. NF instances belonging to an NF Set) to register NF Set profile information (i.e. profile information common to all NF instances belonging to the set) at the NRF using the PUT method. Modification of the resource's representation using PATCH and deletion of the resource using DELETE will also be supported.\nProposed modifications to the URI structure of the NFManagement API are shown in red in figure 6.2.1.2-1:\nFigure 6.2.1.2-1\nProposed modifications to the Resource and Methods overview are shown in red in table 6.2.1.2-1:\nTable 6.2.1.2-1\nResource name\nResource URI\nHTTP method or custom operation\nDescription\nnf-instances\n(Store)\n/nf-instances\nGET\nRead a collection of NF Instances.\nOPTIONS\nDiscover the communication options supported by the NRF for this resource.\nnf-instance\n(Document)\n/nf-instances/{nfInstanceID}\nGET\nRead the profile of a given NF Instance.\nPUT\nRegister in NRF a new NF Instance, or replace the profile of an existing NF Instance, by providing an NF profile.\nPATCH\nModify the NF profile of an existing NF Instance.\nDELETE\nDeregister from NRF a given NF Instance.\nnf-set\n(Document)\n/nf-sets/{nfSetID}\nGETonly for alternative 2\nRead the profile of a given NF Set.\nPUTonly for option A\nRegister in NRF a new NF Set, or replace the profile of an existing NF Set, by providing an NF set profile.\nPATCHonly for option A\nModify the NF set profile of an existing NF Set.\nDELETEonly for option A\nDeregister from NRF a given NF Set.\nsubscriptions\n(Collection)\n/subscriptions\nPOST\nCreates a new subscription in NRF to newly registered NF Instances.\nsubscription\n(Document)\n/subscriptions/{subscriptionID}\nPATCH\nUpdates an existing subscription in NRF.\nDELETE\nDeletes an existing subscription from NRF.\nNotification Callback\n{nfStatusNotificationUri}\nPOST\nNotify about newly created NF Instances, or about changes of the profile of a given NF Instance.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.1.1",
        "table_6.2.1.2-1",
        "figure_6.2.1.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.1.3",
      "section_id": "6.2.1.3",
      "section_title": "NF-Instance Registration",
      "content": "For option A, the NF-Set profile can be registered (is so needed) by any NF instance from the NF Set during NF-Instance registration as shown in figure 6.2.1.3-1. (It is assumed that all NF instances belonging to the same NF Set share some common data e.g. using UDSF. The NF-Set profile would be part of these common data.)\nFor option B, NF-Set profiles are configured at the NRF by OAM and need not be conveyed from the registering NF instance to the NRF.\nFigure 6.2.1.3-1\n1.\tNF instance of a particular NF set sends a PUT request to register the NF instance profile at the NRF by creating a resource with a URI representing the NF Instance ID. The variable nfInstanceID represents the identifier of the registering NF instance. The registering NF instance registers only its NF Set ID and NF instance specific attributes, and not the entire NFSet profile.\n2.\tOn receipt of PUT request, if the NRF determines that there is no corresponding NF Set profile already registered (option A) or configured (option B) for the NF Set ID in the NRF, it replies with an error message 400 Bad Request (Problem details: missing NF Set Profile).\n3.\tHowever, this step and also steps 3, 4 and 5 are skipped if on receipt of PUT request in step 1, NRF determines that there is already a registered or configured NF Set profile for the NF Set ID of the registering NF instance, e.g. in case another NF instance belonging to the same NF set already registered to the NRF or the NF set profile was configured by OAM at the NRF i.e. as per the steps explained in 3 and 4.\n4.\tIn case NF instance receives error message in step 2, with details ‘missing NF Set Profile’,for option A: NF instance sends a PUT request to the NRF to register the NF Set Profile, by creating a resource representing the NF set profile with a URI identifying the NF set id e.g. …/nf-sets/{nfSetID} (NF Set Profile). For example, this may be the case if this is the first NF instance in this NF set registering to the NRF.for option B: NF instance reports an error to OAM, and the NF instance should retry registration with its full NF instance profile, i.e. not making use of the \"NF Set Profile Support\" feature.\n5.\tOn success, NRF replies with \"201 Created\". The payload body of the PUT response contains the representation of the created resource (NF set profile) and the \"Location\" header contains the URI of the created resource.\nSame as 1.\n6.\tOn success, NRF replies with \"201 Created\". The payload body of the PUT response contains the representation of the created resource (NF profile) and the \"Location\" header contains the URI of the created resource.\n7.\tOther NF instance(s) of the particular NF set sends a PUT request to register its NF instance, as defined in step 1.\n8.\tOn success, in response to the above step 7, NF instance(s) of the particular NF set receives NRF replies with \"201 Created\".",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.2.1.3-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.1.4.1",
      "section_id": "6.2.1.4.1",
      "section_title": "Alternative 1",
      "content": "NF service consumer indicates \"Set Profile support\" in the NF discovery request in order for NRF to provide optimal response, including the NF Set profile. Figure 6.2.1.4.1-1 shows an example call flow.\nFigure 6.2.1.4.1-1: NF Discovery Request by NF Service Consumer supporting NF Set Profile\n1.\tThe NF Service Consumer sends GET request to the resource URI \"nf-instances\" collection resource. The input filter criteria for the discovery request are included in query parameters. It provides “Set Profile Support” indicating to the NRF that it supports the \"NF Set Profile Support\" feature.\n2.\tBased on the received input of “NF Set Profile Support”, the NRF determines that the NF service consumer supports NF set profiles and that requested NFInstance(s) belong to a particular NF Set e.g. NF Set 1.\n3.\tOn success, \"200 OK\" is returned. In its response, the NRF includes an array of NF Profile objects, that satisfy the search filter criteria e.g., all NF Instances offering a certain NF Service name, and additionally includes the NF Set Profile data. NRF does not provide NF Set profile attributes in each of the NF Instance Profile, but instead it indicates NF Set ID in each NF Instance profile.",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.2.1.4.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.1.4.2",
      "section_id": "6.2.1.4.2",
      "section_title": "Alternative 2",
      "content": "NF service consumer indicates \"Set Profile support\" in the NF discovery request in order for NRF to provide optimal response, but not including the NF Set profile.\nFigure 6.2.1.4.2-1 shows an example call flow, where the NRF does not return the NF Set Profile data in the NF Discovery Response. If the NF consumer does not already have the NF Set Profile corresponding to the NF Set ID indicated in the returned NF profiles, the NF service consumer separately requests to get it from NRF.\nFigure 6.2.1.4.2-1: NF Discovery Request by NF Service Consumer supporting NF Set Profile (variant)\n1.\tSame as in Figure 6.2.1.4.1-1.\n2.\tSame as in Figure 6.2.1.4.1-1.\n3.\tOn success, \"200 OK\" is returned. In its response, the NRF includes an array of NF Profile objects, that satisfy the search filter criteria e.g., all NF Instances offering a certain NF Service name. NRF does not provide NF Set profile attributes in each of the NF Instance Profile, but instead it indicates NF Set ID in each NF Instance profile. Here (i.e. in this alternative approach) the NRF does not return the NF set profile (as it might already be available to the NRF consumer from previous requests).\n4.\tOn receipt of NRF response in step 3, NF Service consumer determines that it does not already have any stored information about NF Set 1 ID.\n5.\tNF Service consumer sends a request to get NF Set profile corresponding to NF Set 1 ID. As a further optimization retrieval of the NF Set profile and subscription to profile change notifications may be done with a single request (POST).\n6.\tOn success, \"200 OK\" is returned, along with NF Set 1 profile",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.2.1.4.2-1",
        "figure_6.2.1.4.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.1.5",
      "section_id": "6.2.1.5",
      "section_title": "NF Set profile subscription",
      "content": "After having received the NF Set profile (see step 3 in figure 6.2.1.4-1 or step 6 in figure 6.2.1.4-2) the NF service consumer may want to subscribe to NF Set Profile Change Notifications, see figure 6.2.1.5-1.\nfigure 6.2.1.5-1\n1.\tNF Service Consumer subscribes by sending a POST request to the resource URI representing the \"subscriptions\" collection resource, with subscription data identifying the NF status changes to be notified, e.g. identifying the need to notify NF status changes affecting the NF service producers of a given NF set.\n2.\tOn receipt of the request with NF Set profile support indication in step 1, NRF determines that NF service consumer supports NF set profiles and stores the subscription (including the indication that the subscribing NF supports NF set profiles).\n3.\tOn success, \"201 Created\" is returned to the NF Consumer.\nNote:\tNF Set Profile retrieval and subscription to change notifications can be optimized using a single request message (POST). See clause 6.2.1.4 step 5.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.1.4",
        "figure_6.2.1.4-1",
        "figure_6.2.1.4-2",
        "figure_6.2.1.5-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.1.6",
      "section_id": "6.2.1.6",
      "section_title": "NF Set profile modification / deletion",
      "content": "Figure 6.2.1.6-1 describes the procedure to modify/delete the NF set profile of NF instances already registered in the NRF (only applicable for option A, see clause 6.2.1.1). Modification is done by providing the updated NF set profile to the NRF. The update operation may apply to the whole NF set profile i.e. complete replacement of the existing profile by a new profile using PUT, or it may apply only to a subset of the parameters of the NF set profile i.e. including adding/deleting/replacing attributes of the registered NF set profile using PATCH. Deletion is done by using DELETE.\nThe procedure in figure 6.2.1.6-1 also enables the NRF to notify subscribed NF consumers supporting NF Set profiles of changes (modification or deletion) done to an NF set profile (applicable to both options A and B).\nfigure 6.2.1.6-1\n1.\tA NF instance from Set 1 performs an update / deletion of the NF Set Profile by sending a PATCH or PUT or DELETE request to the resource URI representing the NF set profile. For update, it provides the changes corresponding to the NF Set Profile.\n2.\tOn success, \"200 OK\" or \"204 No Content\" is returned.\n3.\tTriggered by steps 1-2 (for option A) or by OAM provisioning (for option B) the NRF determines that it needs to send NFStatusNotify to subscribed NF Service Consumer(s) as shown in figure 6.2.1.5-1.\n4.\tNRF sends NFStatusNotify to subscribed NF Service Consumer(s) (see clause 6.2.1.5) with changes to NF set profile data with update attributes / delete indication.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.1.1",
        "clause_6.2.1.5",
        "figure_6.2.1.6-1",
        "figure_6.2.1.5-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.2.2",
      "section_id": "6.2.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n- Extend the Nnrf_NFManagement and Nnrf_NFDiscovery APIs with the new feature \"NF Set Profile Support\"\n- Support a new resource \"nf-set\" and offer methods to NRF consumers to read and subscribe (only alternative 2), and (only option A) to register, modify, and delete the new resource.\n- Support sending of change notifications to consumers having subscribed\n- Mediate between supporting NF consumers registering (and modifying) NF SET profiles and non supporting NF consumers discovering (and subscribing) registered profiles.\nNRF consumer:\n- Support the new feature when consuming Nnrf_NFManagement or Nnrf_NFDiscovery services\n- Register /Update / Delete NF Set Profile at the NRF when needed (only option A).\n- Retrieve and subscribe to NF Set profiles\nOAM procedures:\n- Configuration impacts to enable provisioning of NF Set profiles at NF instances.\n- Configuration impacts to enable provisioning of NF Set profiles at the NRF (option B only).",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.3.1",
      "section_id": "6.3.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nSome special sub-item in the NF profile may be configured with a huge content list. A typical example is the IMSI/SUPI list configured in the AUSF/UDM profiles. If the IMSI/SUPI list cannot be easily organized as reduced IMSI/SUPI range list, the size of the whole list may occupy a large volume of storage and may reaches or even exceeds the maximum size of JSON object (see clause 6.2 of 3GPP TS 29.501). It is the operator’s responsibility to determine what content size is regarded as large volume based on its policy.\nA possible way to solve this issue is to use pagination mechanism for downloading such NF profile sub-item with huge content list. Currently, the pagination mechanism has already been introduced in TS29.510 to retrieve part of the entire NF profiles from one type of NF instances (see clause 6.1.3.2.3). Similar mechanism can be utilized to retrieve a specific sub-item (e.g. IMSI/SUPI range list) of a NF profile, if that NF profile sub-item has large volume of content.\nTo support the pagination downloading mechanism for NF profile sub-items, following enhancements shall be considered:\n-\t1) When sending NF Discovery request to the NRF, the requesting NF shall:\n-\t(a) indicate its support of paginated data retrieval feature;\n-\t2) On receiving NF Discovery request from an NF, the NRF shall:\n-\t(a) check if the requesting NF supports paginated data retrieval feature;\n-\t(b) check if at least one NF profile sub-item has large volume of content, perform (c)-(d);\n-\t(c) keep the detected NF profile sub-item with empty content;\n-\t(d) indicate a special pagination reference for retrieving the content of the NF profile sub-item;\n-\tFor example, the NRF includes a paginatedDataReference IE in the NF profile. Within the paginatedDataReference IE, it carries: (a) the original resource URI of the NF profile sub-item, (b) a special paginated-data-retrieval URL used to retrieve one page of data of that NF profile inner item, (c) total pages of the NF profile sub-item, (d) page size;\n-\tAn example of the paginated-data-retrieval URL:\n{apiRoot}/nnrf-nfm/v1/paginated-data-retrieval/{nf-instance-id}/{nf-profile-sub-item}\n-\t3) On receiving NF Discovery response from the NRF, the requesting NF shall:\n-\t(a) store the NF profile returned by the NRF;\n-\t(b) check if pagination reference is present in the response, perform bullet (c)-(d);\n-\t(c) initiate an separate HTTP GET to the paginated-data-retrieval URL, indicating the target page number;\n-\tAn example of HTTP GET request:\nGET  {apiRoot}/nnrf-nfm/v1/paginated-data-retrieval/{nf-instance-id}/{nf-profile-sub-item}?page-number=1;\n-\t(d) continue (h) to retrieve all pages from the NRF, and assemble all pages to get the entire content of the indicated NF profile sub-item.",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.501_clause_6.2",
        "clause_6.1.3.2.3",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.3.2",
      "section_id": "6.3.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\textend the existing NRF API to support paginated data retrieval.\nNF:\n-\tindicate its support of paginated data retrieval feature to the NRF;\n-\tinvoke paginated data retrieval to the indicated paginated-data-retrieval URL to retrieve one page of content of a specific NF profile sub-item.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.3.3",
      "section_id": "6.3.3",
      "section_title": "Pros",
      "content": "This solution provides an efficient way to download one piece of content of an NF profile sub-item, in the case that the NF profile sub-item has large volume of content.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.3.4",
      "section_id": "6.3.4",
      "section_title": "Cons",
      "content": "The NRF needs to differentiate the handling to a requesting NF supporting or not supporting paginated data retrieval feature.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.4.1",
      "section_id": "6.4.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nDuplicate configuration may exist in various data types (e.g. UE identifier ranges) among different NF (or NF service) profiles. Possible shareable data in NF (or NF service) profile are listed in clause 6.7.\nEditor’s Note:\tIt is FFS that whether and which data types need to be defined as standardized shared data types.\nTo avoid repeat transmission of shareable data within the NF profile, it is proposed to classify these shareable data as different set of shared data, identified by shared-data ID, in the same way adopted in subscription data retrieval. Within the NRF interaction related procedures (e.g. NF registration, NF discovery), the shared-data ID will be provided instead of shared data.\nAs NRF is deployed in a hierarchical architecture, e.g. PLMN level, shared-slice level, and slice-specific level, to configure the shared data on lower level NRF might be not suitable for the fact that NFs may register its profile in one of multiple NRF instances, and to configure the shared data on all NRF instances as global unique information might cause a waste of storage resource. In this solution, it is proposed to configure the shared on a higher level NRF instance, and the corresponding NRF instance which stores this shared data will be provided simultaneously together with the shared-data ID when needed.\nThe procedure of shared-data ID provisioning would be as below:\n-\tThe mapping correlation between shared-data ID and the corresponding shared data is provisioned on a higher level NRF instance.\n-\tBesides, for the NF instances which holds these shared data, the shared-data ID and the NRF instance ID which maintains the mapping correlation is provisioned during the initialization process.\nThe procedure of NF registration procedure would be as below:\n-\tThe NF registers its NF profile to the NRF, in which the NF profile contains one or more shared-data ID(s) and the NRF instance ID which maintains the shared data corresponds to the shared-data ID.\n-\tIf the NRF determines that the shared data corresponds to the shared-data ID is not available yet, it initiates the retrieval of shared data towards the NRF instance identified by the NRF instance ID of the shared-data ID.\n-\tThe NRF which receives the NF registration request needs to subscribe on the change notification of shared data towards the NRF instance which maintains the shared data.\nThe procedure of NF discovery procedure would be as below:\n-\tUpon receiving the NF discovery request from a request NF which indicates its support for SharedData feature, the NRF can respond to the request NF with the NF profile which includes the shared-data ID and the corresponding NRF instance ID which maintains the related shared data.\n-\tUpon receiving the NF discovery request from a request NF which does not indicate its support for SharedData feature, the NRF shall translate the shared-data ID within the NF profile into the corresponding shared data, and respond the NF profile to the request NF.\n-\tWhen the request NF receives NF profile contains shared-data ID, and the corresponding shared data is not available yet, it initiates the retrieval and subscription of shared data towards the NRF instance identified by the NRF instance ID of the shared-data ID, or alternatively, towards the current NRF instance.\nAs an alternative, if the shared-data ID is unique at PLMN granularity, the mapping between the shared-data ID and corresponding NRF instance ID can be registered outside of the NF profile, and the NRF doesn’t need to provide the NRF instance ID corresponding to the shared-data ID, as the request NF can request and subscribe to the shared data by providing the uniquely assigned shared-data ID.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.7"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.4.2",
      "section_id": "6.4.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\tretrieves the shared-data corresponds to the received shared-data ID from the NRF instance identified by the NRF instance ID.\n-\tresponds the shared data according to the supported feature of the request NF.\nNF:\n-\tregisters its NF profile to the NRF, which may include shared-data ID and the corresponding NRF instance ID.\n-\tretrieves the shared-data corresponds to the received shared-data ID from the NRF instance identified by the NRF instance ID or from the current NRF instance.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.4.3",
      "section_id": "6.4.3",
      "section_title": "Pros",
      "content": "This solution provided an efficient way to optimize the signalling load during NRF interaction, and allows the shared data being provisioned in a distributed way.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.4.4",
      "section_id": "6.4.4",
      "section_title": "Cons",
      "content": "Shared-data ID is tightly bound to the corresponding NRF instance ID which maintains the shared data, and needs to be transmitted together.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.5.1",
      "section_id": "6.5.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nDuplicate configuration may exist in various data types (e.g. UE identifier ranges) among different NF (or NF service) profiles. Possible shareable data in NF (or NF service) profile are listed in clause 6.7.\nEditor’s Note:\tIt is FFS that whether and which data types need to be defined as standardized shared data types.\nAccording to the definition in TS 23.501[3], NF Set is a group of interchangeable NF instances of the same type, supporting the same services and the same network slice(s), and can have access to the same context data even geographically distributed. Under this precondition, it can be assumed that NF profile of different NF instances within the same NF set tend to converge, and would only differ with some NF instance specific data types, e.g. address info, serving area. To optimize the transmission of shared data for an NF set, it is proposed that the NRF can fetch the shared data from the register NF upon receiving the NF set level shared data.\nFor set level shared data transmission, most of the data type within the NF profile can be identified as a one or more shared-data ID(s), and the shared-data ID can be provided together with the NF Set ID to the NRF during the NF registration procedure, and further to the request NF by the NRF during the NF discovery procedure.\nThe procedure of shared-data ID provisioning would be as below:\n-\tThe mapping correlation between shared-data ID(s) and the corresponding shared data is provisioned on all the NF instances within the same NF Set.\nThe procedure of NF registration procedure would be as below:\n-\tThe NF registers its NF profile to the NRF, in which the NF profile contains one or more shared-data ID(s), the shared-data ID can uniquely identify the shared data stored within any of the NF instance in the same NF set.\n-\tIn case that the NRF determines that the shared data corresponds to the shared-data ID is not available yet, it initiates the retrieval and subscription of shared data towards the register NF by providing the shared-data ID.\nThe procedure of NF discovery procedure would be as below:\n-\tUpon receiving the NF discovery request from a request NF which indicates its support for SharedData feature, the NRF can respond to the request NF the target NF profile(s). In case that the target NF(s) includes NF one or more NF instance(s) within the same NF set, the mapping between shared-data ID and the corresponding shared data will be provided within the response message.\n-\tUpon receiving the NF discovery request from a request NF which does not indicate its support for SharedData feature, the NRF shall translate the shared-data ID within the NF profile into the corresponding shared data, and respond the NF profile to the request NF.\n-\tWhen the request NF receives NF profile contains shared-data ID, it initiates the subscription of shared data change event towards the current NRF instance, or alternatively, the NRF creates the subscription in an implicitly way and notifies when shared data change event occurs.\nWhen the NF which is subscribed by the NRF on shared data change event deregisters from the NRF, the NRF can select another NF instance within the same NF set and subscribe on the shared data change event to the NF instance.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.7",
        "ts_23.501"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.5.2",
      "section_id": "6.5.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\tretrieves the shared-data corresponds to the received shared-data ID from the register NF when needed.\n-\tresponds the shared data according to the supported feature of the request NF.\n-\tsubscribe and re-subscribe on shared data change event to the register NF or other NF instance within the same NF Set.\nNF:\n-\tregisters its NF profile to the NRF, which may include shared-data ID, and support to handle the shared data retrieval and subscription of shared data change event initiated by the NRF.\n-\treceives the shared-data ID and the corresponding shared data within the NF discovery procedure.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.5.3",
      "section_id": "6.5.3",
      "section_title": "Pros",
      "content": "This solution introduced shared data mechanism for the NF instances within the same NF Set, to avoid the repeated transmission of the shared data related to these NF instances.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.5.4",
      "section_id": "6.5.4",
      "section_title": "Cons",
      "content": "This solution is designed for NF set level, and may be inefficient for NF instances from different NF set scenario.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.6.1",
      "section_id": "6.6.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #2: Signaling overhead of NF discovery responses between PLMNs.\nThe NRF may be configured by means of OAM with sets of policy rules per PLMN or per groups of PLMNs (e.g. one policy rule set for all foreign PLMNs, one policy rule set for equivalent PLMNs,…). These rules define what parameters of a registered NF profile can be exposed to the PLMN. Also these rules can define the way how to modify/reduce registered profile parameters for exposure to the PLMN in order to reduce the message length and required storage capacity at the consumer.\nThe PLMN specific rules may take additional information into account (e.g. the NF type of the registered NF) when deciding to remove parameters from the discovery response message.\nThe policy rules shall be limited to cases where impacts to NF consumers are avoided, i.e. NF consumers need not be aware of the fact that NF profiles in the discovery response message have been modified/reduced.\nE.g.: If the registered SmfInfo contains a list of TAIs or TAI ranges, the policy rule for all foreign PLMNs could require to remove TAIs and TAI ranges from SMF discovery responses sent to a foreign PLMN.\nThe PLMN-specific policy rules shall apply to NF discovery response messages and to profile change notification messages.\nFigure 6.6.1-1 shows an example flow.\nFigure 6.6.1-1\n1-2.\tPLMN X -specific policy rules are configured at the NRF.\n3-4.\tNF producer registers its profile at the NRF.\n5. \t\tNRF receives a discovery request from PLMN X.\n6.\t\tNRF applies the configured policy rules for PLMN X to the registered NF profile.\n7.\t\tNRF sends a discovery response containing the registered NF profile with PLMN X -specific policy rules applied.\n8-9.\tNRF receives a subscribe request from PLMN X.\n10-11.\tNF producer modifies its NF profile\n12.\t\tNRF applies the configured policy rules for PLMN X to the modified NF profile.\n13-14.\tIf the modified profile with policy rules applied differs from the original profile with policy rules applied: NRF notifies the consumer.",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.6.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.6.2",
      "section_id": "6.6.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "OAM:\n-\tConfigure the NRF with policy rules per PLMN.\nNRF:\n-\tApply configured policy rules to NF discovery response messages and profile change notification messages.\nNF consumer:\n-\tNone.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.6.3",
      "section_id": "6.6.3",
      "section_title": "Pros",
      "content": "This solution provides an efficient way to shorten NF Discovery response messages and Profile change notification messages sent to different PLMNs. Also the amount of Profile change notification messages will be reduced.\nNF consumers are not impacted.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.6.4",
      "section_id": "6.6.4",
      "section_title": "Cons",
      "content": "Depending on the complexity of OAM configured policy rules, additional NRF storage and processing resources to store and apply the rules are needed. However, as inter-PLMN discovery traffic represents a rather low contribution to the overall NF discovery traffic, the need for additional processing resources may be limited.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.7.1",
      "section_id": "6.7.1",
      "section_title": "Description",
      "content": "This solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data. Specially, this solution lists those NF profile items which are possibly shared among different NF (or NF service) profiles which may belong to same or different NF set.\nTable 6.7.1-1 lists NF profile items that might be shared by multiple NFs (or NF services), either across different NF sets or within same NF set.\nTable 6.7.1-1: Possible shareable NF profile items\n#\nShareable NF profile items\nShared by NFs across different NF sets\nShared by NFs within same NF set\n01\nList of supported PLMN (e.g. allowed PLMNs)\nO (Optionally shared)\nM (Mandatorily shared)\n02\nList of supported features\nO\nM\n03\nUE identifier ranges (e.g. SUPI ranges, GPSI ranges, IMSI ranges, IMEI ranges, MSISDN ranges, external/internal group identifier ranges, etc.)\nO\nM\n04\nRouting indicator, SUCI info (e.g. configured in AusfInfo);\nO\nM\n05\nList of supported serving area (e.g. TAI list or TAI range list)\nO\nM\n06\nList of supported NF services\nO\nM\n07\nList of allowed NF types\nO\nM\n08\nList of allowed NF domains\nO\nM\n09\nList of supported S-NSSAI\nO\nM\n10\nList of supported DNN\nO\nM\n11\nList of supported DNAI\nO\nM\n12\nNF/NFS FQDN (used for intra-PLMN or inter-PLMN)\nN/A\nO\n13\nService endpoint info (HTTP scheme, port number)\nO\nO\n14\nList of locality\nO\nO\n15\nList of serving scope\nO\nO\n16\nList of SCP domain\nO\nO\n17\nList of default notification callback URL\nN/A\nO\nIf above sharable profile items are shared by NFs within the same NF set, solution #2 provides candidate methods to configure and store the shared NF set profile without need of definitions for new data type for shareable profile items.\nIf above shareable profile items are shared by NFs not belonging to the same NF Set, new data types for those shareable data might be defined. For example, a variant type might be defined as a container to carry different shareable profile items, with an enumeration attribute (e.g. contentType) indicating the exact type of inner profile item.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.7.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.7.2",
      "section_id": "6.7.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF, NF:\n-\tMay need to support new data types defined for shareable data.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.7.3",
      "section_id": "6.7.3",
      "section_title": "Pros",
      "content": "If a common variant data type is defined for various shareable data, it is no need to define separate data types for each shareable profile items.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.7.4",
      "section_id": "6.7.4",
      "section_title": "Cons",
      "content": "No special cons foreseen.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.8.1",
      "section_id": "6.8.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nMultiple NFs in an NF Set may subscribe the NF profile changes of the same NF. As per existing procedure, the NRF creates individual subscription for each requesting NF. Once the NF profile of the target NF changes, the NRF sends separate notifications to each NF that previously subscribed the NF profile change notification. This mechanism can be simply implemented but it creates unnecessary notifications towards NFs within an NF Set.\nHowever, as NFs within an NF Set may share the runtime context (e.g. cached NF profiles, subscriptions to NF profile changes, etc.) by the assistance of UDSF, it is possible for those NFs to only create one instance of subscription for the indicated purpose in the NRF.\nThe following enhancements can be considered for this solution:\n-\t1) When one NF wants to subscribe NF profile change for a specific NF, the requesting NF shall first check if such subscription context exists in the UDSF:\n-\t1.1) if exist, it means such subscription to the NRF has already been created by another NF in the NF Set, thus it is no need to trigger duplicate subscription to the NRF. The requesting NF may register itself to the subscription context in the UDSF so as to be notified later.\n-\t1.2) if not exist, the requesting NF sends subscription request to the NRF, and stores the subscription context (e.g. subscribed NF Instance ID, requesting NF ID, etc.) in the UDSF.\n-\t2) When detecting NF profile changes for a specific NF, the NRF initiates NF profile change notification to the NF(s) that subscribed the event, without any special enhancement to the notification procedure.\n-\t3) On receiving NF profile change notification from the NRF, the receiving NF shall store the updated NF profile of the indicated NF in the UDSF. Implementation specific method may be used by the UDSF to make other NFs in the NF Set be aware of the updated NF profile.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.8.2",
      "section_id": "6.8.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NF:\n-\tEnhancements to NF internal logic to avoid sending duplicate subscriptions to the NRF to subscribe NF profile change for a specific NF;\nNRF:\n-\tNo special enhancement.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.8.3",
      "section_id": "6.8.3",
      "section_title": "Pros",
      "content": "This solution doesn't require any enhancement to the NRF interface and NRF logic.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.8.4",
      "section_id": "6.8.4",
      "section_title": "Cons",
      "content": "This solution relies on the NF internal enhancement and implementation of UDSF, and may not always be available. The complexity of UDSF implementation may further decrease the usability of the solution.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.9.1",
      "section_id": "6.9.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nMultiple NFs in an NF Set may subscribe the NF profile changes of the same NF. As per existing procedure, the NRF creates individual subscription for each requesting NF. Once the NF profile of the target NF changes, the NRF sends separate notifications to each NF that previously subscribed the NF profile change notification. This mechanism can be simply implemented but it creates unnecessary notifications towards NFs within an NF Set.\nHowever, it is possible for the NRF to aggregate separate subscriptions to NF profile change of a specific NF from multiple NFs within an NF Set, and thus only sends one instance of NF profile change notification to multiple NFs within an NF Set.\nThe following enhancements can be considered for the solution:\n-\t1) When one NF subscribes NF profile change of a specific NF to the NRF, the requesting NF shall indicate its support of sharing NF profile change notification within NF Set in the request message;\n-\tcertain methods (if available) might be used by the requesting NF to avoid sending duplicate NF profile change subscription to the NRF, e.g. as addressed by solution #8;\n-\t2) On receiving subscription to a specific NF profile, the NRF shall:\n-\t2.1) check if the requesting NF supports sharing NF profile change notification within NF Set;\n-\tif the requesting NF does not have the expected capability, the NRF handles the subscription request as per existing procedure;\n-\tif the requesting NF has the expected capability, continue step 2.2);\n-\t2.2) check if the NF profile change subscription for a specific NF Set exists in the NRF;\n-\tif not exist, create the subscription at per NF Set level, and store the following information in the subscription context: NF Instance ID of the subscribed NF, NF Set ID, NF Instance ID of the requesting NF, callback URI of the requesting NF;\n-\tif exist, store the following information in the existing subscription context: NF Instance ID of the requesting NF, callback URI of the requesting NF.\n-\t3) When NF profile change of a specific NF is detected, the NRF shall:\n-\t3.1) check if the stored NF profile change subscription is at NF Set level, i.e. multiple NFs in an NF Set have subscribed the NF profile change notification:\n-\tif not, handle the NF profile change notification as per existing procedure;\n-\tif yes, continue step 3.2);\n-\t3.2) handle the NF profile change notification at NF set level, i.e. select one target NF from the requesting NFs belonging to same NF Set (i.e. from the request NF list stored in the subscription context), and send NF profile change notification to that selected NF;\n-\t4) When one NF receives NF profile change notification from the NRF, it shall store the updated NF profile, and synchronize the received NF profile update with other NFs in the same NF Set.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.9.2",
      "section_id": "6.9.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NF:\n-\tindicate the support of sharing NF profile change notification within NF Set to the NRF;\nNRF:\n-\tenhance the NRF interface and logic, so as to detect the subscription from an NF with support of sharing NF profile change notification within NF Set and handle the subscription and notification accordingly.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.9.3",
      "section_id": "6.9.3",
      "section_title": "Pros",
      "content": "With the enhancement, the NF profile change notifications to multiple NFs within an NF Set are reduced.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.9.4",
      "section_id": "6.9.4",
      "section_title": "Cons",
      "content": "The NRF needs to differentiate the handling to a requesting NF with or with support of sharing NF profile change notification within NF Set.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.10.1",
      "section_id": "6.10.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #2: Signaling Overhead of NF Discovery Responses between PLMNs.\nAccording to the definition in 3GPP TS 29.510 [2], NRF returns all value of attributes of array or map type in NF Profile in NF discovery response, however, in most inter-PLMN scenarios, NF consumer does not need to obtain all attribute values. For example, all the list of ranges of SUPIs whose profile data is available in the UDM instance is stored in the supiRanges  of the NF profile, and NF consumers in other PLMNs need only a few of them.\nConsequently, in this solution, the inter-PLMN NF discovery response message will only contain value that match the NF discovery request parameters, not all value. NF consumer could process the simplified response as normal without any additional change, as the matched values fully meet its requirements in this service procedure. Furthermore, NF consumer could process the simplified response more appropriately with identifying it.\nTo support the solution, following enhancements shall be considered:\nFigure 6.10.1.1: inter-PLMN NF service discovery procedure with partial information\n1) The NF service consumer sends the NF discovery request to the NRF when query fail in the cache;\n2) The intermediate NRF (NRF1) forwards the NF discovery request to the NRF in home network (NRF2);\n3) On receiving NF Discovery request, the target NRF only returns the value matching the query parameters in the response, and carried an indication.\nAn example of simplifying response message:\nThe supiRanges value of the NF1 profile registered on NRF is:\n{{\"start\": \"123456789040000\", \"end\": \"123456789049999\"}\n{\"start\": \"123456789050000\", \"end\": \"123456789059999\"}\n{\"start\": \"123456789060000\", \"end\": \"123456789069999\"}}\nIn the NF discovery request from NF2, the value of the query parameter SUPI is “123456789041234”, and other query parameters also match NF1. Then NF discovery response returned to NF2 contains only “{\"start\": \"123456789040000\", \"end\": \"123456789049999\"}”.\n4) On receiving NF Discovery response from the NRF the consumer could cache it as normal. Provided that the consumer could handle the indication that indicates a simplified response, it could process the response more appropriately, e.g., updating values of the response to cache and not deleting other values of same NF producer already exist in cache, so as to cache more useful data and saving more signaling overhead.",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.10.1.1",
        "ts_29.510"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.10.2",
      "section_id": "6.10.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\tSimplify the NF discovery response message.\nNF:\n-\tProcess the simplified NF discovery response message.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.10.3",
      "section_id": "6.10.3",
      "section_title": "Pros",
      "content": "This solution introduces a simplification mechanism for inter-PLMN NF discovery response, to avoid the unnecessary signalling overhead and data storage overhead in inter-PLMN scenario.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.10.4",
      "section_id": "6.10.4",
      "section_title": "Cons",
      "content": "The number of inter-PLMN NF discovery messages might increase a little.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.11.1",
      "section_id": "6.11.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nSeveral NF types, such as UDM, AUSF, AAnF…, may contain in their NFProfile info a (potentially very large) set of Routing Indicators (RID). When a candidate NF instance of any of those types needs to be discovered by a consumer, it includes the UE RID in the NRF Discovery request, so the NRF returns only those NF instances containing such RID in their profiles.\nThis is a quite similar scenario to the discovery of candidate producer instances based on SUPI, and the problem of provisioning a large set of SUPI ranges in the NF Profile of the NF instances themselves. For this problem, the approach of configuring the mapping between SUPI and NF Group ID was addressed by moving the configuration of SUPI ranges and NF Group IDs to the NRF and letting the NRF to obtain the NF Group ID for a given SUPI received in the discovery request and include the NF instances of the corresponding NF Group ID in the discovery response.\nIf the NRF has no stored configuration mapping identity sets/ranges to NF Group ID locally, the NRF can retrieve the NF Group ID corresponding to a specific subscriber identifier from the UDR using the Nudr_GroupIDmap_Query service operation.\nA similar approach can be proposed for the RIDs: the configuration of mapping between RID and NF Group ID can be moved out from the producer NFProfile (and NRF), and can be done at the NRF either based on local configuration or by interacting with UDR. It should be noted that all NF instances deployed in the same NF Group will define support for the same list of Routing Indicators and multiple Routing Indicators can be supported within the same NF Group.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.11.2",
      "section_id": "6.11.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\tadd logic to determine the NF Group ID for a given RID, either based on local configuration or by interacting with UDR.\nUDR:\n-\tenhance the Nudr_GroupIDmap API to support receiving the RID as input for the mapping.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.11.3",
      "section_id": "6.11.3",
      "section_title": "Pros",
      "content": "This solution provides a very simple enhancements to relieve the configuration of large sets of RID in NF producers' NFProfile and lowering the size of these profiles.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.11.4",
      "section_id": "6.11.4",
      "section_title": "Cons",
      "content": "None identified.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.12.1",
      "section_id": "6.12.1",
      "section_title": "Description",
      "content": "The solution is to address the Key Issue #1: Avoid Duplicate Configuration and Transmission of Shareable Data.\nAccording to the definition in TS 23.501[3], NF Set is a group of interchangeable NF instances of the same type, supporting the same services and the same network slice(s), and can have access to the same context data even geographically distributed. Under this precondition, it can be assumed that NF profiles of different NF instances within the same NF Set tend to converge, and would only differ with some NF instance specific data types, e.g. address info, NF Instance info, etc.\nTo optimize the storage and transmission of shared data for an NF Set, the following issues needs to be addressed in this solution:\na)\tHow the NRF receives the shared data for a specific NF Set.\nb)\tHow the NRF can be notified of the updated shared data for the NF Set.\nc)\tHow the NF discovery procedure can be optimized to avoid the transmission of multiple copies of shared data for the NF Set.\nEvaluation of Issue a) and issue b) heavily depends on the endpoint in which the shared data is provisioned, e.g. the NF instances, or the NRF. If the shared data for the NF Set is provisioned only in the NF instance, the mapping information between NF Set ID and corresponding shared data in the NRF needs to be maintained by the NF instance(s), thus implicit and explicit subscription may be involved as specified in Option A of Solution #2 and Solution #5 respectively, which may cause complicated interaction between NRF and NF instance to guarantee the consistency of the shared data for the NF Set.\nIn consideration of the fact that the NF instances of the same NF Set is usually served by a specific NRF instance or specific pair of NRF instances, it would be much easier to enable the direct provisioning and updating of shared data for the NF Set by the OAM. In this case, transmission of shared data for the NF Set is not needed during the NF registration procedure.\nFor issue c), either one step or two step retrieval can be adopted to avoid the transmission of shared data for the NF Set. As the NF discovery is triggered to discovery the target NF instance or target set of NF instance(s), it means the NF Consumer have no NF profile context for the NF Producer within the NF Set, not to mention the shared data for the NF Set, one step retrieval is proposed to be adopted to avoid additional interaction.\nSimilar with the updating on URI structure of the NFManagement API in Solution #2, resource nf-sets is proposed to be managed independent of the NF profile within the resource nf-instances. As the resource nf-sets is provisioned and updated by the OAM directly, only HTTP GET method triggered by NF Consumer or other NRF instance is needed for this resource.\nFigure 6.12.1.2-1 Resource Structure for Nnrf_NFManagement service\nThe procedure of shared data for NF Set provisioning and updating would be as below:\n-\tThe mapping correlation between NF Set ID and the corresponding shared data for the NF Set is provisioned and updated by the OAM, based on the serving relationship between NRF instance(s) and NF Set(s), which is outside the 3GPP scope.\nNOTE 1: OAM is responsible for the provisioning of shared data for the NF Set into the corresponding NRF instance(s) which serves the NF Set.\nThe procedure of NF registration procedure would be as below:\n-\tThe NF registers its NF profile to the NRF, which contains the NF Set ID it belongs to. As the shared data for the NF Set is already provisioned in the NRF, no shared data is to be contained within the registered NF profile.\n-\tUpon receiving the NF registration request, the NRF correlates the registered NF instance with the stored nf-sets by using NF Set ID.\nThe procedure of NF discovery procedure would be as below:\n-\tUpon receiving the NF discovery request from a requester NF which indicates its support for NFSetSharedData feature, the NRF responds to the requester NF the registered NF profile(s) of the target NF instance(s), together with the shared data for the NF Set(s) corresponding to the target NF instance(s).\n-\tUpon receiving the NF discovery request from a requester NF which does not indicate its support for NFSetSharedData feature, the NRF merges the registered NF profile with the shared data of the NF Set for each target NF instance, and respond the merged NF profile(s) to the requester NF.\n-\tWhen the requester NF receives the additional shared data for the NF Set(s), it correlates the shared data for the NF Set(s) with the received NF profile(s), and regards the shared data for the NF Set applicable for every NF instance of the NF Set when interacting with the NF Producer. It initiates the subscription of change event for the shared data of NF Set(s) and NF profile(s) towards the NRF respectively if not triggered yet.\nNOTE 2:\tOAM is responsible for avoiding duplicate provisioning for a specific attribute in both NF profile registered by the NF Producer and the shared data for the NF Set.",
      "chunk_type": "general",
      "cross_references": [
        "figure_6.12.1.2-1",
        "ts_23.501"
      ]
    },
    {
      "chunk_id": "ts_29.831_6.12.2",
      "section_id": "6.12.2",
      "section_title": "Impacts on services, entities and interfaces",
      "content": "NRF:\n-\tCorrelates the registered NF profile and stored shared data for the corresponding NF Set, and responds the NF profile and shared data for the NF set to the requester NF in a proper way, based on the supported feature of the requester NF.\nNF Producer:\n-\tregisters its NF profile to the NRF, which includes NF Set ID it belongs to, while shared data for the NF set is not included.\nNF Consumer:\n-\treceives the NF profile for the target NF instance(s) and the corresponding shared data for the NF Set, regards the shared data for the NF Set applicable for each NF instance within the NF Set.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.12.3",
      "section_id": "6.12.3",
      "section_title": "Pros",
      "content": "No complicated explicit and implicit coordination for shared data of the NF set is needed between NF Producer and the NRF.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_6.12.4",
      "section_id": "6.12.4",
      "section_title": "Cons",
      "content": "This solution is designed for NF Set level, and may be inefficient for NF instances from different NF Set scenario.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.1.1",
      "section_id": "7.1.1.1",
      "section_title": "Configured Shareable Data",
      "content": "NF configuration data (configured by means of OAM at the NF/NF set) have an impact on the NF's profile data stored at the NRF. Profile data stored at the NRF are either statically configured by means of OAM (in sync with the data configured at the NF/NF set), or dynamically registered by the NF (avoiding synchronization issues).\nSimilarly for shared configuration data and their IDs, which are configured by means of OAM at all sharing NFs/NF sets: The corresponding shared data / set profile and IDs needs to be stored at the NRF.\nSolution #1 allows data sharing among NFs of different types or of same type from different sets. This adds the need for synchronized configuration. In addition, solution #1 proposes to configure shared data and their IDs at all NRFs, adding even more complexity to ensure overall synchronized configuration.\nThe synchronization issue between NRFs is addressed by solution #4 which proposes a higher level NRF to store the shared data, at the cost of higher NRF to NRF traffic, to retrieve the shared data when needed.\nSimilarly, solution #1 proposes as an option to sync NRFs by means of an operator granted NF (e.g. special UDR).\nStill synchronization between NFs, between NF sets and between NF and NRF remains an issue adding complexity to network configuration.\nSolution #2 (option A) and solution #5 propose to configure/provision shareable data (NF set profiles) and their IDs (NF set ID) at a single place (the NF set), avoiding all kinds of synchronization issues.\nSolution #2 (option B) proposes to configure/provision shareable data (NF set profiles) and their IDs (NF set IDs) at two places (a single NRF set and a single NF set) allowing to minimize synchronization issues.\nSolution #8 and #9 proposes similar way to avoid duplicate subscription and change notification, via the UDSF and NRF determination. However, the basis of the solution might be inaccurate, as the NF will only determine to trigger the subscription when no shared data can be found locally, thus no duplication subscription will be received by the NRF, and the NRF does not need to avoid duplicate notification to the NFs within the same NF set.\nSolution #11 proposes to delegate the configuration of a certain type of shareable data (Routing Indicators) to the NRF or UDR and let the NRF find out the mapping between RID and NF Group ID based on local configuration or via an existing API with the UDR. This approach is quite similar to the existing mechanism for handling SUPI ranges, and in that sense, it does not bring any additional issue related to configuration, discovery or change of such shareable data, compared to the existing mechanism already in place for mapping between SUPI and NF Group ID.\nSolution #12 proposes to configure the shared data in NRF(s) which serves the NF Set, thus no synchronization on update of shared data is required between NF(s) and NRF(s).",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.1.2",
      "section_id": "7.1.1.2",
      "section_title": "Discovered Shareable Data",
      "content": "Once shareable data have been discovered by NFs during the NF discovery procedure, the data are subject to change. Solutions #1, #2 and #5 propose similar subscribe/notify mechanisms ensuring that discovered shared data are kept in sync.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.1.3",
      "section_id": "7.1.1.3",
      "section_title": "Change of Shareable Data",
      "content": "When the shareable data is configured in NF instance or NRF, the operator may update the correlation between shared-data ID with shareable data. The NRF should be aware of the change event.\nEditor's note:\tThe solution evaluation for Change of Shareable Data is FFS.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.2.1",
      "section_id": "7.1.2.1",
      "section_title": "Storage of configured data",
      "content": "Storing/configuring multiple copies of the same configured data (i.e. redundant data) at an NF is an issue addressed by solutions #1, #2, #4 and #5. However, storing requirements for a single copy of shared data differ. It is beneficial to store/configure shared data at a single place in the network.\nSolution #1 proposes to configure/store shared data at all or multiple NRFs /NRF set in the PLMN.\nSolution #4 proposes to configure/store shared data at a single higher level NRF /NRF set.\nSolution #2 option A proposes to configure/store shared data (NF set profiles) at a single NF set.\nSolution #2 option B proposes to configure/store shared data (NF set profiles) at a single NRF/NRF set.\nSolution #5 proposes to configure/store shared data at a single NF set.\nSolution #8 and #9 proposes to configure/store shared data at a single NF set.\nSolution #11 proposes to configure Routing Indicator to NF Group ID mapping at the NRF or in the UDR, rather than at the NFProfile of the producer (UDM, AUSF, AAnF).\nSolution #12 proposes to configure shared data within the NRF(s) serving the NF set.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.2.2",
      "section_id": "7.1.2.2",
      "section_title": "Storage of discovered data",
      "content": "Storing multiple copies of the same discovered data (i.e. redundant data) at an NF is an issue addressed by solutions #1, #2, #5, #8, #9 and #12. All solutions propose the same principle, i.e. store the discovered shared data only once and use the IDs as a pointer to the shared data.\nSimilar solution is also proposed in solution #4, by identify the discovered shared data using shared-data IDs together with the corresponding higher level NRF instance ID.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.3",
      "section_id": "7.1.3",
      "section_title": "Discovery procedure",
      "content": "Solutions #1, #2, #4 and #5 propose optimizations, differing with regard to discovery response message length and number of message roundtrips.\nSolution #1, alternative 2 of solution #2, solution #4 and solution #12 propose an additional roundtrip to retrieve shared data from the NRF if a shared data ID (or set profile ID) was received while the corresponding shared data (or set profile) has not yet been received. This additional message roundtrip occurs only when the shared data is not cached.\nSolutions #5 and alternative 1 of solution #2 propose to always include (a single copy of) the shared data in the discovery response message, so to avoid an (potentially seldom occurring) additional roundtrip at the cost of (an always) increased message length.\nWith solution #3 the response message length is reduced at the cost of more roundtrips.\nSolutions #8 and #9 propose optimizations for NF profile change subscription and notification that simplify the discovery of shared data.\nSolution #11 does not imply any change on the discovery procedure by consumers of the NRF Discovery service.",
      "chunk_type": "procedure",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.4",
      "section_id": "7.1.4",
      "section_title": "Which data should be shareable?",
      "content": "Standardizing the exact list of data that may be shareable comes with the drawback that for any extension in future releases the decision (and specification) needs to be taken whether or not the extended data is worth being shareable.\nSolution #1 currently has an editor's note indication that this aspect is ffs.\nSolution #5 has the same issue as #1 (although not explicitly stated).\nSolution #2 avoids the need to address the issue as the NF set profile would be of the same type as the NF profile.\nSolution #7 listed the data which can be shared in the NF profile items.\nSolution #11 is restricted to the Routing Indicator data set, as shareable data.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.5",
      "section_id": "7.1.5",
      "section_title": "New NF services operations",
      "content": "It is beneficial to extend existing service operations rather than defining new service operations.\nSolution #5 proposes that the NRF retrieves (and subscribes to) shared data from the NF during the NF registration procedure. The registering NF can be of any type. Consequently, any NF of any type must offer a new service allowing the NRF to retrieve and subscribe to shared data.\nSolution #2 option A avoids new service operations by re-using and extending the Nnrf_NFManagement service operations (NFRegister, NFUpdate, NFDeregister) allowing any NF to push (register) its set profile to the NRF, modify it at the NRF and delete it from the NRF. While it is not mentioned how the NRF can determine whether the NF Set profile is not contained due to this feature or some error cases, as no shared-data-ID is provided to the NRF in the NFRegister request.\nSolution #3 avoids new service operations by re-using and extending the Nnrf_NFDiscovery service operation (NFDiscover) allowing pagination of discovery responses.\nSolution #11 does not require any modification on the interaction between the producer and the NRF.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.6",
      "section_id": "7.1.6",
      "section_title": "Applicability Scope",
      "content": "Solutions #2, #12 and #5 restrict sharing of data to NF sets and does not address sharing of data that may be common to NFs (of same or different type) from different sets.\nSolution #3 is restricted to NF instance level.\nSolution #1 has no restriction, i.e. it is applicable on PLMN level.\nSolution #4 can be applicable on PLMN level or level NRF instance level.\nSolution #11 is restricted to the Routing Indicator data set, as shareable data, and therefore it is restricted to the producer NF types that make use of such data.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.7",
      "section_id": "7.1.7",
      "section_title": "Backward compatibility",
      "content": "All solutions except Solution #11 require feature support indications to ensure backward compatibility with no-supporting legacy NFs.\nSolution #11 does not require any modification on the interaction between the producer and the NRF, and it simply implies that the producer will no longer include the list of supported Routing Indicators in its NFProfile.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.1.8",
      "section_id": "7.1.8",
      "section_title": "Comparison",
      "content": "Detailed comparison of the solutions can be listed as below:\nSolution #1\nSolution #2\nSolution #3\nSolution #4\nSolution #5\nSolution #8\nSolution #9\nSolution #12\nSynchronization of Shareable Data\nSynchronized configuration in all NFs and all NRFs is required\nOptionA: no synchronized configuration between NFs and NRFs required\nOption B: synchronized configuration between NF sets and NRF(set) required\nN/A\nSynchronized configuration in all NFs and higher level NRF is required\nno synchronized configuration between NFs and NRFs required\nAvoid duplicate subscription and change notification via UDSF.\nAvoid duplicate subscription and change notification via the NRF.\nno synchronized configuration between NFs and NRFs required\nSupport for change of shareable data\nFFS\nFFS\nFFS\nFFS\nFFS\nFFS\nFFS\nFFS\nStorage requirements\nShared data are stored/ configured in all/multiple NFs and NRFs\nOption A: Shared set profile is stored/configured at the NF set only\nOption B: Shared set profile is stored/configured at the NF set and at singleNRF\nN/A\nShared data are stored/ configured in all/multiple NFs and in a higher level NRF\nShared data are stored/configured at the NF set only\nShared data are stored/configured at a single NF set\nShared data are stored/configured at a single NF set\nShared data are stored/configured at the NF set and the NRF(s) serving the NF Set\nDiscovery procedure\nOne additional message roundtrip only when shared data are not cached\nAlternative 1: No additional Roundtrip at the cost of higher message size\nAlternative 2: One additional message roundtrip only when shared data are not cached\nResponse message length is reduced at the cost of more message roundtrips\nOne additional message roundtrip only when shared data are not cached\nNo additional Roundtrip at the cost of higher message size\nNo additional Roundtrip at the cost of higher message size\nNo additional Roundtrip at the cost of higher message size\nNo additional Roundtrip at the cost of higher message size\nWhich data should be shareable?\nffs\nNo need to standardize\nN/A\nN/A\nffs\nN/A\nN/A\nffs\nNew NF service operations\nNot required\nNot required\nNot required\nNot required\nAll NFs must provide a shared data retrieval service operation to be consumed by the NRF\nNot required\nNot required\nNot required\nApplicability scope\nPLMN level\nNF Set level\nNF Instance Level\nNRF level or PLMN level\nNF Set level\nNF Set level\nNF Set level\nNF set level\nBackward Compatibility\nBy including Shared Data support indication\nBy including Set profile Support Indication\nBy indicating support of paginated data retrieval feature\nBy indicating support for sharedData feature\nBy indicating support for sharedData feature\nNot required\nBy indicating support of sharing NF profile change notification\nBy indicating support for sharedData feature",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_7.2",
      "section_id": "7.2",
      "section_title": "Evaluation of Solutions for Key Issue#2",
      "content": "Solution for Key issue#2 aim to address the signalling overhead of NF Discovery Responses between PLMNs.\nSolution #10 reduce the signalling overhead of NF discovery response by only containing value that match the NF discovery request parameters in the response. Solution #10 might increase the number of NF discovery message, however, the overall overhead of NF discovery procedure between PLMNs will be optimized.\nSolution #6 would shorten NF discovery response messages by removing certain parameters from the message, and operators need to determine which parameters can be removed without affecting services.\nSolution #10 reduce values of parameters of array or map type in NF discovery response, while solution #6 reduce unnecessary parameters. And they could be applicable to different scenarios.\nSolution #10 could apply on most parameters of array or map type, while solution #6 might be applicable to a few scenarios and hard to define the rules for reducing which kind of parameters.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_8.1",
      "section_id": "8.1",
      "section_title": "Conclusion of Solutions for Key Issue#1",
      "content": "The following principles are concluded for key issue #1:\n1.\tFor backwards compatibility, the selected solution shall make use of the supported feature negotiation mechanism.\n2.\tFor forward compatibility, the selected solution shall try to avoid the need to standardize, which data are shareable.\n3.\tWhether new NF services are needed will be decided during normative work.\n4.\tThe selected solution shall allow to take advantage of the NF set concept, by defining NF Set profiles. NF set profiles may contain one or more shared data IDs pointing to PLMN-level shared data.\n5.\tThe selected solution shall allow to use shared-data concept across NFs not belonging to an NF-Set.\n6.\tThe selected solution should avoid the need for shared data configuration at multiple NFs within the network. The solutions of both OAM based and OAM-less solution will be further worked on during normative phase of work.\n7.\tThe NRF should optionally allow other NFs to register (and modify and delete) those NfSetProfiles/Shared Data at the NRF the other NFs may make use of. The details are ffs during normative work.\n8.\tThe NRF shall allow other NFs to retrieve (and subscribe to) NfSetProfiles/Shared Data\n9.\tThe selected solution shall ensure that a change of NfSetProfile/Shared Data is propagated between NF set and NRF set involving only one NF instance from the NF set and only one NRF instance from the NRF set.\n10.\tThe selected solution shall allow to avoid the need of including large lists of UE Routing Indicators in NF profiles registered at the NRF, e.g. by NRF configuration or by interaction with the UDR.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.831_8.2",
      "section_id": "8.2",
      "section_title": "Conclusion of Solutions for Key Issue#2",
      "content": "Based on the evaluation of solutions for key issue#2, it is recommended to adapt solution #10 as basis for normative work. With solution#10, NF discovery response messages could be greatly simplified in most scenarios of inter PLMN by reducing values of parameters of array or map type in the messages, while these parameters cannot not be removed from the messages.\nThe new indication added to NF discovery response is optional, and NF consumer could either ignore it without any impact, or do extension processing with it. It is FFS what the impact of the new indication in NF discovery response on NF consumer, and whether it is necessary.\nAnnex A (informative):Change history\nChange history\nDate\nMeeting\nTDoc\nCR\nRev\nCat\nSubject/Comment\nNew version\n2022-08\nCT4#111e\nC4-224138\nSkeleton\n0.1.0\n2022-08\nCT4#111e\nC4-224206\nPseudo-CR on Scope\n0.1.0\n2022-08\nCT4#111e\nC4-224454\nKey Issue for Avoiding Duplicate Configuration and Transmission of Shareable Data\n0.1.0\n2022-08\nCT4#111e\nC4-224455\nSolution for Avoiding Duplicate Configuration and Transmission of Shareable Data\n0.1.0\n2022-11\nCT4#113\nC4-225327\nNew KI on Signaling overhead of NF discovery responses between different PLMNs\n0.2.0\n2022-11\nCT4#113\nC4-225517\nSolution for Support of NF (Service) Set Profiles\n0.2.0\n2022-11\nCT4#113\nC4-225520\nUpdates to Solution #1\n0.2.0\n2022-11\nCT4#113\nC4-225521\nSolution for Downloading Large Volume Data within NF Profile\n0.2.0\n2022-11\nCT4#113\nC4-225549\nUpdate of Key Issue #1 on Support of NF (Service) Set Profiles\n0.2.0\n2022-11\nCT4#113\nC4-225557\nUpdates on Key Issue #1 for FS_NRFe\n0.2.0\n2022-11\nCT4#113\nC4-225558\nNew Solution for Key Issue #1 of FS_NRFe with enhanced inter NRF interaction\n0.2.0\n2022-11\nCT4#113\nC4-225560\nNew Solution for Key Issue #1 of FS_NRFe to support set level shared data\n0.2.0\n2022-11\nCT4#113\nC4-225561\nUpdates on Baseline\n0.2.0\n2022-11\nCT4#113\nC4-225573\nUpdates to Key Issue #1\n0.2.0\n2023-03\nCT4#114\nC4-230669\nNRF Policy Control on Information Exposure for different PLMNs\n0.3.0\n2023-03\nCT4#114\nC4-230656\nEvaluation of Solutions\n0.3.0\n2023-03\nCT4#114\nC4-230518\nList of Shareable Data Types\n0.3.0\n2023-03\nCT4#114\nC4-230521\nSolution for NF Profile Change Notification to NFs in an NF Set\n0.3.0\n2023-03\nCT4#114\nC4-230657\nNew Solution on KI#2 of simplifying the NF service discovery response of inter-PLMN\n0.3.0\n2023-04\nCT4#115e\nC4-231098\nUpdate of Solution #6\n0.4.0\n2023-04\nCT4#115e\nC4-231365\nSolution Evaluation for Key Issue #1\n0.4.0\n2023-05\nCT4#116\nC4-232264\nSolution Update for Solution #5 of FS_NRFe\n0.5.0\n2023-05\nCT4#116\nC4-232536\nSolution Update for Solution #10 of FS_NRFe\n0.5.0\n2023-05\nCT4#116\nC4-232634\nEvaluation for Key Issue #1 of FS_NRFe\n0.5.0\n2023-05\nCT4#116\nC4-232635\nSolution Evaluation for Key Issue #1 of FS_NRFe\n0.5.0\n2023-06\nCT#100\nCP-231023\nPresented for information\n1.0.0\n2023-09\nCT4#117\nC4-233046\nClean Up\n1.1.0\n2023-09\nCT4#117\nC4-233122\nCompleting the Comparison Table for Key Issue #1\n1.1.0\n2023-09\nCT4#117\nC4-233272\nStorage of RID ranges in UDR\n1.1.0\n2023-09\nCT4#117\nC4-233374\nNew Solution for Key Issue #1 of FS_NRFe to support set level shared data\n1.1.0\n2023-09\nCT4#117\nC4-233778\nConclusion for Key Issue #2 of FS_NRFe\n1.1.0\n2023-09\nCT4#117\nC4-233847\nSolution Evaluation for Key Issue #1 of FS_NRFe\n1.1.0\n2023-09\nCT4#117\nC4-233878\nSolution Evaluation for Key Issue #2 of FS_NRFe\n1.1.0\n2023-09\nCT4#117\nC4-233886\nConclusion for KI#1\n1.1.0\n2023-09\nCT#101\nCP-232023\nTR Presented for approval\n2.0.0\n2023-09\nCT#101\nTR Approved\n18.0.0",
      "chunk_type": "general",
      "cross_references": []
    }
  ]
}