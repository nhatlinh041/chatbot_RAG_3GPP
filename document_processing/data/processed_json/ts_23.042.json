{
  "metadata": {
    "specification_id": "ts_23.042",
    "version": "18.0.0",
    "title": "3GPP TS 23.042",
    "file_path": "/content/drive/MyDrive/RAG_thesis/data/23_series/23042-i00/23042-i00.docx"
  },
  "export_info": {
    "export_date": "2025-07-26T09:38:29.187684",
    "total_chunks": 57
  },
  "chunks": [
    {
      "chunk_id": "ts_23.042_1",
      "section_id": "1",
      "section_title": "Scope",
      "content": "The present document introduces the concepts and mechanisms involved in the compression and decompression of a stream of data.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_2",
      "section_id": "2",
      "section_title": "References",
      "content": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non‑specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_2.1",
      "section_id": "2.1",
      "section_title": "Normative references",
      "content": "[1]\t3GPP TS  23.038: \"Alphabets and language‑specific information\".",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.038"
      ]
    },
    {
      "chunk_id": "ts_23.042_2.2",
      "section_id": "2.2",
      "section_title": "Informative references",
      "content": "[2]\t\"The Data Compression Handbook 2nd Edition\" by Mark Nelson and Jean-Loup Gailly, published by M&T Books, ISBN 1-22851-434-1.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_3",
      "section_id": "3",
      "section_title": "Abbreviations",
      "content": "For the purposes of the present document, the following abbreviations apply.\nCD\tCompressed Data\nCDS\tCompressed Data Stream\nCDSL\tCompressed Data Stream Length\nCF\tCompression Footer\nCG-ID\tCharacter Group ID\nCH\tCompression Header\nCLC\tCompression Language Context\nHI-ID\tHuffman initialization ID\nKD-ID\tKeyword Dictionary ID\nPU-ID\tPUnctuator ID",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_4",
      "section_id": "4",
      "section_title": "Algorithms",
      "content": "The compression algorithm comprises a number of components that may be combined in a variety of configurations. The discrete algorithms are discussed in the following subclauses.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_4.1",
      "section_id": "4.1",
      "section_title": "Huffman Coding",
      "content": "The base compression algorithm is a Huffman coder, whereby characters in the input stream are represented in the output stream by bit sequences of variable length. This length is inversely proportional to the frequency with which the character occurs in the input stream.\nThis is the only component of the whole compression algorithm that can be expected to be included in any implementation, all other components are optional.\nThere are two possible approaches here:\na)\tthe (de)coder can be \"pre-loaded\" with a character frequency distribution, thus improving compression rate for streams that approximate to this distribution; or\nb)\tthe (de)coder can adapt the frequency distribution it uses to (de)code characters based on the incidence of previous characters within the input stream.\nIn both cases, the character frequency distribution is represented in a \"tree\" structure, an example of which is shown in figure 1.\nFigure 1: Character frequency distribution\nThe tree represents the characters Z, W, T, R, A, O and E which have frequencies of 1, 1, 4, 6, 10, 10 and 40 respectively. The characters may be coded as variable length bit streams by starting at the \"character node\" and ascending to the \"root node\". At each stage, if a left hand path is traversed, a 0 bit is emitted and if a right hand path is traversed a 1 bit is emitted. Thus the infrequent Z and W would require 5 bits, whereas the most frequent character E requires just 1 bit. The resulting bit stream is decoded by starting at the \"root node\" and descending the tree, to the left or right depending on the value of the current bit, until a \"character node\" is reached.\nIt is a requirement that at any time the trees expressing the character frequencies shall be identical for both coder and decoder. This can be achieved in a number of ways.\nFirstly, both coder and decoder could use a fixed and pre-agreed frequency distribution that includes all possible characters but as noted above, this use of \"prior information\" suffers when a given input stream has a significantly different character frequency distribution.\nSecondly, the coder may calculate the character frequency distribution for the entire input stream and prepend this information to the encoded bit stream. The decoder would then generate the appropriate tree prior to processing the bitstream. This approach offers good compression, especially if the character frequency information may itself be compressed in some manner. Approaches of this type are common but the cost of the prepended information for a potentially small data stream makes it less attractive.\nThirdly,  extend the algorithm such that although both coder and decoder start with known frequency distributions, and subsequently adapt these distributions to reflect the addition of each character in the input stream. One possibility is to have initial distributions that encompass all possible characters so that all that is required, as each input character is processed, is to increment the appropriate frequency and update the tree. However, the inclusion of all possible characters in the initial distribution means that the tree is relatively slow to adapt, making this approach less appropriate for short messages. An alternative is to have an initial distribution that does not include all possible characters and to add new characters to the distribution if, and when, they occur in the input stream.\nTo achieve the latter approach, the concept of a \"special\" character is required. A \"special\" character is one whose value is outside the range of the character set being used (e.g. 256 if the character set has a range 0 to 255). These characters therefore do not form part of the input stream being conveyed, but their existence in the compressed stream signals the need for the decoder to adjust its behaviour. Here a \"special\" character is used to signal that the following n bits (where n is a fixed value) represent a new character that needs to be added to the frequency distribution. In the example above this would be done by replacing the \"character\" node containing the character Z with a new node that had as its children the \"character\" nodes for Z and for the new character.\nThis is the approach taken here. It provides considerable flexibility, effectively enabling all of the foregoing approaches. The specific approach to be used for a given message is signalled in the header.\nThe algorithm uses an additional optimization in that 2 special characters are defined, one meaning that a 7-bit literal follows and the other for 8-bit characters. So for example:\n\tThe initial tree can contain just the \"new character follows\" special character(s). In this case, the input stream \"AAA\" would result in:[1 bit = new character(7bit) special][7 bits = \"A\"][2 bits = \"A\"][1 bit = \"A\"]\n\tAs can be seen from the above there is quite a high cost in adding a new character (the \"special\" plus literal). So if the initial tree contains a small subset of the generally most frequently used characters, the cost of character addition can be avoided for these characters.\n\tGiven that we can signal in the header a specific initial frequency distribution, there is no reason why this distribution cannot contain all possible characters and frequency adaptation enabled or disabled as appropriate.\nA detailed description of Huffman coding can be found in Chapter 4 of  \"The Data Compression Handbook 2nd Edition\" by Mark Nelson and Jean-Loup Gailly, published by M&T Books, ISBN 1-22851-434-1.",
      "chunk_type": "general",
      "cross_references": [
        "figure_1"
      ]
    },
    {
      "chunk_id": "ts_23.042_4.2",
      "section_id": "4.2",
      "section_title": "Character Groups",
      "content": "Character grouping is an optional component that can effect an increase in compression performance of the Huffman coder. This technique groups characters that may be expected to occur together within the input stream and signals transitions between the groups rather than each individual character.\nThe algorithm derives benefit by;\na)\treducing the need to add new characters to the frequency distribution; and\nb)\tusing a smaller overall tree. For example, assume that there is no pre-loaded distribution and a stream comprised the characters \"abcdefABCDEF\".\nThe capital letters can be encoded more efficiently by signalling the transition to \"upper case\" and then coding the extant lower case characters rather than introducing 6 new characters. \"Special\" characters are used to signal transitions between groups of characters.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_4.3",
      "section_id": "4.3",
      "section_title": "UCS2",
      "content": "Input streams comprising 16bit UCS2 information are handled in a manner similar to Character groups. Both coder and decoder maintain knowledge of \"the current\" Basic Multilingual Plane row for characters in the input stream and the row octet itself is then omitted from the output stream for sequences of characters within that row. Transitions between rows are signalled in the output stream by a \"special\" character.\nSupport for UCS2 is optional.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_4.4",
      "section_id": "4.4",
      "section_title": "Keywords",
      "content": "The algorithm optionally supports the concept of dictionaries - essentially a list of key words or phrases of up to 255 characters in length. Dictionaries need to be known to both the coder and the decoder. The input stream is matched against entries in the dictionary and matching characters in the stream are replaced with a reference to the dictionary entry.\nAgain \"special\" characters are used to signal that the following sequence of bits describe a reference to a dictionary entry. So for example, if a dictionary contains the phrases \"Please\" and \"meeting\", an input stream \"Please cancel the monthly meeting\" would be rendered as:\n[keyword special][10 bits = \"Please\"][.......][keyword special][10 bits = \"meeting\"]\nDictionary matches for long strings can result in very high compression rates.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_4.5",
      "section_id": "4.5",
      "section_title": "Punctuation",
      "content": "The punctuation processor is distinct from the other algorithms in that it is non-symmetric so the decompressed stream may not be identical to the original. Its use is therefore mainly applicable to input streams comprising human readable sentences where it is sufficient to preserve the meaning of the content, but not the exact format. It is also applicable when the input stream is a \"standard sentence\" that is known to produce a symmetric result. The punctuation processor is applied before (on coding) and after (on decoding) any of the other algorithms. Its functions are:\n\tto remove leading and trailing spaces from the input stream;\n\tto replace repeated spaces within the stream with a single space;\n\tto remove (on coding) and insert (on decoding) spaces following certain punctuation characters;\n\tto decapitalize (on coding) and capitalize (on decoding) the first character of the stream, the first character following an appropriate punctuation character or a paragraph symbol and capitalized single character words such as \"I\";\n\tto remove (on coding) and insert (on decoding) a full stop if it is the last character of the stream.\nThe use of the punctuation processor is optional.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_4.6",
      "section_id": "4.6",
      "section_title": "Character Sets",
      "content": "The use of pre-loaded frequencies, key word dictionaries and the punctuation processor all require that a consistent character set is used by both coder and decoder. As there can be no assumption that the same character will be have the same value (or even be available) on the devices used to send and receive a compressed message, the algorithms are specified to operate on a known character set to which (prior to coding) and from which (post decoding) a device needs to convert an input stream to render it in the native character set of the device.\nThe handling of character sets is mandatory for all implementations.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_5",
      "section_id": "5",
      "section_title": "Compressed Data Streams",
      "content": "This clause provides:\n-\tA detailed specification of the algorithms and data structures that implement compression and decompression mechanisms.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_5.1",
      "section_id": "5.1",
      "section_title": "Structure",
      "content": "A Compressed Data Stream (CDS) comprises three key components:\n-\ta Compression Header (CH) containing a variable number of octets, the content of which defines the nature of the compressed data;\n-\tthe Compressed Data (CD) which is a bit stream of variable length;\n-\ta Compression Footer (CF) which is used to signal the number of bits in the last octet of the CDS that form part of the compressed data.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_5.2",
      "section_id": "5.2",
      "section_title": "Compression Header",
      "content": "The Compression Header (CH) comprises a variable number of octets that define the nature of the compressed data.\nThe compression header allows for a wide range of compression alternatives, however of these alternatives only one is defined as the basic mandatory form of compression that shall be supported by all implementations. This is the use of the basic Huffman algorithm initialized with no prior knowledge of character distribution. This case can be signalled directly by setting a single octet(octet 1) for the compression header with the value of 120 (decimal).",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_5.2.1",
      "section_id": "5.2.1",
      "section_title": "Compression Header - Octet 1",
      "content": "The first CH octet is mandatory and is defined as follows:\nTable 1: CH octet\n7\n6\n5\n4\n3\n2\n1\n0\nDescription\n0\nThere is no subsequent CH octet\n1\nA further CH octet follows\nn\nn\nn\nn\nThe \"Compression Language Context\" this is described below\n0\nPunctuation processing disabled\n1\nPunctuation processing enabled\n0\nKeyword processing disabled\n1\nKeyword processing enabled\n0\nCharacter group processing disabled\n1\nCharacter group processing enabled\nAs noted in clause 4, the compression algorithms can be configured to operate in a variety of ways and may rely on end-to-end knowledge of \"prior\" information such as which key word dictionary is to be used.\nA requirement that all configuration information be explicitly stated in the CH is less efficient (in terms of compression ratio) than if a default configuration is known and only variations from this need be signalled. However, a major determinant of configuration is the language in which the original message to be compressed is composed. For example, different keyword dictionaries would be required for French and opposed to German and character frequency distributions for English texts may vary greatly from those for Swedish texts. From this it can be seen that a universal \"default\" configuration would be of little value.\nTo address this, the Compression Language Context (CLC) allows a default configuration to be specified for each of the languages defined in 3GPP TS 23.038 [1] in relation to the Cell Broadcast Data Coding Scheme as follows:\n-\tThe CLC in bits 6 to 3 of the CH specify the language as per 3GPP TS 23.038 [1] in the case where bits 7 to 4 of the Cell Broadcast Data Coding Scheme octet are set to 0000.\n-\tIf and when required, higher order bits of the CLC can be signalled by a subsequent CH octet as described below.\n-\tThe CLC value 1111 (language unspecified) will indicate a \"default\" configuration that is language independent. This is specified in annex R and involves the basic  Huffman (de-)coding with no initial character frequency distribution, see example below.\nTable 2: Huffman (de-)coding with no initial character frequency distribution\n7\n6\n5\n4\n3\n2\n1\n0\nDescription\n0\n1\n1\n1\n1\n0\n0\n0\nBasic Huffman (de-)coding only.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4",
        "table_1",
        "table_2",
        "ts_23.038"
      ]
    },
    {
      "chunk_id": "ts_23.042_5.2.2",
      "section_id": "5.2.2",
      "section_title": "Compression Header - Octets 2 to n",
      "content": "Any second and subsequent CH octets are used to vary the configuration defaults established by the CLC. These octets all comprise a continuation bit followed by a Type, Value structure as follows:\nTable 3: Value structure\n7\n6\n5\n4\n3\n2\n1\n0\nDescription\n0\nThere is no subsequent CH octet\n1\nA further CH octet follows\nn\nn\nn\nCH Extension Type\nn\nn\nn\nn\nCH Extension Value\nThe bits of the semi-octet CH Extension value are interpreted left to right, MSB to LSB. If the CH contains more than one octet of the same CH Extension type, the CH Extension value of a subsequent CH octet, is interpreted as being next most significant semi-octet of the composite value being signalled.\nFor example if the CLC in CH octet 1 indicates that the default Huffman Initialization ID is 1 (decimal) and the required HI-ID is 37 (decimal), then the following octets (in the range 2 to n) would also be required in the CH.\nTable 4: CH extension octets  (Example)\n7\n6\n5\n4\n3\n2\n1\n0\nDescription\n1\n0\n1\n1\n0\n1\n0\n1\nThe default HI-ID is replaced with the value 0101\n0\n0\n1\n1\n0\n0\n1\n0\nThe current HI-ID value (0101) is extended to 0010 0101\nThe following values are defined for the CH Extension Type:\n000\tExtend CLC. The CH Extension Value contains higher order bits that are to be pre-pended to the current CLC value.\nNOTE:\tfor 1st occurrence of the Extend CLC CH Extension Type in the CH, the value for the CLC specified in CH octet 1 is not replaced but rather the process of \"extension\" begins directly. Thus is the CLC to be used is 18, octets 1 and 2 of the CH would contain:\nTable 5: CLC extension  (Example)\n7\n6\n5\n4\n3\n2\n1\n0\nDescription\n1\n0\n0\n1\n0\nThe least significant semi-octet of the CLC is 0010\n0\n0\n0\n0\n0\n0\n0\n1\nThe CLC value (0010) is extended to 0001 0010\n001\tChange Character Set. The CLC defines a default character set (UCS2 or otherwise) within which compression will operate. The Change Character Set CH Extension Type indicates that this should be overridden by the character set specified by the CH Extension Value. If a CH contains more than one Change Character Set CH Extension Type octet, the CH Extension Value contained in subsequent CH octets of this type contains higher order bits and are to be pre-pended to the value of the new character set.\nThe following Character Sets are defined:\n0000\tNo character set defined. To be used where original message content is binary data and \tcompression is solely via Huffman coding with no initial frequency training and thus there is no \trequirement to ensure consistent use of character set by coder and decoder.\n0001\tGSM 7 bit default alphabet (3GPP TS 23.038 [1])\n0010\tCodepage 437\n0011\tCodepage 850\nAll other values are reserved - see section 5.2.2.1\nA Change Character Set to UCS2 codepoint is not defined here. Where the  CLC  indicates a character set other than UCS2 and there is a need to change to UCS2 then this is achieved using the Change UCS2 row parameter  described below.\n010\tChange UCS2 Row. The CLC defines a default character set (UCS2 or otherwise) within which compression will operate. The Change UCS2 Row CH Extension Type indicates that this should be overridden by the use of UCS2 and the UCS2 row value for the first character in the input stream is that specified by the CH Extension Value. If a CH contains more than one Change UCS2 Row CH Extension Type octet, the CH Extension Value contained in subsequent CH octets of this type contains higher order bits for the initial UCS2 Row value and are to be pre-pended to the current value.\nNOTE:\tChange UCS2 Row CH Extension Type octet effectively overrides any prior Change Character Set CH Extension Type octet and vice versa so these types are logically mutually exclusive within a given CH.\n011\tChange Huffman Initialization. The CLC defines a default set of parameters for the initialization of the Huffman (de)coder. The Change Huffman Initialization CH Extension Type indicates that this should be overridden by the set of initialization parameters identified by the Huffman Initialization ID contained in the CH Extension Value. If a CH contains more than one Change Huffman Initialization CH Extension Type octet, the CH Extension Value contained in subsequent CH octets of this type contains higher order bits for the initial Huffman Initialization ID value and are to be pre-pended to the current value.\n100\tChange Keyword Dictionary. The CLC defines a default set of parameters for the initialization of the Keyword (de)coder. The Change Keyword Dictionary CH Extension Type indicates that this should be overridden by the set of initialization parameters identified by the Keyword Dictionary ID contained in the CH Extension Value. If a CH contains more than one Change Keyword Dictionary CH Extension Type octet, the CH Extension Value contained in subsequent CH octets of this type contains higher order bits for the initial Keyword Dictionary ID value and are to be pre-pended to the current value.\n101\tChange Punctuator. The CLC defines a default set of parameters for the initialization of the punctuation (de)coder. The Change Punctuator CH Extension Type indicates that this should be overridden by the set of initialization parameters identified by the Punctuator ID contained in the CH Extension Value. If a CH contains more than one Punctuator CH Extension Type octet, the CH Extension Value contained in subsequent CH octets of this type contains higher order bits for the initial Punctuator ID value and are to be pre-pended to the current value.\n110\tChange Character Group. The CLC defines a default set of parameters for the initialization of the Character Group (de)coder. The Change Character Group CH Extension Type indicates that this should be overridden by the set of initialization parameters identified by the Character Group ID contained in the CH Extension Value. If a CH contains more than one Change Character Group CH Extension Type octet, the CH Extension Value contained in subsequent CH octets of this type contains higher order bits for the initial Character Group ID value and are to be pre-pended to the current value.\n111\tReserved, see section 5.2.2.1",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2.2.1",
        "table_3",
        "table_4",
        "table_5",
        "ts_23.038"
      ]
    },
    {
      "chunk_id": "ts_23.042_5.2.2.1",
      "section_id": "5.2.2.1",
      "section_title": "Compression Header  reserved extension types and values",
      "content": "Any currently undefined values in the range 0 to 255 decimal are reserved.\nValues above 255 are available for user to user requirements.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_5.2.3",
      "section_id": "5.2.3",
      "section_title": "Identifying unique parameter sets",
      "content": "The four component compression algorithms (Huffman, Keywords, Character Groups and Punctuation) may all have a variety of initialization options. For each algorithm, a given set of initialization options needs to be identified for the processing of a given input stream.\nInitialization and operation of the algorithms depends not only on the language in which the original source text is composed but also the character set (UCS2 or otherwise) that is to be used during processing. Thus the Huffman Initialization ID (HI-ID), Keyword Dictionary ID (KD-ID), Punctuator ID (PU-ID) and Character Group ID (CG-ID) only define unique values within the context of a given character set (the default established by the CLC or subsequently amended via Change Character Set or Change UCS2 Row CH Extension types) and within the context of the language indicated by the CLC.",
      "chunk_type": "parameter",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_5.3",
      "section_id": "5.3",
      "section_title": "Compressed Data",
      "content": "The Compressed Data (CD) is a stream bits of variable length that represent either an encoding of the content original input stream or control information indication that the operation of some algorithm should vary in some manner.\nControl information is signalled within the CD by Huffman encoded symbols (characters) whose value is greater than 255 decimal. Huffman encoded symbols in the range 0 to 255 are of course characters from the original input stream.\nThe following control symbols are defined:\nTable 6: Compressed Data: control symbols\nDecimal value\nSignificance\n256\nNew 7 bit character.\nOn encoding, if a character (octet) from the input stream in the range 0 to 127 does not exist in the Huffman tree, then the New 7 bit character symbol is Huffman encoded to the CD and bits 6 to 0 of the original octet are copied unchanged to the CD. The Huffman tree would then be updated to include the new character as described in the sections below.\nOn decoding the New 7 bit character symbol, the symbol itself is discarded and the next 7 bits of the CD are copied unchanged to bits 6-0 of the octet to be output, bit 7 of which is zero. The Huffman tree would then be updated to include the new character.\n257\nNew 8 bit character.\nThe operation of this is identical to that of the New 7 bit character except that on encoding, the input character is in the range 128-255 and on decoding, bit 7 of the output character is set to 1.\n258\nKeyword.\nThis symbol (Huffman encoded) Huffma\\n encodedprefixes a sequence of bits of variable length in the CD that define a representation of characters in the uncompressed stream by an entry in a keyword dictionary.\nOn encoding, if a sequence of characters in the input stream can be represented by an entry in a keyword dictionary, the Keyword symbol is Huffman encoded to the CD followed by the bit sequence describing the keyword entry (this is described below).\nOn decoding the Keyword symbol, the symbol itself is discarded and the bit sequence describing the keyword entry is passed to the Keyword processor to recovery the original character sequence to be placed in the output stream.\n259 to 265\nCharacter Group Transitions.\nThese symbols signal transitions between groups of characters defined within the Character Group processor. For example, if 2 groups are defined to be the lower case and upper case characters then the input stream:\n\"abcdefABCDEF\" would become \"abcdef<Change Group>abcdef\"\nOn encoding, Character Group Transition symbols are generated by the Character Group processor and simply passed to the Huffman processor for encoding.\nOn decoding a Character Group Transition symbol, it is simply passed from the Huffman processor to the Character Group processor which takes the appropriate action based its current state and the group transition indicated.\n266\nNew UCS2 Row.\nOn encoding, if the next UCS2 character in the input stream has a \"row octet\" of a different value to that of the previous character in the input stream, the New UCS2 Row symbol is Huffman encoded to the CD and the 8 bit of the new row octet are copied unchanged to the CD. The new row octet is stored by the UCS2 processor as the \"current row octet\" and subsequent input characters within the current row are Huffman encoded as the 8 bit value of the character within the \"current row\".\nOn decoding the New UCS2 Row symbol, the symbol is discarded and the next 8 bits are read from the CD and stored by the UCS2 processor as the \"current row octet\". Subsequent UCS2 characters are decoded by treating the 8 bit character values decoded by the Huffman processor as characters within the \"current row\".",
      "chunk_type": "general",
      "cross_references": [
        "table_6"
      ]
    },
    {
      "chunk_id": "ts_23.042_5.4",
      "section_id": "5.4",
      "section_title": "Compression Footer",
      "content": "Although Compressed Data Stream Length (CDSL) - the total number of octets that contain the CDS - is known, the CD element of the CDS is a bit stream and therefore may not end on an octet boundary. The Compression Footer (CF) is used to indicate the end of the CD as follows:\n-\tCalculate the number of meaningful bits in the last octet of the CD (i.e. total CD bits modulo 8).\n-\tIf the number of meaningful bits is >0 and <6 store the number of meaningful bits in bits 2 to 0 of the last octet. Otherwise extend the CD by adding 1 octet and store the number of meaningful bits in  bits 2 to 0 of this new octet. In the case where the number of meaningful bits is 8 then bits 2 to 0 of the new octet are set to zero.\nFor example if there are 4 meaningful bits in the last CD octet, the CF will be constructed to occupy the shaded area in  table 7.\nTable 7: CF with >0 and <6 meaningful bits in last octet (Example)\n0\n7\n6\n5\n4\n3\n2\n1\n0\nX\nX\nX\nX\nX\n1\n0\n0\nAlternatively if there are 6 meaningful bits in the last CD octet, a new octet needs to be added. The CF will be constructed to occupy the shaded area in table 8.\nTable 8: CF with >5 meaningful bits in last octet (Example)\n0\n7\n6\n5\n4\n3\n2\n1\n0\n7\n6\n5\n4\n3\n2\n1\n0\nX\nX\nX\nX\nX\nX\nX\n1\n1\n0\nIf there are 8 meaningful bits in the last CD octet, a new octet needs to be added. The CF will be constructed to occupy the shaded area in table 8a.\nTable 8a: CF with 8 meaningful bits in last octet (Example)\n0\n7\n6\n5\n4\n3\n2\n1\n0\n7\n6\n5\n4\n3\n2\n1\n0\nX\nX\nX\nX\nX\nX\nX\nX\nX\n0\n0\n0\nIn all the tables above, the bits in the shaded area which have no bit value defined are set according to the particular bearer being used to transport compressed data. e.g. CBS. Where no particular reference is made regarding the value of those bits they may be set to any value.",
      "chunk_type": "general",
      "cross_references": [
        "table_7",
        "table_8"
      ]
    },
    {
      "chunk_id": "ts_23.042_6",
      "section_id": "6",
      "section_title": "Compression processes",
      "content": "This clause defines the detailed operation of the various compression algorithms.",
      "chunk_type": "procedure",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.1",
      "section_id": "6.1",
      "section_title": "Overview",
      "content": "This subclause describes how the various compression algorithms are combined.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.1.1",
      "section_id": "6.1.1",
      "section_title": "Compression",
      "content": "Table 9: Compression\nInput\n1)\tThe nature of the compression to be performed.\n2)\tThe input stream of characters to be compressed.\nStep 1\nConstruct the Compression Header so as to fully describe the nature of the compression to be performed as requested by higher software layers.\nNote that it is the responsibility of higher software layers that use the compression algorithms to ensure that only those aspects of the compression algorithms that are supported by a particular implementation are requested.\nStep 2\nInitialize as defined by the CH the following components:\n1)\tCharacter Set Converter\n2)\tPunctuation Processor\n3)\tKeyword Processor\n4)\tUCS2 Processor\n5)\tCharacter Group Processor\n6)\tHuffman Processor\nStep 3\nIf the Character set in which input stream is composed is different from that specified in the CH, convert the input stream so that it is rendered in the Character set (UCS2 or otherwise) specified in the CH.\nNote that if characters in the input stream cannot be rendered in the character set specified in the CH, it is the responsibility of higher software layers that use the compression algorithms to detect this situation and take appropriate action.\nStep 4\nIf the Punctuation Processor is enabled, use it to encode the character set converted input stream produced by Step 3 above.\nStep 5\nSet the current character position to the start of the character stream produced as the output of Step 4 above.\nStep 6\nIf the Keyword processor is not enabled goto Step 7.\nExamine the sequence of characters starting at the current character position in the input stream and determine if they can be represented by an entry in the keyword dictionary.\nIf an appropriate keyword is not found goto Step 7.\nIf the Character Group processor is enabled, pass it the Keyword symbol and Huffman encode to the CD the sequence of symbols output by it.\nHuffman encode the Keyword symbol to the CD and then copy the bit sequence describing the keyword entry to the CD.\nGoto Step 10.\nStep 7\nIf the input stream is not UCS2 goto Step 8.\nIf the character at the current character position in the input stream has a different UCS2 row octet from the previous character Huffman encode the New UCS2 Row symbol to the CD and then copy the new row octet to the CD.\nRemove the row octet from the character at the current character position in the input stream which will subsequently treated as an 8 bit value.\nStep 8\nIf the Character Group processor is not enabled goto Step 9.\nPass the character at the current character position in the input stream to the Character Group processor and Huffman encode to the CD the sequence of symbols output by it.\nGoto Step 10.\nStep 9\nHuffman encode the character at the current character position in the input stream.\nStep 10\nIncrement the current character position by the number if input characters processed in steps 6 to 9 above.\nIf the entire input stream has not been processed goto Step 6 above.\nStep 11\nConstruct the Compression Footer.\nOutput\nThe completed Compressed Data Stream.\nNote that the possibility exists that the CDS may be larger than the original input stream. In this case it is the responsibility of higher software layers that use the compression algorithms to detect this situation and take appropriate action.",
      "chunk_type": "general",
      "cross_references": [
        "table_9"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.1.2",
      "section_id": "6.1.2",
      "section_title": "Decompression",
      "content": "Table 10: Decompression\nInput\nThe Compressed Data Stream\nStep 1\nInterpret the Compression Header to determine the nature of the decompression to be performed.\nNote that it is the responsibility of higher software layers that use the decompression algorithms to handle appropriately the case where the nature of the decompression to be performed is not supported by a particular implementation.\nStep 2\nInitialize as defined by the CH the following components:\n1)\tCharacter Set Converter\n2)\tPunctuation Processor\n3)\tKeyword Processor\n4)\tUCS2 Processor\n5)\tCharacter Group Processor\n6)\tHuffman Processor\nStep 3\nInterpret the Compression Footer to determine the total number of significant bits in the Compressed Data (CD). Set the total number of bits processed to zero.\nStep 4\nRead bits from the CD passing them to the Huffman decoder to generate the \"current symbol\". The bits should be read in the order bit 7 to bit 0 within each CD octet. CD octets are processed in the order 1 to n.\nStep 5\nIf the Keyword processor is not enabled, goto Step 6.\nIf the \"current symbol\" is the Keyword symbol, read the bit sequence describing the keyword entry from the CD. Pass the keyword entry description to the Keyword processor for decoding and add the resulting sequence of characters representing the keyword to the output stream.\nGoto Step 9.\nStep 6\nIf the Character Group processor is not enabled goto Step 7.\nIf the \"current symbol\" is a Character Group Transition symbol, pass it to the Character Group processor so that the current group can be updated and goto Step 9.\nIf the value of the \"current symbol\" is in the range 0 to 255 (i.e. not a control symbol), pass the \"current symbol\" to the Character Group processor and set the new value of the \"current symbol\" to that returned by the Character Group processor.\nStep 7\nIf the output stream is not UCS2 goto Step 8.\nIf the \"current symbol\" is the New USC2 Row symbol, read the new \"current UCS2 row octet\" from the CD and goto Step 9.\nPre-pend the \"current UCS2 row octet\" to the 8 bit value of the \"current symbol\" to produce a 16 bit UCS2 character.\nStep 8\nAdd the \"current symbol\" to the output stream.\nStep 9\nIncrement the total number of bits processed by the number of bits read from the CD in steps 4 to 8 above.\nIf the total number of bits processed is less than the total number of significant bits in the CD goto Step 4.\nStep 10\nIf the Punctuation Processor is enabled, use it to decode output stream produced by steps 3 to 9 above.\nStep 11\nIf the Character set (UCS2 or otherwise) specified in the CH, is different from that required by higher level software layers, convert the output stream produced by step 10 above so that it is rendered in the Character set (UCS2 or otherwise) required by higher level software layers.\nNote that if characters in the stream cannot be converted, it is the responsibility of higher software layers that use the compression algorithms to detect this situation and take appropriate action.\nOutput\nThe decompressed original input stream.",
      "chunk_type": "general",
      "cross_references": [
        "table_10"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.2",
      "section_id": "6.2",
      "section_title": "Character sets",
      "content": "The need for character set conversion arises in that a number of the compression algorithms operate on the basis of \"prior information\" about the nature of human readable texts. For example Huffman frequency initializations may specify the an initial relative frequency for the letter \"e\" as opposed to the letter \"x\". Similarly, a keyword dictionary may contain the word \"meeting\".\nConsider the case where a keyword dictionary contains the entry \"£10,000\" composed using the Code Page 850 character set. If an input stream containing the string \"£10,000\" also composed in Code Page 850 is processed, the string will be replace in the CD by a reference to the keyword entry. In contrast if the input string is composed using the GSM 7 bit  default alphabet (3GPP TS 23.038 [1]) than a match between the input string and the keyword entry will not be found as the value of the \"£\" symbol in Code Page 850 is 156 decimal whereas in the GSM 7 bit default alphabet it is 2 decimal.\nThere can be no assumption that higher level software layers responsible for composing the original input stream to be compressed and displaying the resulting decompressed output stream use the same character set.\nThus:\n-\tThe character set used to compose initialization parameter sets and used for the compression of a given input stream shall be the same for both compression and decompression.\n-\tWhere an input stream is composed using a character set that is different from that used for compression it shall be converted prior to compression.\n-\tWhere an output stream is required in a character set that is different from that used for compression it shall be converted after decompression.\nThere is an additional requirement in that a number of the compression algorithms perform upper / lower case conversions upon the characters within the character set used for compression. The mapping between \"lower\" and \"upper\" case characters needs to therefore be known.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.038"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.2.1",
      "section_id": "6.2.1",
      "section_title": "Initialization",
      "content": "Initialization of character set conversion processing will typically involve identifying and loading the appropriate tables to a) convert between character sets and b) convert between upper and lower case characters.\nAs the character set(s) in which uncompressed data is required to be rendered is largely an implementation specific matter, so is the precise specification of the tables to convert these to/from the character set specified for compression. However, they need to be sufficient to support the following functions:",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.2.2",
      "section_id": "6.2.2",
      "section_title": "Character set conversion",
      "content": "Table 11: Character set conversion\nInput\n1)\tThe value of the source character.\n2)\tThe character set in which the source character is rendered.\n3)\tThe character set in which the source character is to be rendered.\nOutput\n1)\tThe value of the converted character.\n2)\tA Boolean value indicating whether a successful conversion has been performed.\nProcess\nIf the source character can be rendered in the target character set, its value in the target characterset is returned and a successful conversion is indicated.\nOtherwise, the value of the source character is returned unchanged, a conversion failure is indicated and higher software layers need to take appropriate action.\nFor example:\n-\tThe character \"A\", 65 decimal in Code Page 850 is rendered in the GSM 7 bit default alphabet also as 65 decimal so this value is returned and a successful conversion is indicated.\n-\tThe character \"£\", 156 decimal in Code Page 850 is rendered in the GSM 7 bit default alphabet as 1 decimal so the value 1 is returned and a successful conversion is indicated.\n-\tThe character \"Û\" 234 decimal in Code Page 850 cannot be rendered in the GSM 7 bit default alphabet so the value 234 is returned unchanged and a conversion failure is indicated.",
      "chunk_type": "general",
      "cross_references": [
        "table_11"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.2.3",
      "section_id": "6.2.3",
      "section_title": "Character case conversion",
      "content": "Conversion between upper and lower case for characters within the character set used for compression will also typically be supported by conversion tables that indicate for each character in the character set, the value of any lower case or upper case equivalent character such that the following function can be supported.\nTable 12: Character case conversion\nInput\n1)\tThe value of the source character.\n2)\tThe case (lower or upper) in which the source character is to be rendered.\nOutput\n1)\tThe value of the case converted character.\nProcess\nIf the character can be rendered in the case requested and the value of this case converted character is different from that of the source character, the value of the case converted character is returned.\nOtherwise (i.e. the source character is already in the requested case or the character does not have upper and lower case equivalents), the value of the source character is returned unchanged.",
      "chunk_type": "general",
      "cross_references": [
        "table_12"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.3",
      "section_id": "6.3",
      "section_title": "Punctuation processing",
      "content": "The punctuation processor achieves compression by using the \"prior information\" that the uncompressed stream is human readable and is constructed of sentences that conform to a known set of punctuation rules. Essentially this means that certain characters within the input stream, of themselves imply information about subsequent characters and this may therefore be omitted from the compressed stream. In this way the algorithm achieves some significant compression in a very simple manner.\nHowever, because the algorithm operates on information about sentence structure rather than the exact sequence of characters used to render this, it is non-symmetric. In other words, although the overall meaning of the human readable input stream is preserved between compression and decompression, the exact sequence of characters is not. Higher level software layers or even user inspection may therefore be required to determine if the use of this processor is appropriate for a given input stream.\nIn addition to the ability to handle the conversion of characters between upper and lower case (as described in the previous subclause), the processor requires that certain characters (expressed in the character set to be used for compression) are assigned special attributes. These are:\nTable 13: special attributes\nAttribute\nDescription\nPU-IWS\nInter-word separator. A character with this attribute is that typically used to separate words within the input stream.\nOnly one character in the character set may have this attribute.\nThis attribute is typically set for the \"space\" character (32 decimal).\nPU-LST\nLast Sentence Terminator. A character with this attribute is that typically used to terminate the last sentence in the input stream.\nOnly one character in the character set may have this attribute.\nThis attribute is typically set for the \".\" full stop character (46 decimal).\nPU-WSF\nWord Separator Follows. A character with this attribute is expected to be followed by one or more characters which have the PU-IWS attribute set.\nAny number of characters within the character set may have this attribute.\nExamples of characters that would normally have this attribute set are the exclamation mark (!), comma (,), full stop (.), colon (:), semi-colon (;) and question mark (?).\nPU-UCF\nUpper Case Follows. A character with this attribute is expected to be followed by  an upper case character such as occurs at the start of a sentence or paragraph.\nAny number of characters within the character set may have this attribute.\nTypically, characters with this attribute set will also have the PU-WSF attribute set. Examples are the exclamation mark (!), full stop (.), and question mark (?).\nOther examples associated with new paragraphs might include the carriage return (13 decimal) and line feed (10 decimal) symbols.\nPU-UCW\nUpper Case Word. A character with this attribute set is expected to be upper case if it is a word i.e. if it is both preceded and succeeded by character with the PU-IWS attribute set.\nAny number of characters within the character set may have this attribute.\nAn example in the English language is the letter \"I\".\nPU-NSI\nNo Separator Insertion. A character with this attribute set is does not have the PU-IWS attribute set but is none the less expected to be preceded by a character for which the PU-WSF attribute is set.\nAny number of characters within the character set may have this attribute.\nTypically, characters with this attribute set will be numeric digits so that the case can be resolved where characters which have the  PU-WSF attribute set such as comma (,) and full stop (.) can be used in number formatting as in the case of the string \"£10,000.25\".",
      "chunk_type": "procedure",
      "cross_references": [
        "table_13"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.3.1",
      "section_id": "6.3.1",
      "section_title": "Initialization",
      "content": "Initialization of the punctuation processor will typically involve loading a table containing the combination of attributes defined for each character in the character set to be used for compression for the language defined by the CLC.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.3.2",
      "section_id": "6.3.2",
      "section_title": "Compression",
      "content": "For compression, the punctuation processor operates as follows:\nTable 14: compression punctuation processor\nInput\nThe input stream of characters to be compressed, rendered in the appropriate character set.\nStep 1\nSet the current character position to the start of the input stream.\nStep 2\nDetermine the attributes of the current character.\nIf some previous character in the input stream has not had the PU-IWS attribute set goto Step 3.\nIf the current character has the PU-IWS attribute set goto Step 8.\nConvert the current character to lower case and store the returned value as that of the \"previous character\". Store the attributes of the current character as those of the \"previous character\" after clearing any PU-UCW attribute.\nGoto Step 8.\nStep 3\nIf the previous character has the PU-WSF attribute and the current character has the PU-IWS attribute goto Step 8.\nOtherwise clear the PU-WSF attribute for the \"previous character\".\nStep 4\nIf the previous character has the PU-UCF attribute, convert the current character to lower case and clear the PU-UCF attribute for the \"previous character\".\nStep 5\nIf the previous character has the PU-UCW attribute and the current character has the PU-IWS attribute, convert the previous character to lower case.\nStep 6\nIf the previous character has the PU-IWS attribute and the current character has the PU-IWS attribute, goto Step 8.\nOtherwise add the previous character to the output stream and set the value of the previous character to that of the current character.\nStep 7\nIf the current character has the PU-UCW attribute and the previous character attributes do not contain the PU-IWS attribute, clear the PU-UCW attribute for the current character.\nSet the attributes for the \"previous character\" to those of the current character.\nStep 8\nIf the current character is the last character in the input stream and if some previous character in the input stream has not had the PU-IWS attribute set and if the previous character attributes contain neither the PU-IWS not the PU-LST attribute, add the previous character to the output stream.\nStep 9\nIf the current character is not the last character in the input stream, read the next character from the input stream, set the current character to this value and goto Step 2.\nOutput\nThe de-punctuated data stream.",
      "chunk_type": "general",
      "cross_references": [
        "table_14"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.3.3",
      "section_id": "6.3.3",
      "section_title": "Decompression",
      "content": "For decompression, the punctuation processor operates as follows:\nTable 15: decompression punctuation processor\nInput\nThe de-punctuated stream of characters to be punctuated, rendered in the character set used for compression.\nStep 1\nSet the current character position to the start of the de-punctuated stream.\nStep 2\nDetermine the attributes of the current character.\nIf the current character is the first character in the stream, convert it to upper case and goto Step 8.\nStep 3\nIf the current character has the PU-IWS attribute and the \"previous character\" attributes has the PU-UCW attribute, convert the stored value of the \"previous character\" to upper case.\nStep 4\nIf the \"previous character\" attributes contain the PU-UCF attribute, and the current character was not generated by Step 10 below, convert the current character to upper case and clear the PU-UCF attribute for the \"previous character\" attributes.\nStep 5\nIf the \"previous character\" was generated as a result of Step 10 and the current character contains the PU-NSI attribute goto Step 7.\nStep 6\nAdd the \"previous character\" value to the output stream.\nStep 7\nIf \"previous character\" attributes contain the PU-IWS attribute and the current character has the PU-UCW attribute, add the PU-UCW attribute to those of the \"previous character\". Otherwise clear any PU-UCW attribute stored for the \"previous character\".\nStep 8\nSet the value of the \"previous character\" to be that of the current character.\nStep 9\nIf the attributes of the current character contain the PU-UCF attribute set this attribute for the \"previous character\".\nStep 10\nIf the attributes of the current character contain the PU-WSF attribute and the current character is not the last character in the de-punctuated stream, insert the character containing the PU-IWS attribute at the position following the current character in the de-punctuated stream.\nStep 11\nIf the current character is not the last character in the de-punctuated stream, read the next character from the stream, set the current character to this value and goto Step 2.\nStep 12\nAdd the previous character to the output stream.\nIf the current character attributes do not contain the PU-UCF attribute or the previous character value equals that of the character which has the PU-LST attribute set, add the character which has the PU-LST attribute set to the output stream.\nOutput\nThe punctuated data stream.",
      "chunk_type": "general",
      "cross_references": [
        "table_15"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.4",
      "section_id": "6.4",
      "section_title": "Keywords",
      "content": "The operation of the Keyword processor is controlled by the set of parameters defined by a Keyword Dictionary that is uniquely defined (within a CLC) by the value of the Keyword Dictionary ID (KD-ID) specified in the CH.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.4.1",
      "section_id": "6.4.1",
      "section_title": "Dictionaries",
      "content": "A Keyword Dictionary specifies the following items:\n1)\tCharacter Set ID\nThis is the character set in which the dictionary is composed and shall therefore be equal to the character set to be used for compression as specified in the CH.\n2)\tMatch Options\nThis is a collection of bit flags that control how text in the input stream is to be matched against key word dictionary entries. These are described in the table below in which Bit 0 is considered to be the lease significant bit of the Match Options value.\nTable 16: Match options\nBit\nDescription\n0\nIf set, input stream text shall exactly match the dictionary entry.\n1\nIf set, input stream text may match the lower case conversion of a dictionary entry.\n2\nIf set, input stream text may match the upper case conversion of a dictionary entry.\n3\nIf set, input stream text may match the upper case conversion of the 1st character of a dictionary entry followed by the lower case conversion of the remaining characters of the dictionary entry.\n4\nIf set, input stream text may match a dictionary entry prefixed by the keyword prefix characters (if any) described below.\n5\nIf set, input stream text may match a dictionary entry suffixed by the keyword suffix characters (if any) described below.\n6\nIf set, input stream text may match a part of a dictionary entry. A partial match occurs when, a dictionary entry contains n characters and a match is found with the first m characters where m is less than n.\n7-\nAll other bits are reserved.\n3)\tKeyword Prefix\nThe 1st octet is the Keyword Prefix Length which specifies the number of characters that form the prefix string. The length octet is followed by the actual characters of the prefix string.\n4)\tKeyword Suffix\nThe 1st octet is the Keyword Suffix Length which specifies the number of characters that form the suffix string. The length octet is followed by the actual characters of the suffix string.\n5)\tKeyword Threshold\nThis value determines the minimum number of characters in the input stream that needs to be replaced by a full match with a keyword entry. For a partial match the value of the threshold needs to be incremented by 2.\nIf a match occurs involving fewer characters than that specified by the threshold, keyword substitution does not take place.\n6)\tMaximum Partial Match Length\nThis value determines the maximum number of characters in the input stream that needs to be replaced by a partial match with a keyword entry.\nIf a partial match occurs involving fewer characters than that specified by this value, keyword substitution does not take place.\n7)\tKey Word Group List\nThe actual key word dictionary entries are not directly specified within the Keyword Dictionary. Instead, a set of key word dictionary entries is explicitly identified by a Key Word Group ID - an octet value that is unique within the language specified by the CLC. This approach allows the same set of keyword dictionary entries to be used in conjunction with different values for the parameters specified within the Keyword Dictionary and for Keyword Dictionaries to be defined that combine multiple Key Word Groups.\nThe 1st octet of the Key Word Group List specifies the number of Key Word Group IDs that follow, each of the following octets specifies a Key Word Group ID.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_16"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.4.2",
      "section_id": "6.4.2",
      "section_title": "Groups",
      "content": "A Keyword Group specifies the following items:\n1)\tCharacter Set ID\nThis is the character set in which the keyword dictionary entries are composed and shall therefore be equal to the character set to be used for compression as specified in the CH.\n2)\tNumber of Entries\nThe value specifies the number of keyword dictionary entries contained in the Keyword Group.\n3)\tKeyword Entry\nThe 1st octet is the Keyword Entry Length which specifies the number of characters that form the keyword entry string. The length octet is followed by the actual characters of the entry string.\nThe sequence of entries within a dictionary needs to be known by both coder and decoder. Thus keyword entries in a Keyword Group needs to be sorted in ascending sequence of the actual characters of the entry string. Furthermore if a dictionary defines multiple Keyword Groups, the combined set of entries needs to be resorted as part of initialization of the Keyword processor so that the ascending alphanumeric sequence of entries is achieved for all entries in the combined set.\nA further requirement is that all entries in the combined set shall be unique.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.4.3",
      "section_id": "6.4.3",
      "section_title": "Matches",
      "content": "A Keyword Match specifies how a sequence of characters in the input stream is represented by a keyword dictionary entry. A Keyword Match is a bit stream that is interpreted left to right as described on the table below wherein Bit 0 refers to the most significant, left most bit.\nTable 17:\nBits\nDescription\n0 to N1\nCase conversion.\nIf bit 0 of the Dictionary Match Options is set (i.e. Exact matching is enabled), the Case conversion bits are omitted and the Keyword Match starts with the Keyword Entry ID described below.\nOtherwise, if the match involves a lower case conversion, a single Case conversion bit with value 0 is used.\nOtherwise, 2 case conversion bits are used with the following value:\n10\tUpper Case.\n11\t1st character Upper case, remainder Lower case.\nN1+1 to N2\nKeyword Entry ID.\nThis value represents the position in the list of keyword dictionary entries of the entry with which a match has been found. A value of 0 indicates the first entry.\nThe number of bits used to express the Keyword Entry ID is minimum number of bits required to represent the total number of keyword dictionary entries defined for the Keyword Dictionary minus 1.\nN2+1 to N3\nPrefix Match.\nIf bit 4 of the Dictionary Match Options is set (i.e. Prefix matching is enabled), a single bit is used to indicate whether a prefix match applies (1) or not (0).\nIf prefix matching is not enabled, this bit is omitted from the Keyword Match.\nN3+1 to N4\nPartial Match.\nIf bit 6 of the Dictionary Match Options is set (i.e. Partial matching is enabled), a single bit is used to indicate whether a partial match has occurred (1) or not (0).\nIf partial matching is not enabled, this bit is omitted from the Keyword Match.\nIf partial matching is enabled and a full match has occurred, no further bits are required to describe the match.\nIf partial matching is enabled and a partial match has occurred, it is necessary to encode the length of the partial match as follows:\nThe partial match length equals the total number of characters in the input stream represented by the Keyword Match (excluding any characters represented by any prefix and suffix matches) less the value of the partial match threshold (i.e. Keyword Threshold +2).\nIf the partial match length is less than 8 a single bit (0) is added to the bit stream to indicate this fact followed by 3 bits containing the partial match length.\nOtherwise a single bit (1) is added to the bit stream to indicate that more than 3 bits follow containing the partial match length. In this case the number of bits used to represent the partial match length is the minimum number of bits required to represent the value (Maximum Partial Match Length - (Keyword Threshold +2))\nN4+1 to N5\nSuffix Match.\nIf bit 5 of the Dictionary Match Options is set (i.e. Suffix matching is enabled), a single bit is used to indicate whether a suffix match applies (1) or not (0).\nIf suffix matching is not enabled, this bit is omitted from the Keyword Match.",
      "chunk_type": "general",
      "cross_references": [
        "table_17"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.4.4",
      "section_id": "6.4.4",
      "section_title": "Initialization",
      "content": "Initialization of the Keyword processor involves loading the various parameters specified by the KD-ID contained in the CH.\nAs noted above, if the dictionary is composed on more than 1 Keyword Group, the combined set of keyword entries needs to be resorted so that the full set conforms to an ascending alphanumeric sequence.\nClearly,as it is the total combined and sorted set of keyword entries that is required, implementors may choose to construct this from the component keyword groups at run time or to produce such a combination and use it directly as indicated by the constituent keyword group ID’s.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.4.5",
      "section_id": "6.4.5",
      "section_title": "Compression",
      "content": "For compression, the Keyword processor operates as follows:\nTable 18: compression Keyword processor\nInput\nA offset into the input stream of characters from which a matching keyword is to be found.\nStep 1\nSet the current character position to the input offset.\nStep 2\nIf Prefix matching is not enabled goto Step 3.\nIf the string starting at the current character position exactly matches Keyword Prefix, record this fact and increment the current character position by the length of the prefix string.\nStep 3\nIdentify the Keyword Entry ID and if enabled Case Conversion and Partial Match details for the longest match (i.e. that what whereby the greatest number of characters in the input stream are represented) between a dictionary entry and the string starting at the current character position subject to the following rules:\n1)\tAn exact match shall be greater than or equal to the Keyword Threshold to be considered.\n2)\tA partial match shall be greater than or equal to the Keyword Threshold +2 to be considered.\n3)\tIf more than 1 partial match of equal length is found, the one with the greater Keyword Entry ID is used.\n4)\tIf an exact match and a partial match are found, the length of the partial match shall be at least 2 greater than that of the exact match for it to be used.\n5)\tAlthough the case of more than 1 exact match of equal length being found is not possible as entries are unique, should such a case arise, the one with the greater Keyword Entry ID is used.\nIf the longest match is a partial match with length greater than the Maximum Partial Match Length, the match length is limited to the Maximum Partial Match Length.\nIf no match has been found goto Step 5.\nStep 4\nIf Suffix matching is not enabled goto Step 5.\nIf the string starting at the current character position exactly matches Keyword Prefix, record this fact and increment the current character position by the length of the prefix string.\nStep 5\nIf a matching keyword has been found, construct the Keyword Match bitstream.\nOutput\nA Keyword Match bitstream or an indication that no suitable match is available.",
      "chunk_type": "general",
      "cross_references": [
        "table_18"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.4.6",
      "section_id": "6.4.6",
      "section_title": "Decompression",
      "content": "For decompression, the Keyword processor operates as follows:\nTable 19: decompression Keyword processor\nInput\nA Keyword Match bitstream.\nStep 1\nInterpret the Keyword Match bitstream to determine if there is a Prefix match. If so add the Keyword Prefix string to the string to be output.\nStep 2\nInterpret the Keyword Match bitstream to identify the dictionary entry or part thereof as indicated by any Partial Match details.\nPerform any case conversion (indicated by the Keyword Match bitstream) on the dictionary entry string and add the resulting string to the string to be output.\nStep 3\nInterpret the Keyword Match bitstream to determine if there is a Suffix match. If so add the Keyword Suffix string to the string to be output.\nOutput\nThe character string represented by the input Keyword Match bitstream.",
      "chunk_type": "general",
      "cross_references": [
        "table_19"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.5.1",
      "section_id": "6.5.1",
      "section_title": "Initialization",
      "content": "Initialization of the USC2 processor involves storing the default UCS2 row as specified by the CH.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.5.2",
      "section_id": "6.5.2",
      "section_title": "Compression",
      "content": "For compression, the UCS2 processor operates as follows:\nTable 20:\nInput\nA 16 bit UCS2 character value.\nStep 1\nIf the row octet of the input character is different from the \"current UCS2 row\" store the row octet of the input character as the new \"current UCS2 row\".\nOutput\nA Boolean value indicating whether the current UCS2 row has been changed.",
      "chunk_type": "general",
      "cross_references": [
        "table_20"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.5.3",
      "section_id": "6.5.3",
      "section_title": "Decompression",
      "content": "For decompression, the USC2 processor needs to set and sense the \"current UCS2 row\" as required by the higher level software described in subclause 6.1.2 above.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1.2"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.6",
      "section_id": "6.6",
      "section_title": "Character group processing",
      "content": "The operation of the Character Group processor is controlled by the set of parameters defined by a Character Group that is uniquely defined (within a CLC) by the value of the Character Group ID (CG-ID) specified in the CH.\nCharacter grouping operates by defining 2 or more subsets (groups) of characters within the character set used for compression with the following properties:\n-\tEach sub set contains the same number of characters.\n-\tOne subset (referred to as Group 0 or the \"base group\" contains the characters expected to have higher frequencies in a input stream than those of the characters in other subsets.\n-\tInput stream are expected to contain contiguous sequences of characters belonging to a single group.\nCompression is achieved by assigning a 1:1 mapping between the characters in the base group and those in the other groups and when appropriate signalling a transition between groups and then continuing to encode base group characters. This has the effect of improving the performance of the Huffman encoder by reducing the need to add new characters to the tree and by maintaining a smaller overall tree with a more distinct frequency distribution.\nFor example, assume that we have a character set that comprises just the numeric digits 0 to 9 and the letters A to B and 3 groups containing the digits 1 to 3, 4 to 6 and 0 and 7 to 9. The digits 1 to 3 are considered to be the most frequent and are therefore the base group. The digit 0 is defined to exist in all the groups and the letters A and B do not occur in any group.\nEncoding and decoding of characters is achieved using the various items in table 21.\nTable 21: Encoding and decoding of characters\nItem\nElement\nComment\nValue\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nDecimal character value\nCharacter\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nA\nB\nCharacter symbol\nGroup 0\n1\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\nBit flags for Group 0\nGroup 1\n1\n0\n0\n0\n1\n1\n1\n0\n0\n0\n0\n0\nBit flags for Group 1\nGroup 2\n1\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\nBit flags for Group 2\nFold 0\n0\n1\n2\n3\n1\n2\n3\n1\n2\n3\nA\nB\nGroup 0 Conversions\nFold 1\n0\n4\n5\n6\n4\n5\n6\n7\n8\n9\nA\nB\nGroup 1 Conversions\nFold 2\n0\n7\n8\n9\n4\n5\n6\n7\n8\n9\nA\nB\nGroup 2 Conversions\nThe items Group 0, Group 1 and Group 2 simply enable the determination of whether a given character is a member of the given group by checking the value of the Group x element associated with the value of the character.\nThe elements of the Fold 0 item associated with the members of a given group represent the characters within Group 0 to which the characters of the given group are mapped. For example character 4 in Group 1 is mapped to character 1 in Group 0.\nThe elements of the Fold 1 and Fold 2 items provide the reverse mapping in that the elements associated with membership of Group 0 represent the characters in Groups 1 or 2 that are associated with the Group 0 characters.\nThus if the \"current group\" is Group x, a character with value c can be encoded as follows:\n-\tIf c is a member of Group x or not a member of any group, element c of Fold 0 is output.\n-\tIf c is not a member of Group x it can be output as a \"literal\" which is element c of Fold y where Group y has c as a member alternatively a change of group can be signalled.\nSimilarly, if the \"current group\" is Group x, a character with value c can be decoded as follows:\n-\tIf c is a member of Group x or x is not 0 then, element c of Fold x is output.\n-\tOtherwise the value c is output unchanged.\nThe detailed operation of the Character Group processor (described below) primarily extends these simple rules to optimize the case where a choice between a \"literal\" or a group change arises.",
      "chunk_type": "procedure",
      "cross_references": [
        "table_21"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.6.1",
      "section_id": "6.6.1",
      "section_title": "Character Groups",
      "content": "A Character Group specifies the following items:\n1)\tCharacter Set ID\nThis is the character set in which the character group is composed and shall therefore be equal to the character set to be used for compression as specified in the CH.\n2)\tNumber of Groups\nThis value specifies the number of groups to be defined. The maximum value is 8.\n3)\tGroup Transition Controls\nGroup transitions are signalled through the use of the Character Group Transition symbols in the decimal range 259 to 265.\nIf the Number of Groups is N, (N-1) Character Group Transition symbols shall be specified such that if the \"current group\" is x one Character Group Transition symbol is allocated to signify a transition to each of the other (N-1) groups.\n4)\tFold Tables\nThese are the inter-group character conversion tables described above. One is required for each group defined.\n5)\tGroup Membership\nThis is an array of octets, one for each character in the character set. The 1st octet in the array contains bit flags indicating the group membership of the character value 0 and so on.\nWithin each octet, bit 0 (least significant) indicates membership of Group 0, bit 1 that of Group 1 and so on.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.6.2",
      "section_id": "6.6.2",
      "section_title": "Initialization",
      "content": "Initialization of the Character Group processor involves loading the various parameters specified by the CG-ID contained in the CH.\nAdditionally on initialization, the \"current group\" is assumed to be Group 0.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.6.3",
      "section_id": "6.6.3",
      "section_title": "Compression",
      "content": "For compression, the Character Group processor operates as follows:\nTable 22: compression Character Group processor\nInput\n1)\tA single symbol to be encoded.\n2)\tAn indication that this is the last symbol to be encoded.\nStep 1\nSet the number of output symbols to zero.\nStep 2\nIf the input symbol is not the Keyword symbol, goto Step 3.\nIf a previous input symbol is being held, add this as a \"literal\" to the output sequence by calculating the value of the element indicated by the value of the previous symbol in the fold table associated with the group of the previous symbol and increment the number of output symbols and clear the previous symbol.\nGoto Step 9.\nStep 3\nIf the input symbol is a member of no group or a member of the current group, set the group for the input symbol to be the current group.\nOtherwise, if a previous input symbol is being held and the input symbol is a member of the group of the previous symbol, set the group for the input symbol to be that of the previous symbol.\nOtherwise, test the input symbol for membership of each group in ascending order of groups starting with group 0 and set the group for the input symbol to be that for which membership is first detected.\nStep 4\nIf a previous input symbol is not being held goto Step 5.\nIf the input symbol group equals the previous symbol group:\n-\tAdd the Character Group Transition symbol that indicates a transition from the current group to the previous symbol group to the output sequence and increment the number of output symbols.\n-\tSet the current group to the previous symbol group.\n-\tEncode the previous symbol by calculating the value of the element indicated by the value of the previous symbol in the fold table associated with the base group and add this value to the output sequence and increment the number of output symbols.\n-\tEncode the input symbol by calculating the value of the element indicated by the value of the input symbol in the fold table associated with the base group and add this value to the output sequence and increment the number of output symbols.\n-\tClear the previous symbol.\n-\tGoto Step 9.\nOtherwise, encode the previous symbol as a \"literal\" by calculating the value of the element indicated by the value of the previous symbol in the fold table associated with the group of the previous symbol group and add this value to the output sequence and increment the number of output symbols and clear the previous symbol.\nStep 5\nIf the input symbol group is the base group and the current group is not the base group, add the Character Group Transition symbol that indicates a transition from the current group to the base group to the output sequence and increment the number of output symbols. Set the current group to be the base group.\nStep 6\nIf the input symbol group is the base group or the current group:\n-\tEncode the input symbol by calculating the value of the element indicated by the value of the input symbol in the fold table associated with the base group and add this value to the output sequence and increment the number of output symbols.\n-\tGoto Step 9.\nStep 7\nIf the input symbol is the last symbol to be encoded:\n-\tEncode the input symbol as a \"literal\" by calculating the value of the element indicated by the value of the input symbol in the fold table associated with the  group of the input symbol and add this value to the output sequence and increment the number of output symbols.\n-\tGoto Step 9.\nStep 8\nSet the previous symbol to be the value of the input symbol and set the group for the previous symbol to be that of the input symbol.\nStep 9\nOutput the number of output symbols and the associated symbols.\nOutput\nA count of the number of encoded symbols output and a sequence of encoded symbols.",
      "chunk_type": "general",
      "cross_references": [
        "table_22"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.6.4",
      "section_id": "6.6.4",
      "section_title": "Decompression",
      "content": "For decompression, the Character Group processor operates as follows:\nTable 23: Decompression Character Group processor\nInput\nA single symbol to be decoded.\nStep 1\nIf the symbol is a Character Group Transition symbol, update the \"current group\" to be that indicated by the Character Group Transition.\nGoto Step 3.\nStep 2\nIf the input symbol is a member of the \"current group\" or the \"current group\" is not the base group, calculate the value of the decoded symbol as that given by the element indicated by the value of the input symbol in the fold table associated with the \"current group\".\nOtherwise set the value of the decoded symbol to that of the input symbol.\nStep 3\nIf a decoded symbol has been generated indicate this fact.\nOutput\nThe decoded symbol or an indication that no symbol has been generated.",
      "chunk_type": "general",
      "cross_references": [
        "table_23"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7",
      "section_id": "6.7",
      "section_title": "Huffman coding",
      "content": "As described in subclause 4.2, Huffman encoding requires the set of characters that may be encoded to be represented within a binary tree structure. The tree is constructed of \"nodes\" which have the following properties:\n-\tA Parent node. A node that has no parent is the \"root\" node.\n-\tUp to 2 Child nodes. A node that has no children is a \"leaf\" node.\n-\tCharacter value. If the node is a leaf node it represents a character represented within the tree.\n-\tWeight. If the node is a leaf node, the weight is the frequency with which the associated character has occurred in the input stream. Otherwise the weight is simply the sum of the weights of the nodes children.\nTypically, a tree will be implemented as an array of node structures and parent / child details for a given node will be represented by the index of the appropriate node within the array.\nEvery node in the tree (except the root node or in the case where the tree contains just a single leaf node) has a \"sibling\" - the other node that shares the same parent node.\nFor the binary tree to be a Huffman tree its construction needs to display a further property. This is that the nodes can be listed in ascending order of weight and in so doing every node is adjacent to its sibling in the list. This property needs to be preserved at all times - when the tree is initially created, when a new leaf node is added to the tree to represent a new character and when the frequency of a leaf node is incremented as a new instance of that character is processed.\nThe ordering of nodes is also significant in that it will determine which of the siblings is the \"left-hand\" as opposed to \"right-hand\" of the sibling pair. Encoding a symbol involves navigating the tree from leaf to root and emitting a bit to the encoded stream the value of which depends on whether the current node is the left or right hand sibling. If the node is a left hand node, the bit value is 0 and if it is a right hand node, the bit value is 1. Assuming that the 1st element of the array of nodes has an index value of 0, this means that left hand nodes will have even numbered indices and right hand nodes will have odd numbered indices.\nNode weights are assumed to be 16 bit unsigned values and this means that the potential exists for these values to overflow. To handle this case, the algorithm defines a maximum weight value for the root node. If this is to be exceeded, the weights of all leaf nodes are divided by 2 and the tree is rebuilt. The maximum value for the root weight is defined to be 8000 (hex).\nAlthough the bit sequence representing the encoded symbol is discovered in the order of traversing the tree from leaf to root, for decoding the bit sequence needs to be processed in the order that describes the navigation of the tree from root to leaf. Thus the entire encoding bit sequence needs to be collected in some temporary variable and emitted to the output stream in reverse order. For example if the passage from leaf to root is described by the sequence 010011, the bits added to the output stream would be 110010. The need to collect the bits in a temporary variable also introduces the potential for this value to overflow. Given the maximum value for the root node weight described above, a 32bit variable is suitable of containing all possible bit sequences.\nIf a symbol that does not already exist in the tree is to be encoded, either the \"New 7bit Character\" or the \"New 8bit Character\" is encoded, the lower 7 bits of the new character value are then added literally to the out put stream and the new character needs to be added to the tree. This is done by splitting the \"lightest\" node (the first node in the list ordered by ascending weight) such that it becomes a parent node whose right hand child is the leaf node that was originally represented by the node being split and the left hand child is a new leaf node representing the new character. The new leaf is initially created with a weight of 0 but this is immediately updated as described below.\nIf a new symbol has been added to the tree or a new instance of an existing symbol processed, the weight for the associated leaf node needs to be incremented and the tree updated to preserve the \"sibling\" property.\nThe tree is updated in the following manner. If the node a position x in the ascending weight ordered list has had its weight incremented by 1, the list needs to be scanned from position x in ascending weight order to identify the node at position y such that the node at position (y+1) is the first node encountered that has a weight greater than or equal to the new weight of the node at position x. The nodes at x and y are then \"swapped\" in terms of their position in the list and their parents while maintaining all other attributes. This process of weight increment and swapping is then repeated for the parent of the node at position y until the root node is reached.\nThe operation of the Huffman processor is controlled by the set of parameters defined by a Huffman Initialization that is uniquely defined (within a CLC) by the value of the Huffman Initialization ID (HI-ID) specified in the CH.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.2"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7.1",
      "section_id": "6.7.1",
      "section_title": "Initialization Overview",
      "content": "A Huffman Initialization specifies the following items:\n1)\tCharacter Set ID\nThis is the character set in which the Huffman Initialization is composed and shall therefore be equal to the character set to be used for compression as specified in the CH.\n2)\tOptions\nThis is a collection of bit flags that control how the processor is to operate. These are described in table 24 in which Bit 0 is considered to be the lease significant bit of the Match Options value.\nTable 24: collection of bit flags\nBit\nDescription\n0\nIf set, weights for leaf nodes representing  control symbols (other than New 7 bit character and New 8 bit character symbols) are to be updated.\n1\nIf set, weights for leaf nodes representing control symbols are to be updated.\n2\nAll other bits are reserved.\n3)\tThe Character Group ID with which these initializations may operate.\n4)\tNumber of initial symbol frequencies\n2 values representing the cases where the Character Group processor is enabled or disabled.\nThese are counts of the number of characters or control symbols for which there are following initial frequencies defined.\nAs this initializations will vary significantly depending on whether the Character Group processor is enabled 2 sets of initializations are provided to cover both cases.\n5)\tInitial frequencies\nTwo sets of initialization values are supplied as described above.\nAny control symbol that may occur when processing an input stream needs to be represented within the tree, prior to the first character of the input stream being processed. These symbols shall therefore be handled by the initialization process. This is achieved by :\n-\tThe frequency initialization data will always include all control symbols that might occur for any stream. Thus the New 7bit character, New 8bit character, New UCS2 Row and Keyword symbols will always be included and if the initialization set is that for the case where the specified Character Group ID is enabled, the associated Character Group Transition symbols will also be included.\n-\tFor a given input stream, the frequency initialization process (described in subclause 6.7.2 below) will determine whether a control symbol contained in the frequency initialization data can occur in the input stream based on the information contained in the CH. If it is determined that a control symbol contained in the frequency initialization data can NOT occur in the input stream, this symbol will not be added to the Huffman tree.\nFrequency initialization data comprises the value of the character or symbol and the initial frequency for that symbol.\n-\tThe order in which character or symbol values and their associated initial frequencies are stated is significant and this order must be preserved when these items are loaded as part of the Huffman Initialisation process. Frequency Initialisation data must be stated in ascending order of character or symbol initial frequency.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_6.7.2",
        "table_24"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7.2",
      "section_id": "6.7.2",
      "section_title": "Initialization",
      "content": "Initialization of the Huffman processor involves loading the various parameters specified by the HI-ID contained in the CH.\nThe appropriate set of frequency initialization data is selected depending on whether the Character Group processor is enabled.\nLeaf nodes are created for each symbol for which a frequency initialization is specified, subject to the following rules:\n-\tLeaf nodes must be created within the array of Huffman tree nodes in exactly the same ascending order in which they are stated in the Huffman Initialisation data.\n-\tIf the character set specified for compression is the GSM 7 bit default alphabet, leaf nodes are not created for the New 8bit Character and the New UCS2 Row symbols.\n-\tIf the character set specified for compression is not UCS2 a leaf node is not created for the New UCS2 Row symbol.\n-\tIf the Keyword processor is disabled, no leaf node is created for the Keyword symbol.\nThe initial tree is then built as described below - rescaling is not indicated.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.042_6.7.3",
      "section_id": "6.7.3",
      "section_title": "Build Tree",
      "content": "To build the tree, the Huffman processor operates as follows:\nTable 25: Build Tree, Huffman processor operation\nInput\n1)\tThe array of Huffman tree nodes.\n2)\tA Boolean value indicating whether frequencies need to be rescaled as a result of the root node weight becoming the maximum value.\nStep 1\nAssemble all leaf nodes, preserving their  ascending weight order at the start of the node array. This is achieved by setting the “current node” and “assembled leaf” node position to the base of the array. If the current node is a leaf node, set the symbol and frequency associated with assembled leaf node to those of the current node and increment the assembled leaf node position. Increment the current node position and repeat this process until the current node becomes the root node.\nIf rescaling is requested recalculate each leaf node weight as (current weight+1)/2.\nSet the current node to the start of the array.\nStep 2\nCreate a parent node for the current node and the next node and insert it into the array at position x where the node at position (x+1) is the first node with a weight greater than that of the newly created node.\nIf the newly created node is not the root node, increment the current node by 2 and goto Step 2.\nOutput\nA completed Huffman tree.",
      "chunk_type": "general",
      "cross_references": [
        "table_25"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7.4",
      "section_id": "6.7.4",
      "section_title": "Update Tree",
      "content": "To update the tree, the Huffman processor operates as follows:\nTable 26: Update Tree, Huffman processor operation\nInput\nThe symbol whose frequency is to be incremented by 1.\nStep 1\nIf the weight of the root node +1 is greater than 0 x 8000 build the tree indicating that resealing is required.\nStep 2\nIncrement the weight of the leaf node associated with the input symbol by 1 and \"swap\" it with the node at position y such that the node at position (y+1) is the first node encountered in the order list that has a weight greater than or equal to the new weight of the incremented leaf node.\nRepeat this process of weight increment and \"swap\" for the parent of the node at position y until the node at position y becomes the root node.\nOutput\nAn updated Huffman tree.",
      "chunk_type": "general",
      "cross_references": [
        "table_26"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7.5",
      "section_id": "6.7.5",
      "section_title": "Add New Node",
      "content": "To add a new node, the Huffman processor operates as follows:\nTable 27: Add New Node, Huffman processor operation\nInput\nThe symbol to be added to the tree.\nStep 1\nSplitting the \"lightest\" node (the first node in the list ordered by ascending weight) such that it becomes a parent node whose right hand child is the leaf node that was originally represented by the node being split and the left hand child is a new leaf node representing the new input symbol. The new leaf node is initially created with a weight of 0.\nStep 2\nUpdate the tree (as above) passing the new symbol as the input parameter.\nOutput\nAn updated Huffman tree.",
      "chunk_type": "general",
      "cross_references": [
        "table_27"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7.6",
      "section_id": "6.7.6",
      "section_title": "Compression",
      "content": "For compression, the Huffman processor operates as follows:\nTable 28: Compression, Huffman processor operation\nInput\nA character from the input stream or control symbol.\nStep 1\nIf there is no existing leaf node for the input symbol set the \"source\" symbol to be either the New 7bit or New 8bit symbol depending on the value of the input symbol.\nOtherwise set the source symbol to be the input symbol.\nStep 2\nTraverse the tree from the leaf node associated with the source symbol to the root node while generating the Huffman bit sequence.\nStep 3\nReverse the generated Huffman bit sequence and add it to the output bitstream.\nStep 4\nIf the source symbol equals the input symbol goto Step 5.\nAdd the lower 7 bits of the input symbol to the output bitstream.\nAdd a new node for the input symbol.\nUpdate the tree for the input symbol.\nGoto Output.\nStep 5\nIf the input symbol value is less than 256 and bit 0 of the Huffman Initialization Options value is set, update the tree for the input symbol and goto Output.\nStep 6\nIf the input symbol value is greater than or equal 256 and bit 1 of the Huffman Initialization Options value is set, update the tree for the input symbol.\nOutput\nA Huffman bitstream.",
      "chunk_type": "general",
      "cross_references": [
        "table_28"
      ]
    },
    {
      "chunk_id": "ts_23.042_6.7.7",
      "section_id": "6.7.7",
      "section_title": "Decompression",
      "content": "For decompression, the Huffman processor operates as follows:\nTable 29: Decompression, Huffman processor operation\nInput\nA bit stream.\nStep 1\nTraverse the tree from the root node to a leaf node as indicated by the value of the bits read from the front of the input bitstream.\nStep 2\nIf the symbol associated with the leaf node identified in step 1 is neither the New 7bit nor New 8bit symbol, goto Step 3.\nSet the lower 7 bits of the output symbol to be next 7 bits read from the input bitstream and set bit 7 as indicated.\nAdd a new node for the output symbol.\nUpdate the tree for the output symbol.\nGoto Output.\nStep 3\nSet the output symbol to the symbol associated with the leaf node from Step 1.\nStep 4\nIf the output symbol value is less than 256 and bit 0 of the Huffman Initialization Options value is set, update the tree for the output symbol and goto Output.\nStep 5\nIf the input symbol value is greater than or equal 256 and bit 1 of the Huffman Initialization Options value is set update the tree for the output symbol.\nOutput\nA decoded symbol.",
      "chunk_type": "general",
      "cross_references": [
        "table_29"
      ]
    },
    {
      "chunk_id": "ts_23.042_7",
      "section_id": "7",
      "section_title": "Test Vectors",
      "content": "In order to assist implementors of the compression algorithm described in this specification, a suite of test vectors and ‘help’ information are available in electronic format. The test vectors  are supplied on a single diskette attached to this specification.\nThese test vectors provide checks for most of the commonly expected parameter value variants in this specification and may be updated as the need arises.\nAnnex A (normative):German Language parameters\nA.1\tCompression Language Context\nCLC Value:\t0 (decimal)\nThis specifies the following items as defaults:\n1)\tLanguage\tGerman\n2)\tCharacter set\tCharacter Set ID 3 (decimal) = Code Page 850\n3)\tPunctuator ID\t0 (decimal)\n4)\tKeyword Dictionary ID\t0 (decimal)\n5)\tCharacter Group ID\t1 (decimal)\n6)\tHuffman Initialization ID\t1 (decimal)\nA.2\tPunctuators\nPunctuator ID 0 (decimal)\nThis punctuator ID has the special meaning that no punctuator is defined (or therefore enabled) and the value of bit 2 of octet 1 of the CH is always to be interpreted as zero.\nPunctuator ID 1 (decimal)\nThe punctuator is rendered in Character Set ID 3 (decimal) = Code Page 850.\nThe following characters have punctuator attributes set:\nTable A.1: punctuator attributes set:\nChar\nValue\nPU-IWS\nPU-LST\nPU-WSF\nPU-UCF\nPU-UCW\nPU-NSI\n<LF>\n010\n0\n0\n0\n1\n0\n0\n<CR>\n013\n0\n0\n0\n1\n0\n0\n<SP>\n032\n1\n0\n0\n0\n0\n0\n!\n033\n0\n0\n1\n1\n0\n0\n,\n044\n0\n0\n1\n0\n0\n0\n.\n046\n0\n1\n1\n1\n0\n0\n0\n048\n0\n0\n0\n0\n0\n1\n1\n049\n0\n0\n0\n0\n0\n1\n2\n050\n0\n0\n0\n0\n0\n1\n3\n051\n0\n0\n0\n0\n0\n1\n4\n052\n0\n0\n0\n0\n0\n1\n5\n053\n0\n0\n0\n0\n0\n1\n6\n054\n0\n0\n0\n0\n0\n1\n7\n055\n0\n0\n0\n0\n0\n1\n8\n056\n0\n0\n0\n0\n0\n1\n9\n057\n0\n0\n0\n0\n0\n1\n:\n058\n0\n0\n1\n0\n0\n0\n;\n059\n0\n0\n1\n0\n0\n0\n?\n063\n0\n0\n1\n1\n0\n0\nNOTE:\tThe characters \"<SP>\" are used to represent the \"space\" character, the characters \"<LF>\" the \"line feed\" character and \"<CR>\" the \"carriage return\" character.\nPunctuator ID >1 (decimal)\nNo other punctuators are defined and all other values are reserved.\nA.3\tKeyword Dictionaries\nKeyword Dictionary ID 0 (decimal)\nThis Keyword Dictionary ID has the special meaning that no Keyword Dictionary is defined (or therefore enabled) and the value of bit 1 of octet 1 of the CH is always to be interpreted as zero.\nKeyword Dictionary ID 1 (decimal)\nThe Keyword Dictionary is rendered in Character Set ID 3 (decimal) = Code Page 850.\nThe Match Options value is 94 (decimal) indicating the following:\n-\tPartial matching is enabled.\n-\tSuffix matching is not enabled.\n-\tPrefix matching is enabled.\n-\t1st char upper case, remainder lower case matching is enabled.\n-\tUpper case matching is enabled.\n-\tLower case matching is enabled.\n-\tExact matching is not enabled.\nThe Keyword Prefix Length is 1 and the prefix string contains a single character with value 32 decimal (a space).\nThe Keyword Suffix Length is 0.\nThe Keyword Threshold value is 4.\nThe Maximum Partial Match Length value is 20 (decimal).\nThe Key Word Group List contains only 1 Key Word Group ID. The value of this Key Word Group ID is 0.\nKeyword Dictionary ID >1 (decimal)\nNo other Keyword Dictionaries are defined and all other values are reserved.\nKey Word Group ID 0 (decimal)\nThe entries within this Key Word Group are rendered in Character Set ID 3 (decimal) = Code Page 850.\nThe Number of Entries value is 128 (decimal).\nThe entries are defined in table A.2 wherein the characters \"<SP>\" are used to represent the \"space\" character of decimal value 32.\nTable A.2: Key Word Group ID 0 (decimal)\nEntry ID\nEntry Length\nEntry String\n1\n5\nAbend\n2\n7\nAbholen\n3\n6\nAlles<SP>\n4\n10\nAngekommen\n5\n9\nAngerufen\n6\n7\nAnrufen\n7\n7\nAntwort\n8\n6\nAnzahl\n9\n6\nArbeit\n10\n5\nAuch<SP>\n11\n8\nBekommen\n12\n8\nBescheid\n13\n6\nBesser\n14\n5\nBitte\n15\n7\nBrauche\n16\n5\nDabei\n17\n6\nDamit<SP>\n18\n5\nDanke\n19\n5\nDann<SP>\n20\n8\nDienstag\n21\n5\nDoch<SP>\n22\n10\nDonnerstag\n23\n8\nDringend\n24\n10\nEigentlich\n25\n7\nEinfach\n26\n6\nEinmal\n27\n7\nEmpfang\n28\n7\nEndlich\n29\n11\nErfolgreich\n30\n9\nEröffnung\n31\n8\nErhalten\n32\n10\nErreichbar\n33\n5\nEssen\n34\n6\nEtwas<SP>\n35\n6\nFahren\n36\n10\nFeierabend\n37\n6\nFertig\n38\n7\nFreitag\n39\n6\nFreund\n40\n5\nGegen\n41\n5\nGehen\n42\n5\nGeht_\n43\n6\nGerade\n44\n8\nGespräch\n45\n7\nGestern\n46\n6\nGlaube\n47\n6\nGleich\n48\n6\nGrüsse\n49\n5\nGuten\n50\n5\nHaben\n51\n6\nHallo<SP>\n52\n6\nHeute<SP>\n53\n12\nHoffentlich<SP>\n54\n6\nImmer<SP>\n55\n6\nJetzt<SP>\n56\n6\nKaufen\n57\n6\nKönnen\n58\n5\nKomme\n59\n6\nKonnte\n60\n5\nKonto\n61\n5\nLange\n62\n7\nLangsam\n63\n6\nLassen\n64\n6\nLaufen\n65\n7\nLeider<SP>\n66\n6\nLetzte\n67\n5\nLiebe\n68\n6\nMachen\n69\n5\nMacht\n70\n6\nMelden\n71\n6\nMittag\n72\n8\nMittwoch\n73\n6\nMontag\n74\n6\nMorgen\n75\n7\nNachher\n76\n10\nNachmittag\n77\n9\nNachricht\n78\n5\nNacht\n79\n9\nNatürlich\n80\n5\nNicht\n81\n6\nNummer\n82\n7\nNutzung\n83\n5\nPause\n84\n7\nProblem\n85\n7\nRückruf\n86\n8\nRechnung\n87\n5\nReden\n88\n7\nRichtig\n89\n5\nSagen\n90\n7\nSamstag\n91\n8\nSchlafen\n92\n8\nSchlecht\n93\n7\nSchnell\n94\n6\nSchon<SP>\n95\n5\nSchön\n96\n7\nSchreib\n97\n6\nSchule\n98\n5\nSehen\n99\n6\nSicher\n100\n6\nSofort\n101\n7\nSonntag\n102\n5\nSonst\n103\n6\nSpäter\n104\n6\nStunde\n105\n7\nTelefon\n106\n6\nTermin\n107\n5\nTotal\n108\n7\nTreffen\n109\n7\nTrinken\n110\n10\nUnterwegs<SP>\n111\n6\nurlaub\n112\n9\nVergessen\n113\n7\nVersuch\n114\n11\nVielleicht<SP>\n115\n14\nWahrscheinlich\n116\n5\nWann<SP>\n117\n6\nWarum<SP>\n118\n6\nWegen<SP>\n119\n5\nWenn<SP>\n120\n6\nWerden\n121\n7\nWichtig\n122\n6\nWieder\n123\n8\nWirklich\n124\n6\nWissen\n125\n5\nWoche\n126\n10\nWochenende\n127\n6\nZurück\n128\n8\nZusammen\nKey Word Group ID >0 (decimal)\nNo other Key Word Groups are defined and all other values are reserved.\nA.4\tCharacter Groups\nCharacter Group ID 0 (decimal)\nThis Character Group ID has the special meaning that no Character Group is defined (or therefore enabled) and the value of bit 0 of octet 1 of the CH is always to be interpreted as zero.\nCharacter Group ID 1 (decimal)\nThe Character Group is rendered in Character Set ID 3 (decimal) = Code Page 850.\nThe Number of Groups value is 3.\nThere are 2 Group Transition symbols used these have the decimal values 259 and 260. Their use in signalling transitions between the 3 groups are shown in the table A.3.\nTable A.3: Character Group ID 1 (decimal)\nNew Group\nCurrent Group\n0\n1\n2\n0\n260\n259\n1\n260\n259\n2\n260\n259\nThe fold tables and Group Membership bit flags are set out in the following table A.4.\nTable A.4: fold tables and Group Membership bit flags\nChar\nValue\nGroup 0Fold Table\nGroup 1Fold Table\nGroup 2Fold Table\nGroup 2Member\nGroup 1Member\nGroup 0Member\n<SP>\n032\n032\n032\n032\n1\n1\n1\n!\n033\n033\n033\n033\n1\n1\n1\n\"\n034\n034\n034\n012\n1\n1\n1\n#\n035\n107\n035\n035\n1\n0\n0\n$\n036\n113\n035\n035\n1\n0\n0\n%\n037\n118\n037\n037\n1\n0\n0\n&\n038\n112\n038\n038\n1\n0\n0\n'\n039\n111\n039\n039\n1\n0\n0\n(\n040\n119\n040\n040\n1\n0\n0\n)\n041\n098\n041\n041\n1\n0\n0\n*\n042\n109\n042\n042\n1\n0\n0\n+\n043\n103\n043\n043\n1\n0\n0\n,\n044\n044\n044\n044\n1\n1\n1\n-\n045\n097\n045\n045\n1\n0\n0\n.\n046\n046\n046\n046\n1\n1\n1\n/\n047\n102\n047\n047\n1\n0\n0\n0\n048\n110\n048\n048\n1\n0\n0\n1\n049\n101\n049\n049\n1\n0\n0\n2\n050\n105\n050\n050\n1\n0\n0\n3\n051\n104\n051\n051\n1\n0\n0\n4\n052\n114\n052\n052\n1\n0\n0\n5\n053\n100\n053\n053\n1\n0\n0\n6\n054\n108\n054\n054\n1\n0\n0\n7\n055\n115\n055\n055\n1\n0\n0\n8\n056\n117\n056\n056\n1\n0\n0\n9\n057\n099\n057\n057\n1\n0\n0\n:\n058\n116\n058\n058\n1\n0\n0\n;\n059\n121\n059\n059\n1\n0\n0\n<\n060\n106\n060\n060\n1\n0\n0\n=\n061\n120\n061\n061\n1\n0\n0\n>\n062\n122\n062\n062\n1\n0\n0\n?\n063\n063\n063\n063\n1\n1\n1\nA\n065\n097\n065\n065\n0\n1\n0\nB\n066\n098\n066\n066\n0\n1\n0\nC\n067\n099\n067\n067\n0\n1\n0\nD\n068\n100\n068\n068\n0\n1\n0\nE\n069\n101\n069\n069\n0\n1\n0\nF\n070\n102\n070\n070\n0\n1\n0\nG\n071\n103\n071\n071\n0\n1\n0\nH\n072\n104\n072\n072\n0\n1\n0\nI\n073\n105\n073\n073\n0\n1\n0\nJ\n074\n106\n074\n074\n0\n1\n0\nK\n075\n107\n075\n075\n0\n1\n0\nL\n076\n108\n076\n076\n0\n1\n0\nM\n077\n109\n077\n077\n0\n1\n0\nN\n078\n110\n078\n078\n0\n1\n0\nO\n079\n111\n079\n079\n0\n1\n0\nP\n080\n112\n080\n080\n0\n1\n0\nQ\n081\n113\n081\n081\n0\n1\n0\nR\n082\n114\n082\n082\n0\n1\n0\nS\n083\n115\n083\n083\n0\n1\n0\nT\n084\n116\n084\n084\n0\n1\n0\nU\n085\n117\n085\n085\n0\n1\n0\nV\n086\n118\n086\n086\n0\n1\n0\nW\n087\n119\n087\n087\n0\n1\n0\nX\n088\n120\n088\n088\n0\n1\n0\nY\n089\n121\n089\n089\n0\n1\n0\nZ\n090\n122\n090\n090\n0\n1\n0\na\n097\n097\n065\n045\n0\n0\n1\nb\n098\n098\n066\n041\n0\n0\n1\nc\n099\n099\n067\n057\n0\n0\n1\nd\n100\n100\n068\n053\n0\n0\n1\ne\n101\n101\n069\n049\n0\n0\n1\nf\n102\n102\n070\n047\n0\n0\n1\ng\n103\n103\n071\n043\n0\n0\n1\nh\n104\n104\n072\n051\n0\n0\n1\ni\n105\n105\n073\n050\n0\n0\n1\nj\n106\n106\n074\n060\n0\n0\n1\nk\n107\n107\n075\n035\n0\n0\n1\nl\n108\n108\n076\n054\n0\n0\n1\nm\n109\n109\n077\n042\n0\n0\n1\nn\n110\n110\n078\n048\n0\n0\n1\no\n111\n111\n079\n039\n0\n0\n1\np\n112\n112\n080\n038\n0\n0\n1\nq\n113\n113\n081\n036\n0\n0\n1\nr\n114\n114\n082\n052\n0\n0\n1\ns\n115\n115\n083\n055\n0\n0\n1\nt\n116\n116\n084\n058\n0\n0\n1\nu\n117\n117\n085\n056\n0\n0\n1\nv\n118\n118\n086\n037\n0\n0\n1\nw\n119\n119\n087\n040\n0\n0\n1\nx\n120\n120\n088\n061\n0\n0\n1\ny\n121\n121\n089\n059\n0\n0\n1\nz\n122\n122\n090\n062\n0\n0\n1\nNOTE:\tThe characters \"<SP>\" are used to represent the \"space\" character.\nCharacters with any other value in the range 0 to 255 are not a member of any group and therefore the fold table values will be equal to the character value in all cases.\nCharacter Group ID >1 (decimal)\nNo other Character Groups are defined and all other values are reserved.\nA.5\tHuffman Initializations\nHuffman Initialization ID 0 (decimal)\nThe Huffman Initialization is rendered in Character Set ID 3(decimal) = Code Page 850.\nThe Options value indicates that both character and control symbol updating are enabled.\nAs described is subclause 6.7.1, the tables below include initialization values for all control symbols that might occur in conjunction with the use of this Huffman Initialization. However, initialization values for control symbols that cannot occur for a particular use of this Huffman Initialization are identified as part of the Huffman initialization process and are not added to the Huffman tree as described in subclause 6.7.2.\nThe Character Group ID value is 1.\nCharacter Group Processing is disabled:\nThe number of frequency initializations is 4.\nThe initial frequencies are:\nTable A.5: Character Group Processing is disabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n1\nKeyword\n258\n1\nNew 8bit\n257\n1\nNew 7bit\n256\n1\nCharacter Group Processing is enabled:\nThe number of frequency initializations is 6.\nThe initial frequencies are:\nTable A.6: Character Group Processing is enabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n1\nChange CG1\n260\n1\nChange CG0\n259\n1\nKeyword\n258\n1\nNew 8bit\n257\n1\nNew 7bit\n256\n1\nHuffman Initialization ID 1 (decimal)\nThe Huffman Initialization is rendered in Character Set ID 3 (decimal) = Code Page 850.\nThe Options value indicates that both character and control symbol updating are enabled.\nAs described is subclause 6.7.1, the tables below include initialization values for all control symbols that might occur in conjunction with the use of this Huffman Initialization. However, initialization values for control symbols that cannot occur for a particular use of this Huffman Initialization are identified as part of the Huffman initialization process and are not added to the Huffman tree as described in subclause 6.7.2.\nThe Character Group ID value is 1.\nCharacter Group Processing is disabled:\nThe number of frequency initializations is 32.\nThe initial frequencies are:\nTable A.7: Character Group Processing is disabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n00001\nq\n113\n00001\nx\n120\n00001\ny\n121\n00001\nj\n106\n00001\nv\n118\n00001\np\n112\n00001\nNew 8bit\n257\n00002\nz\n122\n00002\n.\n46\n00003\nk\n107\n00003\nf\n102\n00003\nw\n119\n00003\nKeyword\n258\n00004\nb\n98\n00004\ng\n103\n00004\no\n111\n00005\nm\n109\n00006\nl\n108\n00006\nu\n117\n00007\nc\n99\n00007\nd\n100\n00007\nNew 7bit\n256\n00009\nr\n114\n00009\nt\n116\n00009\ns\n115\n00010\nh\n104\n00010\na\n97\n00012\ni\n105\n00013\nn\n110\n00014\ne\n101\n00021\n<SP>\n32\n00032\nNOTE:\tIn the above table, the characters \"<SP>\" are used to represent the \"space\" character.\nCharacter Group Processing is enabled:\nThe number of frequency initializations is 34.\nThe initial frequencies are:\nTable A.8: Character Group Processing is enabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n00001\nq\n113\n00001\nx\n120\n00001\ny\n121\n00001\nj\n106\n00001\nv\n118\n00001\np\n112\n00001\nNew 8bit\n257\n00002\nz\n122\n00002\nChange CG0\n259\n00002\n.\n46\n00003\nk\n107\n00003\nf\n102\n00003\nw\n119\n00003\nKeyword\n258\n00004\nChange CG1\n260\n00004\nb\n98\n00004\ng\n103\n00004\no\n111\n00005\nm\n109\n00006\nl\n108\n00006\nu\n117\n00007\nc\n99\n00007\nd\n100\n00007\nNew 7bit\n256\n00009\nr\n114\n00009\nt\n116\n00009\ns\n115\n00010\nh\n104\n00010\na\n97\n00012\ni\n105\n00013\nn\n110\n00014\ne\n101\n00021\n<SP>\n32\n00032\nNote in the above table, the characters \"<SP>\" are used to represent the \"space\" character.\nHuffman Initialization ID >1 (decimal)\nNo other Huffman Initializations are defined and all other values are reserved.\nAnnex B (normative):English language parameters\nB.1\tCompression Language Context\nCLC Value:\t1 (decimal)\nThis specifies the following items as defaults:\n1)\tLanguage\tEnglish\n2)\tCharacter set\tCharacter Set ID 2 (decimal) = Code page 437\n3)\tPunctuator ID\t1 (decimal)\n4)\tKeyword Dictionary ID\t0 (decimal)\n5)\tCharacter Group ID\t1 (decimal)\n6)\tHuffman Initialization ID\t1 (decimal)\nB.2\tPunctuators\nPunctuator ID 0 (decimal)\nThis punctuator ID has the special meaning that no punctuator is defined (or therefore enabled) and the value of bit 2 of octet 1 of the CH is always to be interpreted as zero.\nPunctuator ID 1 (decimal)\nThe punctuator is rendered in Character Set ID 2 (decimal) = Code Page 437.\nThe following characters have punctuator attributes set:\nTable B.1: punctuator attributes set:\nChar\nValue\nPU-IWS\nPU-LST\nPU-WSF\nPU-UCF\nPU-UCW\nPU-NSI\n<LF>\n010\n0\n0\n0\n1\n0\n0\n<CR>\n013\n0\n0\n0\n1\n0\n0\n<SP>\n032\n1\n0\n0\n0\n0\n0\n!\n033\n0\n0\n1\n1\n0\n0\n,\n044\n0\n0\n1\n0\n0\n0\n.\n046\n0\n1\n1\n1\n0\n0\n0\n048\n0\n0\n0\n0\n0\n1\n1\n049\n0\n0\n0\n0\n0\n1\n2\n050\n0\n0\n0\n0\n0\n1\n3\n051\n0\n0\n0\n0\n0\n1\n4\n052\n0\n0\n0\n0\n0\n1\n5\n053\n0\n0\n0\n0\n0\n1\n6\n054\n0\n0\n0\n0\n0\n1\n7\n055\n0\n0\n0\n0\n0\n1\n8\n056\n0\n0\n0\n0\n0\n1\n9\n057\n0\n0\n0\n0\n0\n1\n:\n058\n0\n0\n1\n0\n0\n0\n;\n059\n0\n0\n1\n0\n0\n0\n?\n063\n0\n0\n1\n1\n0\n0\nI\n073\n0\n0\n0\n0\n1\n0\nNOTE:\tThe characters \"<SP>\" are used to represent the \"space\" character, the characters \"<LF>\" the \"line feed\" character and \"<CR>\" the \"carriage return\" character.\nPunctuator ID >1 (decimal)\nNo other punctuators are defined and all other values are reserved.\nB.3\tKeyword Dictionaries\nKeyword Dictionary ID 0 (decimal)\nThis Keyword Dictionary ID has the special meaning that no Keyword Dictionary is defined (or therefore enabled) and the value of bit 1 of octet 1 of the CH is always to be interpreted as zero.\nKeyword Dictionary ID 1 (decimal)\nThe Keyword Dictionary is rendered in Character Set ID 2 (decimal) = Code Page 437.\nThe Match Options value is 94 (decimal) indicating the following:\n-\tPartial matching is enabled.\n-\tSuffix matching is not enabled.\n-\tPrefix matching is enabled.\n-\t1st char upper case, remainder lower case matching is enabled.\n-\tUpper case matching is enabled.\n-\tLower case matching is enabled.\n-\tExact matching is not enabled.\nThe Keyword Prefix Length is 1 and the prefix string contains a single character with value 32 decimal (a space).\nThe Keyword Suffix Length is 0.\nThe Keyword Threshold value is 4.\nThe Maximum Partial Match Length value is 46 (decimal).\nThe Key Word Group List contains only 1 Key Word Group ID. The value of this Key Word Group ID is 0.\nKeyword Dictionary ID >1 (decimal)\nNo other Keyword Dictionaries are defined and all other values are reserved.\nKey Word Group ID 0 (decimal)\nThe entries within this Key Word Group are rendered in Character Set ID 2 (decimal) = Code Page 437.\nThe Number of Entries value is 128 (decimal).\nThe entries are defined in table B.2wherein the characters \"<SP>\" are used to represent the \"space\" character of decimal value 32.\nTable B.2: Key Word Group ID 0 (decimal)\nEntry ID\nEntry Length\nEntry String\n1\n5\nAbout\n2\n9\nAfternoon\n3\n5\nAgain\n4\n6\nAgenda\n5\n6\nAgreed\n6\n4\nAnd<SP>\n7\n11\nAppointment\n8\n4\nAre<SP>\n9\n7\nArrange\n10\n6\nArrive\n11\n6\nAttend\n12\n9\nAvailable\n13\n4\nAway\n14\n7\nBecause\n15\n6\nBefore\n16\n7\nBenefit\n17\n8\nBusiness\n18\n4\nBut<SP>\n19\n4\nCall\n20\n6\nCan't<SP>\n21\n6\nCancel\n22\n6\nCommit\n23\n7\nCompany\n24\n8\nComplete\n25\n7\nConfirm\n26\n7\nContact\n27\n10\nConvenient\n28\n5\nCould\n29\n7\nDeliver\n30\n6\nDemand\n31\n10\nDepartment\n32\n6\nDinner\n33\n7\nDiscuss\n34\n6\nDon't<SP>\n35\n5\nExist\n36\n6\nFlight\n37\n4\nFor<SP>\n38\n7\nForward\n39\n6\nFriday\n40\n5\nFrom<SP>\n41\n5\nGoing\n42\n7\nGoodbye\n43\n8\nHardware\n44\n5\nHave<SP>\n45\n4\nHear\n46\n5\nHello\n47\n4\nHelp\n48\n4\nHome\n49\n5\nHotel\n50\n4\nHow<SP>\n51\n9\nImmediate\n52\n9\nImportant\n53\n11\nInformation\n54\n4\nIts<SP>\n55\n5\nLater\n56\n6\nLetter\n57\n7\nMachine\n58\n5\nMake<SP>\n59\n6\nManage\n60\n7\nMeeting\n61\n7\nMessage\n62\n6\nMobile\n63\n6\nMonday\n64\n7\nMorning\n65\n5\nNeed<SP>\n66\n6\nOffice\n67\n5\nOther\n68\n6\nPassed\n69\n8\nPersonal\n70\n5\nPhone\n71\n6\nPlease\n72\n8\nPossible\n73\n4\nPost\n74\n8\nPostpone\n75\n5\nPrice\n76\n8\nPriority\n77\n7\nProduct\n78\n7\nProject\n79\n5\nQuick\n80\n7\nReceive\n81\n9\nReference\n82\n7\nRegards\n83\n8\nRemember\n84\n6\nReturn\n85\n4\nRing\n86\n8\nSaturday\n87\n4\nSend\n88\n7\nService\n89\n6\nShould\n90\n5\nSince\n91\n8\nSoftware\n92\n4\nSoon\n93\n5\nSpeak\n94\n5\nStill\n95\n7\nSubject\n96\n7\nSuccess\n97\n6\nSunday\n98\n4\nTalk\n99\n9\nTelephone\n100\n5\nThank\n101\n4\nThat\n102\n4\nThe<SP>\n103\n5\nThem<SP>\n104\n5\nThere\n105\n5\nThey<SP>\n106\n5\nThink\n107\n4\nThis\n108\n8\nThursday\n109\n5\nToday\n110\n8\nTomorrow\n111\n7\nTonight\n112\n5\nTotal\n113\n6\nTravel\n114\n7\nTuesday\n115\n6\nUntil<SP>\n116\n6\nUpdate\n117\n6\nUrgent\n118\n5\nUsing\n119\n4\nWant\n120\n9\nWednesday\n121\n7\nWeekend\n122\n7\nWelcome\n123\n5\nWhen<SP>\n124\n6\nWhere<SP>\n125\n4\nWill\n126\n5\nWould\n127\n9\nYesterday\n128\n4\nYou<SP>\nKey Word Group ID >0 (decimal)\nNo other Key Word Groups are defined and all other values are reserved.\nB.4\tCharacter Groups\nCharacter Group ID 0 (decimal)\nThis Character Group ID has the special meaning that no Character Group is defined (or therefore enabled) and the value of bit 0 of octet 1 of the CH is always to be interpreted as zero.\nCharacter Group ID 1 (decimal)\nThe Character Group is rendered in Character Set ID 2 (decimal) = Code Page 437.\nThe Number of Groups value is 3.\nThere are 2 Group Transition symbols used these have the decimal values 259 and 260. Their use in signalling transitions between the 3 groups are shown in the table B.3.\nTable B.3: Character Group ID 1 (decimal)\nNew Group\nCurrent Group\n0\n1\n2\n0\n260\n259\n1\n260\n259\n2\n260\n259\nThe fold tables and Group Membership bit flags are set out in the following table B.4.\nTable B.4: fold tables and Group Membership bit flags\nChar\nValue\nGroup 0Fold Table\nGroup 1Fold Table\nGroup 2Fold Table\nGroup 2Member\nGroup 1Member\nGroup 0Member\n012\n034\n012\n012\n1\n0\n0\n<SP>\n032\n032\n032\n032\n1\n1\n1\n!\n033\n118\n033\n033\n1\n0\n0\n\"\n034\n034\n034\n012\n0\n1\n1\n#\n035\n102\n035\n035\n1\n0\n0\n%\n037\n113\n037\n037\n1\n0\n0\n&\n038\n111\n038\n038\n1\n0\n0\n'\n039\n039\n039\n039\n1\n1\n1\n(\n040\n116\n040\n040\n1\n0\n0\n)\n041\n117\n041\n041\n1\n0\n0\n*\n042\n110\n042\n042\n1\n0\n0\n+\n043\n119\n043\n043\n1\n0\n0\n,\n044\n044\n044\n062\n0\n1\n1\n-\n045\n120\n045\n045\n1\n0\n0\n.\n046\n046\n046\n046\n1\n1\n1\n/\n047\n114\n047\n047\n1\n0\n0\n0\n048\n101\n048\n048\n1\n0\n0\n1\n049\n097\n049\n049\n1\n0\n0\n2\n050\n105\n050\n050\n1\n0\n0\n3\n051\n099\n051\n051\n1\n0\n0\n4\n052\n112\n052\n052\n1\n0\n0\n5\n053\n100\n053\n053\n1\n0\n0\n6\n054\n107\n054\n054\n1\n0\n0\n7\n055\n104\n055\n055\n1\n0\n0\n8\n056\n103\n056\n056\n1\n0\n0\n9\n057\n109\n057\n057\n1\n0\n0\n:\n058\n098\n058\n058\n1\n0\n0\n;\n059\n106\n059\n059\n1\n0\n0\n<\n060\n122\n060\n060\n1\n0\n0\n=\n061\n121\n061\n061\n1\n0\n0\n>\n062\n044\n062\n062\n1\n0\n0\n?\n063\n063\n063\n093\n0\n1\n1\nA\n065\n097\n065\n065\n0\n1\n0\nB\n066\n098\n066\n066\n0\n1\n0\nC\n067\n099\n067\n067\n0\n1\n0\nD\n068\n100\n068\n068\n0\n1\n0\nE\n069\n101\n069\n069\n0\n1\n0\nF\n070\n102\n070\n070\n0\n1\n0\nG\n071\n103\n071\n071\n0\n1\n0\nH\n072\n104\n072\n072\n0\n1\n0\nI\n073\n105\n073\n073\n0\n1\n0\nJ\n074\n106\n074\n074\n0\n1\n0\nK\n075\n107\n075\n075\n0\n1\n0\nL\n076\n108\n076\n076\n0\n1\n0\nM\n077\n109\n077\n077\n0\n1\n0\nN\n078\n110\n078\n078\n0\n1\n0\nO\n079\n111\n079\n079\n0\n1\n0\nP\n080\n112\n080\n080\n0\n1\n0\nQ\n081\n113\n081\n081\n0\n1\n0\nR\n082\n114\n082\n082\n0\n1\n0\nS\n083\n115\n083\n083\n0\n1\n0\nT\n084\n116\n084\n084\n0\n1\n0\nU\n085\n117\n085\n085\n0\n1\n0\nV\n086\n118\n086\n086\n0\n1\n0\nW\n087\n119\n087\n087\n0\n1\n0\nX\n088\n120\n088\n088\n0\n1\n0\nY\n089\n121\n089\n089\n0\n1\n0\nZ\n090\n122\n090\n090\n0\n1\n0\n[\n091\n108\n091\n091\n1\n0\n0\n]\n093\n063\n093\n093\n1\n0\n0\na\n097\n097\n065\n049\n0\n0\n1\nb\n098\n098\n066\n058\n0\n0\n1\nc\n099\n099\n067\n051\n0\n0\n1\nd\n100\n100\n068\n053\n0\n0\n1\ne\n101\n101\n069\n048\n0\n0\n1\nf\n102\n102\n070\n035\n0\n0\n1\ng\n103\n103\n071\n056\n0\n0\n1\nh\n104\n104\n072\n055\n0\n0\n1\ni\n105\n105\n073\n050\n0\n0\n1\nj\n106\n106\n074\n059\n0\n0\n1\nk\n107\n107\n075\n054\n0\n0\n1\nl\n108\n108\n076\n091\n0\n0\n1\nm\n109\n109\n077\n057\n0\n0\n1\nn\n110\n110\n078\n042\n0\n0\n1\no\n111\n111\n079\n038\n0\n0\n1\np\n112\n112\n080\n052\n0\n0\n1\nq\n113\n113\n081\n037\n0\n0\n1\nr\n114\n114\n082\n047\n0\n0\n1\ns\n115\n115\n083\n156\n0\n0\n1\nt\n116\n116\n084\n040\n0\n0\n1\nu\n117\n117\n085\n041\n0\n0\n1\nv\n118\n118\n086\n033\n0\n0\n1\nw\n119\n119\n087\n043\n0\n0\n1\nx\n120\n120\n088\n045\n0\n0\n1\ny\n121\n121\n089\n061\n0\n0\n1\nz\n122\n122\n090\n060\n0\n0\n1\n£\n156\n115\n156\n156\n1\n0\n0\nNOTE:\tThe characters \"<SP>\" are used to represent the \"space\" character.\nCharacters with any other value in the range 0 to 255 are not a member of any group and therefore the fold table values will be equal to the character value in all cases.\nCharacter Group ID >1 (decimal)\nNo other Character Groups are defined and all other values are reserved.\nB.5\tHuffman Initializations\nHuffman Initialization ID 0 (decimal)\nThe Huffman Initialization is rendered in Character Set ID 2 (decimal) = Code Page 437.\nThe Options value indicates that both character and control symbol updating are enabled.\nAs described is subclause 6.7.1, the tables below include initialization values for all control symbols that might occur in conjunction with the use of this Huffman Initialization. However, initialization values for control symbols that cannot occur for a particular use of this Huffman Initialization are identified as part of the Huffman initialization process and are not added to the Huffman tree as described in subclause 6.7.2.\nThe Character Group ID value is 1.\nCharacter Group Processing is disabled:\nThe number of frequency initializations is 4.\nThe initial frequencies are:\nTable B.5: Character Group Processing is disabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n1\nKeyword\n258\n1\nNew 8bit\n257\n1\nNew 7bit\n256\n1\nCharacter Group Processing is enabled:\nThe number of frequency initializations is 6.\nThe initial frequencies are:\nTable B.6: Character Group Processing is enabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n1\nChange CG1\n260\n1\nChange CG0\n259\n1\nKeyword\n258\n1\nNew 8bit\n257\n1\nNew 7bit\n256\n1\nHuffman Initialization ID 1 (decimal)\nThe Huffman Initialization is rendered in Character Set ID 2 (decimal) = Code Page 437.\nThe Options value indicates that both character and control symbol updating are enabled.\nAs described is subclause 6.7.1, the tables below include initialization values for all control symbols that might occur in conjunction with the use of this Huffman Initialization. However, initialization values for control symbols that cannot occur for a particular use of this Huffman Initialization are identified as part of the Huffman initialization process and are not added to the Huffman tree as described in subclause 6.7.2.\nThe Character Group ID value is 1.\nCharacter Group Processing is disabled:\nThe number of frequency initializations is 32.\nThe initial frequencies are:\nTable B.7: Character Group Processing is disabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n00001\nz\n122\n00001\nKeyword\n258\n00001\nq\n113\n00001\nj\n106\n00003\nx\n120\n00003\nNew 7bit\n256\n00003\nNew 8bit\n257\n00003\nv\n118\n00008\nw\n119\n00010\nb\n098\n00010\ny\n121\n00011\nf\n102\n00011\nu\n117\n00012\n.\n046\n00014\nm\n109\n00016\ng\n103\n00017\nk\n107\n00017\nh\n104\n00018\nd\n100\n00024\np\n112\n00029\nc\n099\n00029\ni\n105\n00030\nr\n114\n00038\nl\n108\n00038\ns\n115\n00040\nn\n110\n00048\nt\n116\n00050\no\n111\n00055\n<SP>\n032\n00060\na\n097\n00066\ne\n101\n00079\nNOTE:\tIn the above table, the characters \"<SP>\" are used to represent the \"space\" character.\nCharacter Group Processing is enabled:\nThe number of frequency initializations is 34.\nThe initial frequencies are:\nTable B.8: Character Group Processing is enabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n00001\nChange CG1\n260\n00001\nz\n122\n00001\nKeyword\n258\n00001\nq\n113\n00002\nj\n106\n00003\nx\n120\n00003\nNew 7bit\n256\n00003\nNew 8bit\n257\n00003\nv\n118\n00008\nw\n119\n00010\nb\n098\n00010\nChange CG0\n259\n00010\ny\n121\n00011\nf\n102\n00013\nu\n117\n00013\n.\n046\n00015\nm\n109\n00017\ng\n103\n00017\nk\n107\n00019\nh\n104\n00020\nd\n100\n00026\np\n112\n00030\nc\n099\n00030\ni\n105\n00031\nr\n114\n00040\nl\n108\n00040\ns\n115\n00045\nn\n110\n00050\nt\n116\n00053\no\n111\n00054\n<SP>\n032\n00058\na\n097\n00064\ne\n101\n00077\nNote in the above table, the characters \"<SP>\" are used to represent the \"space\" character.\nHuffman Initialization ID >1 (decimal)\nNo other Huffman Initializations are defined and all other values are reserved.\nAnnex C (normative):Italian Language parameters\nAnnex under development\nAnnex D (normative):French Language parameters\nAnnex under development\nAnnex E (normative):Spanish Language parameters\nAnnex under development\nAnnex F (normative):Dutch Language parameters\nAnnex under development\nAnnex G (normative):Swedish Language parameters\nAnnex under development\nAnnex H (normative):Danish Language parameters\nAnnex under development\nAnnex J (normative):Portuguese Language parameters\nAnnex under development\nAnnex K (normative):Finnish Language parameters\nAnnex under development\nAnnex L (normative):Norwegian Language parameters\nAnnex under development\nAnnex M (normative):Greek Language parameters\nAnnex under development\nAnnex N (normative):Turkish Language parameters\nAnnex under development\nAnnex P (normative):Reserved\nAnnex under development\nAnnex Q (normative):Reserved\nAnnex under development\nAnnex R (normative):Default Parameters for Unspecified Language\nR.1\tCompression Language Context\nCLC Value:\t 15 (decimal)\nThis specifies the following items as defaults:\n1)\tLanguage\tUnspecified\n2)\tCharacter set \tCharacter Set ID 1 (decimal) = 3GPP TS 23.038 [1] GSM 7 bitdefault alphabet\n3)\tPunctuator ID\t0 (decimal)\n4)\tKeyword Dictionary ID\t0 (decimal)\n5)\tCharacter Group ID\t0 (decimal)\n6)\tHuffman Initialization ID\t0 (decimal)\nR.2\tPunctuators\nPunctuator ID 0 (decimal)\nThis punctuator ID has the special meaning that no punctuator is defined (or therefore enabled) and the value of bit 2 of octet 1 of the CH is always to be interpreted as zero.\nPunctuator ID >0 (decimal)\nNo other punctuators are defined and all other values are reserved.\nR.3\tKeyword Dictionaries\nKeyword Dictionary ID 0 (decimal)\nThis Keyword Dictionary ID has the special meaning that no Keyword Dictionary is defined (or therefore enabled) and the value of bit 1 of octet 1 of the CH is always to be interpreted as zero.\nKeyword Dictionary ID >0 (decimal)\nNo other Keyword Dictionaries are defined and all other values are reserved.\nR.4\tCharacter Groups\nCharacter Group ID 0 (decimal)\nThis Character Group ID has the special meaning that no Character Group is defined (or therefore enabled) and the value of bit 0 of octet 1 of the CH is always to be interpreted as zero.\nCharacter Group ID >0 (decimal)\nNo other Character Groups are defined and all other values are reserved.\nR.5\tHuffman Initializations\nHuffman Initialization ID 0 (decimal)\nOnly control symbols are included in this initialization. It's rendition is therefore independent of character set.\nThe Options value indicates that both character and control symbol updating are enabled.\nAs described is subclause 6.7.1, the tables below include initialization values for all control symbols that might occur in conjunction with the use of this Huffman Initialization. However, initialization values for control symbols that cannot occur for a particular use of this Huffman Initialization are identified as part of the Huffman initialization process and are not added to the Huffman tree as described in subclause 6.7.2.\nCharacter Group Processing is always disabled:\nThe number of frequency initializations is 4.\nThe initial frequencies are:\nTable R.1: Character Group Processing is always disabled: initial frequencies\nSymbol\nValue\nFrequency\nNew UCS2 Row\n266\n1\nKeyword\n258\n1\nNew 8bit\n257\n1\nNew 7bit\n256\n1\nCharacter Group Processing can not be enabled therefore:\nThe number of frequency initializations is 0.\nHuffman Initialization ID >0 (decimal)\nNo other Huffman Initializations are defined and all other values are reserved.\nAnnex S (informative):Change history\nTSG#\nTDoc\nVERS\nNEW_VERS\nCR\nREV\nREL\nCAT\nWORKITEM\nSUBJECT\nT#4\n3.0.0\nNew\nCreation of 3GPP 23.042 out of GSM 03.42 v.7.1.0\nT#6\nTP-99237\n3.0.0\n3.1.0\n001\nR99\nF\nTEI\nAdaptations for UMTS\nT#11\n-\n3.1.0\n4.0.0\n-\nRel-4\nUpgrade to Rel-4\n4.0.0\n4.0.1\nRel-4\n2001-10: Replacement of erroneous R99 test vector file by correct Rel-4 one.\nT#16\n-\n4.0.1\n5.0.0\n-\nRel-5\nUpgrade to Rel-5\nT#26\n-\n5.0.0\n6.0.0\n-\nRel-6\nUpgrade to Rel-6\n6.0.0\n7.0.0\nRel-7\nUpgrade to Rel-7\n7.0.0\n8.0.0\nRel-8\nUpgrade to Rel-8\n8.0.0\n9.0.0\nRel-9\nUpgrade to Rel-9\n9.0.0\n10.0.0\nRel-10\nUpgrade to Rel-10\n10.0.0\n11.0.0\nRel-11\nUpgrade to Rel-11\n11.0.0\n12.0.0\nRel-12\nUpgrade to Rel-12\n12.0.0\n13.0.0\nRel-13\nUpgrade to Rel-13\nChange history\nDate\nMeeting\nTDoc\nCR\nRev\nCat\nSubject/Comment\nNew version\n2017-03\nCT-75\n-\n-\n-\nUpdate to Rel-14 version (MCC)\n14.0.0\n2018-06\nSA-80\n-\n-\n-\n-\nUpdate to Rel-15 version (MCC)\n15.0.0\n2020-07\nSA-88e\n-\n-\n-\n-\nUpdate to Rel-16 version (MCC)\n16.0.0\n2022-03\nSA-95e\n-\n-\n-\n-\nUpdate to Rel-17 version (MCC)\n17.0.0\n2024-03\n-\n-\n-\n-\n-\nUpdate to Rel-18 version (MCC)\n18.0.0",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.7.1",
        "clause_6.7.2",
        "ts_23.038"
      ]
    }
  ]
}