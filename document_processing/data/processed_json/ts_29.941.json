{
  "metadata": {
    "specification_id": "ts_29.941",
    "version": "Unknown",
    "title": "3GPP TS 29.941",
    "file_path": "/content/drive/MyDrive/RAG_thesis/data/29_series/29941-i00/29941-i00.docx"
  },
  "export_info": {
    "export_date": "2025-07-26T08:47:05.298654",
    "total_chunks": 38
  },
  "chunks": [
    {
      "chunk_id": "ts_29.941_1",
      "section_id": "1",
      "section_title": "Scope",
      "content": "IETF has indicated to 3GPP that future IANA port number assignment requests for protocol only used inside 3GPP networks will be likely rejected except if there is a strong justification for it. The present document provides guidelines for resolving the problem with allocating port numbers for new 3GPP interfaces, as an alternative to IANA assigned port numbers.\nStarting from 3GPP Rel-17, any 3GPP working group can rely on these guidelines when defining new interfaces, which require new default port number allocation.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_2",
      "section_id": "2",
      "section_title": "References",
      "content": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non‑specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TR 29.835: \"Study on Port Number Allocation Alternatives for New 3GPP Interfaces\".\n[3]\tIETF RFC 793: \"Transmission Control Protocol\".\n[4]\tIETF RFC 1078: \"TCP Port Service Multiplexer (TCPMUX)\"\n[5]\tIETF RFC 2782: \"A DNS RR for specifying the location of services (DNS SRV)\".\n[6]\tIETF RFC 4960: \"Stream Control Transmission Protocol\".\n[7]\tIETF RFC 5226: \"Guidelines for Writing an IANA Considerations clause in RFCs\".\n[8]\tIETF RFC 6066: \"Transport Layer Security (TLS) Extensions: Extension Definitions\".\n[9]\tIETF RFC 6083: \"Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)\".\n[10]\tIETF RFC 6335: \"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry\".\n[11]\tIETF RFC 6347: \"Datagram Transport Layer Security Version 1.2\".\n[12]\tIETF RFC 6762: \"Multicast DNS\".\n[13]\tIETF RFC 6763: \"DNS-Based Service Discovery\".\n[14]\tIETF RFC 7301: \"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension\".\n[15]\tIETF RFC 7605: \"Recommendations on Using Assigned Transport Port Numbers\".\n[16]\tIETF RFC 7805: \"Moving Outdated TCP Extensions and TCP-Related Documents to Historic or Informational Status\".\n[17]\tIETF RFC 8126: \"Guidelines for Writing an IANA Considerations Clause in RFCs\".\n[18]\tIETF RFC 8446: \"The Transport Layer Security (TLS) Protocol Version 1.3\".\n[19]\tIETF RFC 1035: \"Domain Names – Implementation and specification\".\n[20]\t3GPP TS 29.641: \"3GPP registry for Service Names and Port Numbers\".",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905",
        "ts_29.835",
        "ts_29.641"
      ]
    },
    {
      "chunk_id": "ts_29.941_3.1",
      "section_id": "3.1",
      "section_title": "Terms",
      "content": "For the purposes of the present document, the terms given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905"
      ]
    },
    {
      "chunk_id": "ts_29.941_3.2",
      "section_id": "3.2",
      "section_title": "Symbols",
      "content": "Void.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_3.3",
      "section_id": "3.3",
      "section_title": "Abbreviations",
      "content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.1",
      "section_id": "4.1",
      "section_title": "General",
      "content": "Since 2015, IANA had gradually warned 3GPP that a solution should be found to avoid port assignments for protocols only used in 3GPP networks (and not on the public Internet). The last requests were exceptionally granted by the Internet Engineering Steering Group (IESG) only at the conditions that it was the last one(s). Now, it is clear that application for a new port will not be granted without a strong justification and only if:\n-\tThe recommendations given in IETF RFC 7605 [3] have been carefully followed (see Annex C.4);\n-\tIt is proved that there is no other solution than port assignment for service port discovery.\nThe IETF RFC 7605 [3] provides recommendations to designers of application and service protocols on how to use the transport protocol port number space and when to request a port assignment from IANA. In this document, it is reminded that:\nIANA assigns port numbers so that Internet endpoints do not need pairwise, explicit coordination of the meaning of their port numbers. This is the primary reason for requesting port number assignment by IANA: to have a common agreement between all endpoints on the Internet as to the default meaning of a port number, which provides the endpoints with a default port number for a particular protocol or service.\nIt is also clarified that:\nPort numbers can also be used for other purposes. Assigned port numbers can simplify end-system configuration, so that individual installations do not need to coordinate their use of arbitrary port numbers. Such assignments may also have the effect of simplifying firewall management, so that a single, fixed firewall configuration can either permit or deny a service that uses the assigned ports.\nIn typical roaming scenarios, three or more administrative domains can be crossed: visited and home PLMN, one or more IPX providers connecting together via an IPX peering point for traffic exchange between PLMNs. Operators and service providers may even decide to rely on the global connectivity provided by the public Internet for interconnection.\nAs roaming implies the need for a global configuration of the port to use for a particular protocol, it is strongly recommended for 3GPP to apply to IANA for assigned service name and port number for any protocol potentially supported by roaming interfaces when no other service port discovery (e.g. DNS-based solutions) is applicable.\nIn non-roaming scenarios, a given interface can still cross multiple domains. For instance, RAN can be supported by an IP-based network distinct from the one supporting the core network even if both are under the same PLMN Another example is the RAN sharing case (i.e. same RAN is used by multiple PLMN's CN) in which the interface between RAN and CN also crosses multiple administrative domains. In such a case, it is also strongly recommended for 3GPP to apply to IANA for assigned service name and port number for any protocol potentially supported by inter-domain interfaces when no other service port discovery (e.g. DNS-based solutions) is applicable.\nFor 3GPP interfaces that would be used only in intra-domain scenarios, alternative solutions to IANA assigned port numbers are required.\nTable 4.1-1 provides brief summary of the identified alternative solutions.\nTable 4.1-1: Solution summary\nSolution\nPort allocation method\nApplicable transport layer protocol\nSuitable (NOTE)\nComments\nInter-domain\nIntra-domain\n#1\nUn-assigned\nUDP, TCP, SCTP\nPart\nYes\nDNS infrastructure based solution (DNS-SD)\nThe port number is selected dynamically by the interface application locally. DNS server is kept up-to-date with the records like hostnames, IP addresses, locally assigned port numbers, service names supported, etc. for application clients to discover using DNS PTR query.\nThis solution is suitable for inter-domain scenario with certain limitations.\nInter-PLMN service discovery can be provided using operator DNS servers connected to the IPX, the private, inter-operator IP backbone network. But if the traffic related to the discovered application/interface needs to be controlled, this will not work as the destination port is unknown to security gateway/firewall.\n#2\nUn-assigned\nUDP, TCP, SCTP\nPart\nYes\nDNS infrastructure based solution (DNS SRV)\nThis is an alternative to solution#1 in which there is only one logical instance of service <Service> and all clients are expected to use that one logical instance. Application clients can discover the server end point details using DNS SRV query.\nRequires DNS infrastructure application clients that support DNS queries.\nThis solution is suitable for inter-domain scenario with certain limitations.\nInter-PLMN service discovery can be provided using operator DNS servers connected to the IPX, the private, inter-operator IP backbone network operator DNS servers connected to the IPX, the private, inter-operator IP backbone network. But if the traffic related to the discovered application/interface needs to be controlled, this will not work as the destination port is unknown to security gateway/firewall.\n#3\nUn-assigned\nUDP, TCP, SCTP\nNo\nYes\nMulticast DNS based solution (mDNS)\nInstead of sending the DNS query to a unicast DNS server, the query is sent to a link-local multicast address. The nodes are implemented with mDNS resolver and responder. The node supporting the service responds to the mDNS query.\nThis solution is not suitable for Inter-domain scenario, because multicast is restricted to local link.\n#4\nUn-assigned\nUDP, TCP, SCTP\nPart\nYes\nUnicast DNS based solution (uDNS)\nSimilar to Solution#3 with only difference that the mDNS query is sent to a pre-configured IP address instead of the link-local multicast address.\nThis solution is suitable for inter-domain scenario with certain limitations.\nIf the IP address can be dynamically resolved, e.g. using an FQDN to retrieve an IP from the DNS and inter-domain interface is secured it can be used for Inter-domain scenario. But if DNS has to be used, then this solution has less value than the Solution#1 and the Solution#2.\n#5\nFixed\nSCTP\nYes\nYes\nSCTP MUX based solution using standardized PPID (SCTP MUX)\nAll new interfaces/applications use a common standardized port number and unique standardized SCTP Payload Protocol Identifier (PPID). The server side implements an SCTP multiplexer that distributes the traffic to intended applications based on PPID value.\nThis solution is suitable for Inter-domain scenario.\n#6\nFixed\nUDP, TCP, SCTP\nPart\nYes\n3GPP allocated port number solution (3GPP)\nIANA does not assign any port number from the Dynamic/Private range [49152 - 65535]. If 3GPP standardizes a subrange [65400 - 65500] from this range for 3GPP interfaces and starts allocating port numbers, this may cause port number clash during the actual deployments.\nThis solution is suitable for inter-domain scenario with certain limitations. The limitation may be mitigated if firewall implementations will start supporting 3GPP allocated port number range.\n#7\nFixed\nUDP, TCP, SCTP\nNo\nYes\nOAM allocated port number solution (OAM)\nOperator becomes responsible for allocating port numbers via OAM from either the User range [1024-49151] or from the Dynamic/Private range [49152 - 65535]. Operator is also responsible for avoiding port number clashes.\nThis solution is not suitable for Inter-domain scenario.\n#8\nUn-assigned\nUDP, TCP, SCTP\nYes\nYes\nPort Registration and Retrieval via NRF based solution (NRF)\nNRF is enhanced to support the registration of port number information and the retrieval of the port number by an application client. An application client can use the NF Discovery service to retrieve the port number of a specific protocol, by indicating the protocol type.\nOn client side, this solution requires support of SBI interface to NRF. On server side, NRF will need to support port number registration and discovery for non-SBI interfaces/applications. If the traffic related to the discovered application/interface needs to be controlled, this will not work as the destination port is unknown for security gateway/firewall.\nThis solution is suitable for inter-domain scenario.\nNOTE:\t'Part' indicates the solution is partially suitable for the inter-domain scenario and certain limitations need to be considered. For instance, with inter-domain scenario, it is not possible to prevent firewalls/security gateways located between two domains from restricting outgoing/incoming network traffic for a specific port not assigned by IANA. It is therefore strongly recommended for 3GPP to apply to IANA for assigned service name and port number.\nAnnex A on this specification summarizes IANA port allocation policy.\nAnnexes B.1 and B.2 provide essential background information and also how IANA classifies different port number ranges. Annex B.3 explains relations between the services and port numbers.\nAnnex C explains IANA procedures for Service Name and Port Number registry management.\n3GPP procedures for Service Name and Port Number registry management are specified in 3GPP TS 29.641 [20].",
      "chunk_type": "definition",
      "cross_references": [
        "table_4.1-1",
        "ts_29.641"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.2.1",
      "section_id": "4.2.1",
      "section_title": "General",
      "content": "DNS procedures can be used to discover a service or a service instance in a given domain using PTR (see IETF RFC 1035 [19]) and/or SRV resource record lookups.\nThe PTR and SRV lookup are performed on the name:\n<Service>.<Domain>\nThe <Service> portion consists of a pair of DNS labels separated by a dot, following the convention already established for SRV records (IETF RFC 2782 [8]).\nThe first label of the pair is an underscore character followed by an IANA registered Service Name (IETF RFC 6335 [10]).\nNOTE 1:\tService names are assigned on a \"first come, first served\" basis, as described in clause 8.1 of IETF RFC 6335 [10]. There is no substantive review of the request, other than to ensure that it is well-formed and doesn't duplicate an existing assignment.\nFor new service names registered by 3GPP, the Service Name should start with \"3gpp-\", followed by a name identifying the application protocol defined by 3GPP. This name should be the acronym used to identify the protocol in 3GPP specifications.\nThe second label is either \"_tcp\" (for application protocols that run over TCP) or \"_udp\" (for application protocols that run over any transport protocol other than TCP, e.g. SCTP).\nEXAMPLE:\tIANA-assigned Service Name for the SCTP application W1AP supporting the service provided by the W1 interface defined by 3GPP:\n\"_3gpp-w1ap._udp\"\nThe <Domain> portion specifies the DNS subdomain within which those names are registered. It may be:\n-\t\"local.\" in the absence of any conventional Unicast DNS server, meaning \"link-local Multicast DNS\" (see IETF RFC 6762 [12]);\n-\tA subdomain of any conventional Unicast DNS domain name operated by the operator, e.g. \"example.com\";\n-\tA subdomain of \"mnc<MNC>.mcc<MCC>.3gppnetwork.org\" for service discovery across PLMNs (e.g. in roaming cases).\nWhen relying on a DNS infrastructure, the operators are responsible for:\n-\tThe selection of the subdomain name in which the Service Instance Names are registered, and\n-\tThe provisioning of the authoritative DNS server of this subdomain with the corresponding PTR, SRV, TXT and A/AAAA records used to discover and contact the target nodes.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_8.1"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.2.2.1",
      "section_id": "4.2.2.1",
      "section_title": "General",
      "content": "The DNS-based Service Discovery (DNS-SD) (see IETF RFC 6763 [13]) allows clients to discover one or multiple nodes in the network supporting a specific service, the application protocol and the transport protocol used for accessing the service, using standard DNS queries sent to a conventional unicast DNS server available in the network.\nIn 3GPP networks, any IP-based interface can been considered as a specific service provided by a node on a given IP address and an IP port number. By identifying an interface with a unique service name, the DNS-based Service Discovery (DNS-SD) can be used by clients to discover the IP port number used by a remote node for a given interface.\nIn this proposed solution, it is assumed that a conventional unicast DNS server is available in the network. When a node is activated in the network, the service application is assigned with any available port from either the User Port number range [1024-49151] or the Dynamic/Private Port range [49152 - 65535]. The DNS server of the domain needs to be updated with the node's DNS records (configured hostnames, IP addresses, locally assigned port numbers, service names supported, etc.). This update can be done manually by the network administrator or done automatically by the node with mechanisms such as Dynamic DNS (DDNS).\nThe name of the service supported by a given 3GPP interface is registered to IANA. It consists of a pair of DNS labels separated by a dot, following the convention already established for SRV records (IETF RFC 2782 [5]).\n-\tThe first label of the pair is an underscore character followed by an IANA registered Service Name (IETF RFC 6335 [10]).\n-\tThe second label is either \"_tcp\" (for application protocols that run over TCP) or \"_udp\" (for application protocols that run over any transport protocol other than TCP).\nService names are assigned by IANA on a \"first come, first served\" basis, as described in Clause 8.1 of IETF RFC 6335 [10]. There is no substantive review of the request, other than to ensure that it is well-formed and doesn't duplicate an existing assignment. The assignment of a standard service name is therefore straightforward.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_8.1"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.2.2.2",
      "section_id": "4.2.2.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n-\tA listening port is locally assigned to a service application hosted in a node;\n-\tThe DNS server of the domain is updated with the resource records of the service application (configured hostnames, node's IP addresses, locally assigned port numbers, service names supported, etc.);\n-\tThe service application client implements a DNS resolver.\nTo set-up a transport connection with the application server, the following steps apply:\n1\tThe client is configured with an IANA registered service name <Service> identifying a specific service and the application protocol used to support the service.\n2\tTo discover the list of available service instances supporting the service <Service> in the domain <Domain>, the client performs a DNS-SD PTR lookup (see IETF RFC 6763 [13]) for the name:\n<Service>.<Domain>\nNOTE 1:\tthe domain name in which the service instances have to be discovered is either configured in the client or derived from service-specific information e.g. IMSI/SUPI, PLMN-Id, etc.3\tThe DNS query is sent to the conventional unicast DNS server.\n4\tThe result of the DNS-SD's PTR lookup is a set of zero or more PTR records giving the list of available instances in the form of Service Instance Names:\nService Instance Name = <Instance>.<Service>.<Domain>\nIn which the <Instance> portion is a user-friendly name, consisting of arbitrary Net-Unicode text, as defined in IETF RFC 6763 [13].\nWhen at least one PTR record is present in the DNS response, the following additional records are included in the DNS response:\n-\tThe SRV record(s) for each Service Instance Name listed in the PTR record(s), providing the port number and target host name of the Service Instance Name.\n-\tAll address records (type \"A\" and \"AAAA\") for the target host name listed in the SRV record(s).\n-\tThe TXT record(s) containing a single zero octet (i.e., a single empty string.) for each Service Instance Name named in the PTR record(s).\nNOTE 2:\tDNS clients are able of functioning correctly with DNS servers (and Multicast DNS Responders) that fail to generate these additional records automatically, by issuing subsequent queries for any further record(s) they require.\nNOTE 3:\tAs described in IETF RFC 6763 [13], TXT record(s) containing a single zero octet indicate that there is no additional data for the given Service Instance\n5\tIn the event that more than one SRV is returned, the client shall correctly interpret the priority and weight fields to select the target node i.e.:\n-\tLower-numbered priority instances should be used in preference to higher-numbered priority instances, and\n-\tInstances with equal priority should be selected randomly in proportion to their relative weights.\nNOTE 4:\tIt is recommended to give the same weight to all the instances with the same priority.\n6\tThe client can set up connection(s) with the remote node(s) using the IP address(es) and port number(s) retrieved from the DNS server and then application data can be exchanged between the client and the server.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.2.3",
      "section_id": "4.2.2.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tPort numbers are locally assigned in the node supporting the interface applications.\n-\tLimit the need for manual configuration.\n-\tLeveraging on a proven DNS infrastructure and mature technology.\n-\tThe \"_tcp\" and \"_udp\" subdomains can be delegated to a dedicated DNS server.\nCons:\n-\tRely on the availability of a DNS infrastructure.\n-\t3GPP nodes need to implement a DNS resolver in order to discover interfaces supported by other nodes.\n-\tThe discovery mechanism implies additional signalling before setting up the connection between nodes.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.3.1",
      "section_id": "4.2.3.1",
      "section_title": "General",
      "content": "This is an alternative to solution#1 in which there is only one logical instance of service <Service> and all clients are expected to use that one logical instance. Of course, the logical instance can be load-shared across multiple nodes, but all the nodes provide an equivalent service.\nIn this proposed solution, to discover the list of available service instances, the client performs a simple SRV lookup (see IETF RFC 2782 [5]) instead of a PTR lookup in solution#1:\nThe result of the SRV lookup is SRV record(s) providing the port number and target host name of the nodes supporting the service. All address records (type \"A\" and \"AAAA\") for the target host name listed in the SRV record are also provided.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.3.2",
      "section_id": "4.2.3.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n-\tA listening port is locally assigned to a service application hosted in a node;\n-\tThe DNS server of the domain is updated with the resource records of the service application (configured hostnames, node's IP addresses, locally assigned port numbers, service names supported, etc.);\n-\tThe service application client implements a DNS resolver.\nTo set-up a transport connection with the application server, the following steps apply:\n1\tThe client is configured with an IANA registered service name <Service> identifying a specific service and the application protocol used to support the service.\n2\tTo discover the list of available service instances supporting the service <Service> in the domain <Domain>, the client performs a DNS SRV lookup (see IETF RFC 6763 [13]) for the name:\n<Service>.<Domain>\nNOTE 1:\tthe domain name in which the service instances have to be discovered is either configured in the client\tor derived from service-specific information e.g. IMSI/SUPI, PLMN-Id, etc. See 3GPP TS 23.003.\n3\tThe DNS query is sent to the conventional unicast DNS server.\n4\tThe result of the DNS SRV lookup is a set of zero or more SRV records providing the port number and host name of the target nodes supporting the service. All address records (type \"A\" and \"AAAA\") for the target host name listed in the SRV record are also provided:\nNOTE 2:\tDNS clients are able of functioning correctly with DNS servers that fail to generate these additional A/AAAA records automatically, by issuing subsequent queries for any further record(s) they require.\n5\tIn the event that more than one SRV is returned, the client shall correctly interpret the priority and weight fields to select the target node i.e.:\n-\tLower-numbered priority instances should be used in preference to higher-numbered priority instances, and\n-\tInstances with equal priority should be selected randomly in proportion to their relative weights.\nNOTE 3:\tIt is recommended to give the same weight to all the instances with the same priority.\n6\tThe client can set up connection(s) with the remote node(s) using the IP address(es) and port number(s) retrieved from the DNS server and then application data can be exchanged between the client and the server.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.003"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.2.3.3",
      "section_id": "4.2.3.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tPort numbers are locally assigned in the node supporting the interface applications.\n-\tLimit the need for manual configuration.\n-\tLeveraging on a proven DNS infrastructure and mature technology.\n-\tThe \"_tcp\" and \"_udp\" subdomains can be delegated to a dedicated DNS server.\nCons:\n-\tRely on the availability of a DNS infrastructure.\n-\t3GPP nodes need to implement a DNS resolver in order to discover interfaces supported by other nodes.\n-\tThe discovery mechanism implies additional signalling before setting up the connection between nodes.\n-\tIt is not possible to discriminate multiple service instances. All clients are expected to use that the same logical instance.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.4.1",
      "section_id": "4.2.4.1",
      "section_title": "General",
      "content": "This is an alternative to solution#1 and solution#2 in the absence of DNS server in the domain.\nMulticast DNS (mDNS) (see IETF RFC 6762 [12]) provides the ability to perform DNS-like operations on the local link in the absence of any conventional Unicast DNS server. DNS queries are multicasted on a local link and any node receiving the query responds with a unicast packet directed back to the querier if it supports the service requested by the querier. The response can also be multicasted on local link, all the nodes on this local link being updated at the same time.\nMulticast DNS can provide zero-configuration operation -- just connect a DNS-SD/mDNS device, and its services are advertised on the local link with no further user interaction.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.4.2",
      "section_id": "4.2.4.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n-\tA listening port is locally assigned to a service application hosted in a node;\n-\tThe application server implements a Multicast DNS responder listening for DNS queries on the UDP port 5353\n-\tthe application client implements either a full Multicast DNS resolver sending DNS queries from the UDP source port 5353 or a minimal Multicast DNS resolver (light enhancement of a legacy DNS resolver) sending DNS queries from high-numbered ephemeral UDP source port.\nTo set-up a transport connection with the SCTP application server, the following steps apply:\n1\tThe client is configured with an IANA registered service name <Service> identifying a specific service and the application protocol used to support the service.\n2\tTo discover the list of available service instances supporting the service <Service> on the local link, the client performs a DNS PRT lookup (solution#1, see clause 4.2.2.2) or SRV lookup (solution#2, see clause 4.2.3.2) for the name:\n<Service>.local.\n3\tDNS queries are sent to the mDNS IPv4 link-local multicast address 224.0.0.251 or mDNS IPv6 link-local multicast address FF02::FB, to UDP destination port 5353 and using as UDP source port either:\n-\tport 5353 if the client supports a fully compliant mDNS resolver; or\n-\ta high-numbered ephemeral UDP source port other than port 5353, if the client supports minimal Multicast DNS resolver\nNOTE 1:\tIt is recommended to use the mDNS IPv4 link-local multicast address only if IPv6 is not not avalaible.\n4\tA node receiving the mDNS request and supporting the desired service shall provide in the response its own DNS records as described in clauses 4.2.2.2 (solution#1) and 4.2.3.2 (solution#2).\n5\tThe DNS response is either unicast to the source IP address of the DNS querier, or the response is multicast on the local link.\nNOTE 2:\tDNS querier can asked for unicast response by setting the unicast-response bit, the top bit in the class field of a DNS question.\n6\tThe client can set up connection(s) with the remote node(s) using the IP address(es) and port number(s) retrieved from the DNS server and then application data can be exchanged between the client and the server.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.2.2.2",
        "clause_4.2.3.2"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.2.4.3",
      "section_id": "4.2.4.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tPort numbers are locally assigned in the node supporting the interface applications.\n-\tLittle or no administration or configuration to set the nodes up\n-\tWork when no DNS infrastructure is present\n-\tCan be used also during DNS infrastructure failures\nCons:\n-\tAll the nodes have to be on the same logical local network.\n-\t(Minimal) Multicast DNS resolvers and Multicast DNS responders have to be implemented in the nodes.\n-\tAdditional traffic with multicast queries and responses.\n-\tThe discovery mechanism implies additional signalling before setting up the connection between nodes.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.5.1",
      "section_id": "4.2.5.1",
      "section_title": "General",
      "content": "This is an alternative to solution#3 when there is no DNS server and the target node can be outside the local link.\nIn this proposed solution, instead of relying on Multicast DNS queries sent on the local link, the client sends its DNS query via unicast directly to the node, using the destination port 5353. The IP address of the target node is discovered by configuration.\nThe node receiving the unicast DNS query and supporting the desired service answers via with a unicast packet directed back to the client, using the source IP address and port of the received DNS query.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.5.2",
      "section_id": "4.2.5.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n-\tA listening port is locally assigned to a service application hosted in a node;\n-\tThe application server implements a Multicast DNS responder listening for DNS queries on the UDP port 5353\n-\tthe application client implements either a full Multicast DNS resolver sending DNS queries from the UDP source port 5353 or a minimal Multicast DNS resolver (light enhancement of a legacy DNS resolver) sending DNS queries from high-numbered ephemeral UDP source port.\nTo set-up a transport connection with the application server, the following steps apply:\n1\tThe client is configured with:\n-\tAn IANA registered service name <Service> identifying a specific service and the application protocol used to support the service;\n-\tThe IP address of the target node.\n2\tTo discover the list of available service instances supporting the service <Service> on the local link, the client performs a DNS PRT lookup (solution#1, see clause 4.2.2.2) or SRV lookup (solution#2, see clause 4.2.3.2) for the name:\n<Service>.local.\n3\tDNS queries are sent to the unicast IP address of the target node configured in the client, to UDP destination port 5353 and using as UDP source port either:\n-\tPort 5353 if the client supports a fully compliant mDNS resolver; or\n-\tHigh-numbered ephemeral UDP source port other than port 5353, if the client supports minimal Multicast DNS resolver\nNOTE:\tIt is recommended to use the mDNS IPv4 link-local multicast address only if IPv6 is not not avalaible.\n4\tA node receiving the mDNS request and supporting the desired service will provide in the response its own DNS records as described in clause 4.2.2.2 (solution#1) and 4.2.3.2 (solution#2).\n5\tThe DNS response is unicast to the source IP address of the DNS querier.\n6\tThe client can set up connection(s) with the remote node(s) using the IP address(es) and port number(s) retrieved from the DNS server and then application data can be exchanged between the client and the server.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.2.2.2",
        "clause_4.2.3.2"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.2.5.3",
      "section_id": "4.2.5.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tPort numbers are locally assigned in the node supporting the interface applications.\n-\tMinimal administration or configuration to set the nodes up\n-\tWork when no DNS infrastructure is present\n-\tCan be used also during DNS infrastructure failures\nCons:\n-\t(Minimal) Multicast DNS resolvers and Multicast DNS responders have to be implemented in the nodes.\n-\tThe discovery mechanism implies additional signalling before setting up the connection between nodes.\n-\tThe signalling between the client and the target node outside the local link shall be protected with confidentiality, integrity and replay protection, using for instance IPsec.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.2.6",
      "section_id": "4.2.6",
      "section_title": "Guidelines for DNS based solutions#1-4",
      "content": "It is beneficial to use solution#1 (DNS-SD) and solution#2 (DNS SRV), if DNS infrastructure is readily available and if the clients support DNS-based discovery mechanisms.\nWhen relying on a DNS infrastructure, the <Domain> portion of the Service Instance Name in which the Service Instance Names are registered depends on the nature of the interface on which the transport protocol is used:\n-\tIf the interface is only used in an intra-domain scenario, the operators are free to use any suitable subdomain of the domain for which the operator is responsible, e.g. \"example.com\";\n-\tIf the interface may be used in an inter-domain scenario, the <Domain> portion must be a subdomain of the domain \"mnc<MNC>.mcc<MCC>.3gppnetwork.org\", e.g.:\n-\t\"epc.mnc<MNC>.mcc<MCC>.3gppnetwork.org\" when the DNS server is located in the 3GPP core network;\n-\t\"ran.mnc<MNC>.mcc<MCC>.3gppnetwork.org\" when the DNS server is located in the 3GPP radio access network.\nOperators are responsible for the provisioning of the authoritative DNS server of this subdomain with the corresponding resource records (PTR, SRV, TXT and A/AAAA) used to discover and contact the service instances.\nIt is beneficial to use solution#3 (mDNS), if DNS infrastructure is not available and the clients support mDNS queries. Solution#3 however is not suitable for the inter-domain scenario, because multicast is restricted to the local link.\nIt is beneficial to use solution#4 (uDNS), if there is no DNS server, the target node can be outside the local link and the clients support unicast DNS queries. Solution#4 can also be used for the inter-domain scenario, but that requires DNS infrastructure. If DNS has to be used, then solution#4 has less value than solution#1 and solution#2.\nNOTE:\tFor inter-domain scenario, it is not possible to prevent firewalls/security gateways located between two domains from restricting outgoing/incoming network traffic for a specific port not assigned by IANA. It is therefore strongly recommended for 3GPP to apply to IANA for assigned service name and port number.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.3.1",
      "section_id": "4.3.1",
      "section_title": "General",
      "content": "The TCP Port Service Multiplexer (TCPMUX) is defined in IETF RFC 1078 [4]. The specification describes a multiplexing service that may be accessed with a network protocol to contact any one of a number of available TCP services of a host on a single, well-known port number.\nThe same principle is applied to SCTP applications.\nAn SCTP (IETF RFC 4960 [6]) packet is composed of a common header and chunks.\nThe SCTP common header contains:\n-\tThe SCTP Source Port Number that can be used by the receiver in combination with the source IP address, the SCTP destination port, and possibly the destination IP address to identify the association to which this packet belongs.\n-\tThe SCTP Destination Port Number that can be used by the receiving host to de-multiplex the SCTP packet to the correct receiving endpoint/application.\nA SCTP chunk represents a protocol message, which can be used by the protocol itself or can contain user data. User data are contained in DATA chunks that include a Payload Protocol Identifier. The Payload Protocol Identifier is used to identify the application which uses the services of SCTP.\nAs it is contained in each DATA chunk, the Payload Protocol Identifier identifies the protocol being carried over SCTP independently of the port numbers being used. The Payload Protocol Identifier can be used therefore to de-multiplex the SCTP packet to the correct receiving endpoint/application above SCTP instead of the SCTP Destination Port Number.\nThe proposed solution based on the Payload Protocol Identifier parsing would then allow to contact multiple applications on a single well-known STCP port using the SCTP Payload Protocol Identifier instead of requesting IANA for allocation of a new well-known SCTP port number each time a new application is defined.\nThe SCTP multiplexer is implemented as a stand-alone process above the SCTP layer, listening at the well-known SCTP port and used to initiate and manage associations with remote SCTP endpoints and distribute received SCTP messages to upper-layer applications based on the Payload Protocol Identifier. The SCTP multiplexer is seen as a regular SCTP user. There is no impact on the SCTP stack.\nThe well-known port can be:\n-\tThe port already allocated for TCPMUX (port 1);\n-\tA port already allocated for another SCTP application defined by 3GPP;\n-\tA new port dedicated to SCTP multiplexing allocated in a port range locally administrated by 3GPP.\n-\tA new port dedicated to SCTP multiplexing allocated by IANA.\nIn the figure below, a single SCTP host is supporting 4 new applications in addition of an existing W1 application (identified by the IANA-assigned port 38472). The port number used to identify the multiplexer is 47002 (given only as possible unassigned User Port that can be assigned by IANA for the SCTP multiplexer application).\nFigure 4.3.1-1: SCTP server-side illustration for SCTP Multiplexer (port)\nWhen DTLS over SCTP, as described in IETF RFC 6083 [9], is used to provide mutual authentication, integrity protection, replay protection and confidentiality protection, only SCTP user data are integrity protected and encrypted by DTLS. The Payload Data (DATA) header, in which the SCTP Payload Protocol Identifier is indicated, is therefore sent as clear text. The SCTP Multiplexer can still use the SCTP Payload Protocol Identifier to distribute SCTP messages to upper-layer applications. Moreover, the SCTP associations being managed by the SCTP Multiplexer and the DTLS connections being handled by the applications (identified by the SCTP Payload Protocol Identifier) above the SCTP Multiplexer, it is possible to have multiple DTLS connections over a the same SCTP association, one DTLS connection per application (or per SCTP Payload Protocol Identifier).\nIn the figure below, a single SCTP host is supporting 4 new applications in addition of an existing W1 application (identified by the IANA-assigned port 38472). The port number used to identify the multiplexer is 47002 (given only as possible unassigned User Port that can be used). DTLS over SCTP is used to provide communications privacy for applications above the SCTP Multiplexer.\nFigure 4.3.1-2: SCTP server-side illustration for SCTP Multiplexer (SCTP MUX) with used of DTLS over SCTP",
      "chunk_type": "definition",
      "cross_references": [
        "figure_4.3.1-1",
        "figure_4.3.1-2"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.3.2",
      "section_id": "4.3.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n-\tThe server implements an SCTP multiplexer that can serve multiple applications on a single well-known STCP port.\n-\tEach SCTP application hosted in the server is configured with an internal IP address and a listening port. The SCTP multiplexer is configured with forwarding rules that associate an SCTP Payload Protocol Identifier with a target internal IP address/port. The forwarding rules are used by the SCTP multiplexer to forward incoming SCTP application traffic received on the well-known STCP port to the internal application processes.\n-\tThe client is configured with the IP address of the server to contact and use the well-known STCP port associated to the SCTP multiplexer or the IP address is discovered using basic DNS procedures.\nTo set-up a transport connection with the SCTP application server, the following steps apply:\n1\tThe client sends an INIT signal to the SCTP multiplexer on the dedicated port to initiate an association.\n2\tOn receipt of the INIT signal, the SCTP multiplexer sends an INIT-ACK response to the client. This INIT-ACK signal contains a state cookie.\n3\tOn receipt of this INIT-ACK signal, the client sends a COOKIE-ECHO response, which just echoes the state cookie.\n4\tAfter verifying the authenticity of the state cookie, the SCTP multiplexer then allocates the resources for the association, sends a COOKIE-ACK response acknowledging the COOKIE-ECHO signal, and the association is said ESTABLISHED.\n5\tThe client can send to the SCTP multiplexer user data encapsulated within SCTP DATA chunks, each DATA chunk including a Payload Protocol Identifier identifying the requested application.\n6\tThe SCTP multiplexer checks the Payload Protocol Identifier included in each received DATA chunk.\na\tIf the Payload Protocol Identifier is supported i.e., there is an internal process that supports the requested application, the SCTP multiplexer delivers the user data to the correct receiving application. The reception of the DATA chunk is then acknowledged by a SACK chunks and protocol data exchange between the client and the application behind the SCTP multiplexer can continue.\nb\tIf the Payload Identifier is not supported i.e., there is no internal process that supports the requested application, the SCTP multiplexer will abort the created SCTP association, sending an ABORT chunk to the client that contains a User-Initiated Abort cause code (12). A specific Upper Layer Abort Reason (e.g. \"Unsupported Payload Protocol Identifier\") can also be included and be delivered to the upper-layer protocol at the peer.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.3.3",
      "section_id": "4.3.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tMultiple SCTP applications can be run on the same port.\n-\tMinimal administration or configuration to set the nodes up.\n-\tDoes not rely on DNS infrastructure.\nCons:\n-\tAn SCTP multiplexer process needs to be implemented in servers.\n-\tOnly applicable to protocols carried over SCTP.\n-\tNeed for IANA port number allocation if the one assigned to TCPMUX is not reused.\n-\tNeed for a 3GPP-managed port allocation if the port used for SCTP multiplexer is neither the one for TCPMUX nor one allocated by IANA.\n-\tNot possible to use the port number to distinguish SCTP applications.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.3.4",
      "section_id": "4.3.4",
      "section_title": "Guidelines for SCTP based solution#5",
      "content": "Solution#5 (SCTP MUX) is beneficial for clients that utilize SCTP.\nIt is strongly recommended to apply to IANA for assigned service name and SCTP port number for the first application of this solution in 3GPP networks. For additional SCTP applications, only the service name will have to be assigned by IANA as all the new SCTP application will be multiplexed over the same assigned STCP port using the SCTP Payload Protocol Identifier.\nWith IANA assigned service name and port numbers, solution#5 is beneficial for inter-domain scenario.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.4.1",
      "section_id": "4.4.1",
      "section_title": "General",
      "content": "In scenarios, when IANA allocated default port numbers cannot be used, while a new 3GPP interface application may require a pre-defined specific server port number, 3GPP becomes responsible for allocating a server port number. Such port numbers should be assigned from a sub-range of the Dynamic/Private Port range [49152 - 65535].\nNOTE:\tClause 4 in IETF RFC 6335 [2] specifies that the term \"assignment\" is used to refer to the procedure by which IANA provides service names and/or port numbers to requesting parties and that other RFCs refer to this as \"allocation\" or \"registration\". IANA does not assign port numbers from Dynamic/Private Port range [49152 - 65535] and therefore any application designer is free to use any of these ports at will.\nWhen a new 3GPP Rel-17 and onwards application requires pre-defined server port number, during the application initialization the operating system will tell the new application if the port is already in use or not. If the port is in use by another, legacy application, the new application or operating system shall ensure that the legacy application stops using the port. It is up to the implementation to decide if the legacy application will be forced to stop using the port immediately, or if the legacy application will be granted some period of time for graciously removing the port from usage.\nAny sub-range from [49152 - 65535] range would be good for this purpose. 3GPP decided to set aside a sub-range of 101 ports from 65400 to 65500. 3GPP allocated port numbers are documented in 3GPP TS 29.641 [20].",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4",
        "ts_29.641"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.4.2",
      "section_id": "4.4.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n1.\tDynamic/Private Port number range [49152 - 65535] is not restricted by IANA and may be used by 3GPP or non-3GPP applications without any restrictions.\n2.\tMany existing interface applications are dynamically selecting port numbers from range [49152 - 65535] when populating source port field in UDP/TCP/SCTP header, e.g. for load balancing. In a request-response type of communication, the remote peer typically sends the response message to the port number, which is populating the source port field of the received request message.\n3.\tLet's assume, 3GPP specifies in Rel-17 or onwards that the port number of some new application 'X' is e.g. 50000.\n4.\tWhen sending a request message, the new application X will populate the port numbers as follows:\n-\tDestination port: e.g. 50000\n-\tSource port: e.g. 60000\n5.\tWhen the application peer sends a response, the new remote application X will populate the port numbers in a reverse order:\n-\tDestination port: 60000\n-\tSource port: 50000\n6.\tNow, in the network there will be other, legacy interface applications that were taken into use before application X is specified. Let's look into how the traffic for these applications would be handled.\n7.\tApplication X sends a request to the destination port 50000.\na.\tIf the application X peer receives such legit message, it will correctly handle the message.\nb.\tIf a legacy application receives such message at port 50000, then the following scenarios should be checked. Note, that legacy application may expect only a response message at port 50000. If the application does not listen to port 50000, the message will be discarded. Even if the application listens to port 50000, it obviously cannot correctly parse the X application request and therefore an application/protocol specific error handling will be triggered. The legacy application will discard the message also in this case and may either log an error or may resend the request. For resending the request, the sequence numbers in the outstanding request and in the received erroneous message shall match. The latter case is highly hypothetical, because it is unlikely the legacy application can correctly extract a sequence number from the erroneous message, in the first place. Even less likely would be finding the match.\n8.\tLegacy application sends a response to the destination port 50000, because it received a request from this port.\na.\tIf the legacy application peer receives such legit message, it will correctly handle the message.\nb.\tIf an application X receives such message at port 50000, then the following scenarios should be checked. Note, that application X may expect only a request message at port 50000. The application X obviously cannot correctly parse the legacy application request and therefore an application/protocol specific error handling will be triggered. In order to optimize the error handling, the application X should be able to detect the legacy application type. In such case, the message shall be silently discarded. There will be only a handful of legacy applications running on the given NF, i.e. the NF will be connected only to a handful of 3GPP interfaces. Therefore, such additional, but trivial feature will not cause any considerable extra efforts.\nThe following use case needs to be considered:\n-\tA legacy application client already runs on a network entity and a new 3GPP Rel-17 app is initializing;\n-\tBoth apps share the same IP address;\n-\tThe new 3GPP Rel-17 app shall listen to e.g. port 50000 for incoming requests;\n-\tThere is a small, but non-zero probability that the legacy app has sent a request to another server and is expecting a response to port 50000;\n-\tThe system will not allow new 3GPP Rel-17 app to run, because port 50000 is already in use;\n-\tImplementation needs to find a way to somehow remove port 50000 from the legacy app usage, which will enable new 3GPP Rel-17 app to start;\n-\tOnce the new 3GPP Rel-17 app is up and running, the system will ensure the legacy app will always select another port from the dynamic range. No more clashes will happen on this network entity.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.4.3",
      "section_id": "4.4.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tThe solution will have no impact on legacy applications.\nCons:\n-\tIf a legacy application client already runs on a network entity and a new 3GPP Rel-17 app is initializing on the same entity while both applications share the same IP address and port, then the system will not permit the new app to start. Implementation will need to find a way to free up the port in usage by the legacy application client, which will enable new 3GPP Rel-17 application to start.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.4.4",
      "section_id": "4.4.4",
      "section_title": "Guidelines for 3GPP allocated port number solution#6",
      "content": "It is beneficial to use solution#6 (3GPP), if obtaining new default port number from IANA is deemed unsuitable, but when it is preferable for applications to use a fixed port number.\nFor inter-domain scenario, currently it is not possible to prevent firewalls/security gateways located between two domains from restricting outgoing/incoming network traffic for a specific port not assigned by IANA. This limitation may be mitigated if firewall implementations will start supporting 3GPP allocated port number range. This will be similar to the GTP-aware firewall implementations, which are already commonplace in operator networks.  It is strongly recommended that 3GPP applies for IANA-assigned service name and port numbers.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.5.1",
      "section_id": "4.5.1",
      "section_title": "General",
      "content": "Each operator becomes responsible for allocating a port number to each new 3GPP application from either the User Port number range [1024-49151] or from the Dynamic/Private Port range [49152 - 65535].",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.5.2",
      "section_id": "4.5.2",
      "section_title": "Detailed description",
      "content": "The proposed solution is based on the following assumptions:\n1.\tAn operator determines which port numbers are not used as default ones in their network (either from the User Port number range [1024-49151] or from the Dynamic/Private Port range [49152 - 65535]).\n2.\tThe operator selects certain unused port number as a default one for the new 3GPP interface application and configures all relevant network entities with OAM.\n3.\tMany existing interface applications are dynamically selecting port numbers from range [49152 - 65535] when populating source port field in UDP/TCP/SCTP header, e.g. for load balancing. In a request-response type of communication, the remote peer typically sends the response message to the source port number of the received request message. If the new port number is selected from the Dynamic/Private Port range [49152 - 65535], then the solution will be similar to the one, which is described in clause 4.4 for Solution#6.\n4.\tIf the new port number is selected from the User Port number range [1024-49151], then the drawbacks described in the above bullet point 3 will be eliminated.\nThe following use case needs to be considered, if Dynamic/Private Port range [49152 - 65535] is used:\n-\tA legacy application client already runs on a network entity and a new 3GPP Rel-17 app is initializing;\n-\tBoth apps share the same IP address;\n-\tThe new 3GPP Rel-17 app shall listen to e.g. port 50000 for incoming requests;\n-\tThere is a small, but non-zero probability that the legacy app has sent a request to another server and is expecting a response to port 50000;\n-\tThe system will not allow new 3GPP Rel-17 app to run, because port 50000 is already in use;\n-\tOAM needs to find a way to somehow remove port 50000 from the legacy app usage, which will enable new 3GPP Rel-17 app to start;\n-\tOnce the new 3GPP Rel-17 app is up and running, the system will ensure the legacy app will always select another port from the dynamic range. No more clashes will happen on this network entity.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.4"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.5.3",
      "section_id": "4.5.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tGives full control and flexibility to operators when selecting default port numbers for new 3GPP interfaces.\nCons:\n-\tThe new application cannot have hard-coded default port number. That is, it will learn the default port number after successful configuration action.\n-\tMakes the default port setting logic more complex in a new application.\n-\tIf a legacy application client already runs on a network entity and a new 3GPP Rel-17 app is initializing on the same entity while both applications share the same IP address and port, then the system will not permit the new app to start. OAM will need to find a way to free up the port in usage by the legacy application client, which will enable new 3GPP Rel-17 application to start.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.5.4",
      "section_id": "4.5.4",
      "section_title": "Guidelines for OAM allocated port number solution7",
      "content": "It is beneficial to use solution#7 (OAM), if obtaining new default port number from IANA or from 3GPP is deemed unsuitable, but when it is preferable for applications to use a fixed port number. Solution#7 is not suitable for the inter-domain scenario.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.6.1",
      "section_id": "4.6.1",
      "section_title": "General",
      "content": "This is an alternative solution which allows port information registration to the NRF and port information retrieval from the NRF. This solution is applicable for those NFs have entry in the NRF and provide specific protocols for non-SBI interfaces.\nThis solution is mostly used to register port numbers for 3GPP interface applications whose port numbers are not allocated by IANA. It is recommended that the port number for 3GPP interface applications should be allocated from User Port number range [1024-49151] or from Dynamic/Private Port range [49152 - 65535].\nTo avoid potential port clash, an operator shall investigate the port numbers used by existing interfaces/applications hosted by an NF before deploying that NF, and thus determine one port number to be used and registered. Other mechanisms to detect and remove the port clash (e.g. described in clause 4.4 and 4.5 for solution#6 and solution#7, respectively) may also be used if necessary.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.4"
      ]
    },
    {
      "chunk_id": "ts_29.941_4.6.2",
      "section_id": "4.6.2",
      "section_title": "Detailed description",
      "content": "Normally, same port number is allocated to a group of NFs hosting the same protocol. However, different port numbers may be allocated for same protocol per NF Types, NF Sets, or even per NF instance.\nTo configure port numbers in the NRF, a data type of PortInfo is defined to carry a list of port record, and each port record indicates the port number and related protocol type. A PortInfo is included in the NF Profile to register the protocol and associated port numbers used by the NF. One PortInfo instance can be shared by multiple NFs which have the same NF type or belong to same NF Set. If one NF needs to be configured with different port number than other NFs using the same protocol, the NF can be configured with its own PortInfo.\nA requesting NF thus can use the NF Discovery service to retrieve the port number of a specific protocol, by indicating the protocol type. Other parameters such as NF type, NF Set ID, or NF Instance ID may also be provided as discovery parameter.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.6.3",
      "section_id": "4.6.3",
      "section_title": "Pros and cons",
      "content": "Pros:\n-\tReuse NRF mechanism for port configuration and retrieval.\n-\tPort number for a protocol can be configured at granularity of NF type, NF Set, or individual NF instance.\nCons:\n-\tThis solution relies on NRF mechanism, and is more applicable to non-SBI interfaces hosted by core network NFs.\n-\tIf this solution is used for RAN interfaces, the RAN node may need to support SBI interface to a localized NRF.\n-\tThe use cases for the NRF based solution will be reduced to non-roaming core network interfaces.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_4.6.4",
      "section_id": "4.6.4",
      "section_title": "Guidelines for Port Registration and Retrieval via NRF solution#8",
      "content": "It is beneficial to use solution#8 (NRF), if the network element can support service-based interface and access an NRF.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.941_5.1",
      "section_id": "5.1",
      "section_title": "General",
      "content": "As indicated in the clause 4.1, it is strongly recommended for 3GPP to apply to IANA for assigned service name and port number for any protocol potentially supported by roaming and inter-domain interfaces when no other service port discovery (e.g. DNS-based solutions) is applicable.\nWhen the IANA assignment request cannot be justified, one of the alternative solutions described in clause 4 should be adopted.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.1",
        "clause_4"
      ]
    },
    {
      "chunk_id": "ts_29.941_5.2",
      "section_id": "5.2",
      "section_title": "3GPP allocated Service Name and Port Number registry",
      "content": "3GPP CT4 maintains 3GPP TS 29.641 [20] as a repository of the 3GPP assigned Service Name and Port Numbers, which are necessary for the solution#6, which is specified in clause 4.4.\nAnnex A:IANA port allocation policy\nIANA maintains the list of service names and port numbers used to distinguish between different services that run over transport protocols such as TCP, UDP, DCCP and SCTP. The IANA registration procedures for service names and port numbers are described in IEFT RFC 6335 [2].\n-\tService names are assigned on a first-come, first-served process. Assignments are made to anyone on a \"first come, first served\" basis. There is no substantive review of the request, other than to ensure that it is well-formed and doesn't duplicate an existing assignment.\n-\tPort numbers are assigned in various ways, based on three ranges: System Ports [0-1023], User Ports [1024-49151], and the Dynamic and/or Private Ports [49152 - 65535].\nAccording to Clause 8.1.2 of IEFT RFC 6335 [2], IANA follows one the following procedures for port number value allocation defined in IEFT RFC 8126 [9]:\n-\tIETF Review:\n-\tNew values are assigned only through IETF RFCs in the IETF Stream, i.e., documents that has been approved by the IESG as having IETF consensus.\n-\tIESG Approval:\n-\tNew value assignment is directly approved by the IESG without the need for approved IETF RFCs.\n-\tExpert Review:\n-\tNew values are assigned after review and approval by a designated expert. An approved IETF RFC is not required but information needs to be provided with the request for the designated expert to evaluate.\nSystem Ports are assigned by IANA using the \"IETF Review\" or \"IESG Approval\" procedures.\nUser Ports are assigned by IANA using the \"IETF Review\" process or the \"IESG Approval\" process or the \"Expert Review\" process.\nDynamic Ports are not assigned. The Dynamic Ports range has been specifically set aside for local and dynamic use. Application software may simply use any dynamic port that is available on the local host, without any sort of assignment, assuming that the port used by applications are discovered by clients dynamically at run-time.\nSystem and User ports should not be used without or prior to IANA registration. The registration procedures for service names and port numbers are described in IEFT RFC 6335 [2].\nRecently, however, IANA became more restrictive to reserving new port numbers to private networks. IANA experts are now following the recommendations given in Clause 6 of IETF RFC 7605 [3]. Each port number assignment request must be now strongly justified by the applicants as independently useful service. This was done on purpose, as the range of port number that can be allocated by IANA is fixed and IANA does not want to run out of available port numbers in future, due to uncontrolled requests as it was done in the past (e.g. range of port numbers allocated to a single company etc.).\nAnnex B:Port number use\nB.1\tGeneral\nIn IP networking, the destination or origination IP address of a message is completed by a port number. If the IP address identifies the device e.g. computer, the port number is used to identify an application or service running on the device.\nThe current use of ports was clearly established in the Transmission Control Protocol [13]\nMultiplexing:\n-\tTo allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host. Concatenated with the network and host addresses from the internet communication layer, this forms a socket. A pair of sockets uniquely identifies each connection.\n-\tThat is, a socket may be simultaneously used in multiple connections.\n-\tThe binding of ports to processes is handled independently by each Host. However, it proves useful to attach frequently used processes (e.g., a \"logger\" or timesharing service) to fixed sockets which are made known to the public. These services can then be accessed through the known addresses.  Establishing and learning the port addresses of other processes may involve more dynamic mechanisms.\nThe port number is a 16-bit unsigned number, ranging then from 0 to 65535.\nAs indicated in the IETF RFC 6335 [2], this range [0-65535] is subdivided as follows:\n-\t0-1023: the System Ports, also known as the Well Known Ports, assigned by IANA\n-\t1024-49151: the User Ports, also known as the Registered Ports, assigned by IANA\n-\t49152-65535: the Dynamic Ports, also known as the Private or Ephemeral Ports, not assigned, controlled, nor registered.\nB.2\tPort number ranges\nSystem ports [0-1023] are assigned by IANA and were initially reserved to services that required privileged/root access to the operating system. They have been reserved for common applications, typically server applications. The port numbers assigned to these server applications have to be known by the client's transport layer and are used by the client as destination port number in message requests sent to the server applications. Clients know that servers will be listening for their requests at these reserved port numbers.\nB.2-1: Example of Well-Known port numbers used by servers.\nUser ports [1024-49151] are assigned by IANA and also used to identify server applications as for System port except that they were reserved for services that did not require privileged access.\nNOTE:\tToday, the distinction between System and User ports is not any more obvious. Operating systems may allow access to System port numbers to non-privileged services and well-known services are usually replicated on User ports (e.g. HTTP on port 8080).\nDynamic ports [49152-65535] are not assigned/allocated by IANA. They are automatically allocated by the IP stack software to be used as source port of an outgoing IP message. These port numbers are used by clients to identify the internal process sending the message and the receiver can simply reply to the client by using the received source port number as destination port number in the reply sent to the client. The port allocations are temporary and only valid for the duration of the communication session. After completion (or timeout) of the communication session, the ports become available for reuse, although most IP stacks will usually not reuse that port number until the entire pool of ephemeral ports have been used. So, if the client program reconnects, it will be assigned a different ephemeral port number for its side of the new connection.\nB2-2: Dynamic port numbers used by clients.\nEven if not recommended, Dynamic Port numbers may also be used to temporary identify a server application in a node. This implies that:\n-\tThe client has a mean to discover the port allocated to the server at run-time.\n-\tThe dynamic port assigned to the service cannot be reused by a client program in the same node as long as the port needs to be used as listening port by the service.\nB.3\tService identified by port number not assigned by IANA\nNot all the services need assigned port numbers. Any service can use:\n-\tAny unassigned port in the System and User port ranges\n-\tAny port number from the Dynamic port range.\n-\tPort numbers assigned to another protocol if this protocol is not used e.g. ports assigned to the Service Location Protocol (SLP) can be reused by any service if this service is not deployed in a private network and there is then no risk of conflict.\nServices assigned with System/User ports by IANA may also use unassigned ports to reduce the impact of potential attacks on the well-known ports and then be more securely operated. For instance, a node that provides an HTTP interface for internal management will likely use another port that the port 80.\nFor port numbers picked in the Dynamic port range to identify a service application, there is a need to ensure that this port will not be re-allocated to another client program in the same node to avoid conflict. Mechanisms to achieve such a \"long-lived\" port assignment of dynamic port include:\n-\tConfigure the range of dynamic ports that can be dynamically assigned by the IP stack: the range defined by IANA is [49152-65535] but IP stacks can usually be tuned to use another range, e.g. [32768-60999]. This implies that port numbers outside this range can be used as listening ports by servers, including ports normally considered as \"dynamic ports\" by IANA.\n-\tWhen booting the node, start all services before any other process start and begin establishing connections. Therefore, all the servers can be assigned with any available port from the unassigned ports in System/User port range or any port from the Dynamic port range. Then a client program will only be able to use remaining port numbers in the dynamic port range and no conflict will happen.\nWhen the port used to identify a service is not assigned by IANA, the clients have to discover the destination port to use when sending a request. As indicated in the IETF RFC 6335 [2], possible discovery mechanisms include:\n-\tExplicit configuration of both endpoints;\n-\tInternal mechanisms within the same host (e.g. a configuration file, indicated within a URI or using interprocess communication);\n-\tInformation provided by another service e.g. FTP, SIP, etc.;\n-\tRelying on specific service names and use of existing port discovery services defined by IETF: mDNS as defined in IETF RFC 6762 [8], DNS-based Service Discovery defined in IETF RFC 6763 [6], etc. Service names can be simply registered by IANA on a \"first-come, first-served\" basis in a namespace much larger than the port number range.\nAnnex C:IANA procedures for Service Name and Port Number registry management\nC.1\tGeneral principles\nIANA is responsible for the management and maintenance of service name and port number registry. Because assigned port numbers are a limited resource that is globally shared by the entire Internet community, the conservation of the port space is the key priority of IANA when addressing port number assignment request. IANA strives to limit assigned port number consumption and promotes the use of alternate solutions for service identification, such as explicit configuration of both endpoints, the use of service names and dynamic ports along with service discovery mechanism, in-band port negotiation and/or application layer service multiplexing.\nAnother priority is to allocate port primarily to applications used on the Internet.\nIANA assigns port numbers so that Internet endpoints do not need pairwise, explicit coordination of the meaning of their port numbers. This is the primary reason for requesting port number assignment by IANA -- to have a common agreement between all endpoints on the Internet as to the default meaning of a port number, which provides the endpoints with a default port number for a particular protocol or service.\nC.2\tAssignment Procedure\nAs described in the IETFC RFC 6335 [2], a service name or port number assignment request sent to IANA contains the following information:\nTable C.2-1: Service Name/port number assignment request form\nField\nRequired/optional\nDescription\nService Name\nRequired\nUnique service name for the service associated with the assignment request. The name MUST be compliant with the syntax defined in clause 5.1 of IETF RFC 6335 [2] (NOTE)\nTransport Protocol(s)\nRequired\nTCP, UDP, SCTP, and/or DCCP. It is required even if the request is only for service name assignment\nAssignee\nRequired\nName and email address of the organization, company or individual person responsible for the initial assignment.\nContact\nRequired\nName and email address of the Contact person for the assignment\nDescription\nRequired\nShort description of the service associated with the assignment request\nReference\nRequired\nA description of (or a reference to a document describing) the protocol or application using this port.\nPort Number\nOptional\nSuggested port number or port range (user or system)\nService Code\nOptional\nRequired only for DCCP\nKnown Unauthorized Uses\nOptional\nKnown/reported unauthorized uses by applications or organizations who are not the Assignee\nAssignment Notes\nOptional\nIndications of owner/name change, or any other assignment process issue\nNOTE:\tFor 3GPP defined service names, the name shall be prefixed by \"3gpp-\"\nWhen receiving the assignment request, IANA will follow the one of the procedures described in the following clause.\nC.3\tIANA Policies for Port Number assignment\nWhen IANA receives an assignment request that is only requesting service name, IANA will usually assign the service name under a simple \"First Come First Served\" policy defined in IETF RFC 5226 [14]\nWhen IANA receives an assignment request that is requesting a port number, IANA will initiate an \"IETF Review\" or \"IESG Approval\" procedures or an \"Expert Review\" procedure defined in IETF RFC 5226 [14], depending on the requested port range:\n-\tPorts in the Dynamic Ports range (49152-65535) cannot be assigned through IANA. A port number in that range MUST NOT be used as a service identifier.\n-\tPorts in the User Ports range (1024-49151) will be assigned under the \"IETF Review\" or \"IESG Approval\" procedures defined in IETF RFC 5226 [14] for IETF protocol. In other cases, the requester must input the documentation to the \"Expert Review\" procedure defined in IETF RFC 5226 [14], by which IANA will have a technical expert review the request to determine whether to grant the assignment. The submitted documentation MUST explain why using a port number in the Dynamic Ports range is unsuitable for the given application.\n-\tPorts in the System Ports range (0-1023) will only be assigned under the \"IETF Review\" or \"IESG Approval\" procedures defined in IETF RFC 5226 [14]. A request for a System Port number MUST document *both* why using a port number from the Dynamic Ports range is unsuitable *and* why using a port number from the User Ports range is unsuitable for that application.\nC.4\tRecommendations to designers of application and service protocols\nUsed as companion document of the IETF RFC 6335 [2], the IETF RFC 7605 [3] provides recommendations to designers of application and service protocols on how to use the transport protocol port number space and when to request a port assignment from IANA.\nFirst, a set of questions is given to help designers to check whether a port number assignment is deemed required for a given service application. These questions are listed hereafter:\n-\tIs this really a new service or could an existing service suffice?\n-\tIs this an experimental service [RFC3692]? If so, consider using the current experimental ports [RFC2780].\n-\tIs this service independently useful?  Some systems are composed from collections of different service capabilities, but not all component functions are useful as independent services. Port numbers are typically shared among the smallest independently useful set of functions. Different service uses or properties can be supported in separate pairwise endpoint associations after an initial negotiation, e.g., to support software decomposition.\n-\tCan this service use a Dynamic port number that is coordinated out-of-band? For example:\n-\tBy explicit configuration of both endpoints.\n-\tBy internal mechanisms within the same host (e.g., a configuration file, indicated within a URI or using interprocess communication).\n-\tUsing information exchanged on a related service: FTP [RFC959], SIP [RFC3261], etc.\n-\tUsing an existing port discovery service: portmapper [RFC1833], mDNS [RFC6762] [RFC6763], etc.\nMoreover, a set of recommendations and requirements for registration and use of port is provided to help designers to determine whether a port number assignment is required. These recommendations and requirements are provided for information hereafter:\n-\tEach assigned port requested MUST be justified by the applicant as an independently useful service.\n-\tDevelopers SHOULD NOT apply for System port number assignments because the increased privilege they are intended to provide is not always enforced.\n-\tSystem implementers SHOULD enforce the need for privilege for processes to listen on System port numbers.\n-\tNew services SHOULD support security capabilities, either directly or via a content protection such as TLS [RFC5246] or Datagram TLS (DTLS) [RFC6347], or transport protection such as the TCP-AO [RFC5925]. Insecure versions of new or existing secure services SHOULD be avoided because of the new vulnerability they create.\n-\tWhen requesting both secure and insecure port assignments for the same service, justification is expected for the utility and safety of each port as an independent service (clause 6).  Precedent (e.g., citing other protocols that use a separate insecure port) is inadequate justification by itself.\n-\tSecurity SHOULD NOT rely on assigned port number distinctions alone; every service, whether secure or not, is likely to be attacked.\n-\tVersion support SHOULD be included in new services rather than relying on different port number assignments for different versions.\n-\tVersion numbers SHOULD NOT be included in either the service name or service description, to avoid the need to make additional port number assignments for future variants of a service.\n-\tService names and descriptions for multiple transport port number assignments SHOULD match only when they describe the same service, excepting only enhancements for each supported transport.\n-\tNames of discovery services SHOULD use an identifiable suffix; the suggestion is \"-disc\".\n-\tUDP over IPv4 multi-host services SHOULD use multicast rather than broadcast.\n-\tServices that use multipoint communication SHOULD be scalable and SHOULD NOT rely solely on the efficiency of multicast transmission for scalability.\n-\tServices SHOULD NOT use UDP as a performance enhancement over TCP, e.g., to circumnavigate TCP's congestion control.\n-\tUsers MUST NOT deploy implementations that use assigned port numbers prior their assignment by IANA.\n-\tUsers MUST NOT deploy implementations that default to using the experimental System port numbers (1021 and 1022 [RFC4727]) outside a controlled environment where they can be updated with a subsequent assigned port [RFC3692].\n-\tUsers writing specifications SHOULD use symbolic names for port numbers and service names until an IANA assignment has been completed.  Implementations SHOULD use experimental port numbers during this time, but those numbers MUST NOT be cited in documentation except as interim.\nC.5\t3GPP port assignment applications since 2009\nIETF RFC 6335 [2] was published in 2011 to update IANA's procedures by obsoleting the previous UDP and TCP port assignment procedures. Before that, the principles for service name and port number management were based on a set of informal guidelines developed based on the review experience from previous assignment request and never publicly documented. Port numbers were managed informally, and sometimes inconsistently and arbitrarily e.g., some services were assigned ranges of many port numbers even where not strictly necessary.\nPublished in 2015, IETF RFC 7605 [3] provides additional information to designers on how to use assigned port numbers that complements the IANA process described in IETF RFC 6335 [2].\nWhereas the conditions of port assignment have been further clarified and reinforced based on the conservation principle, it seems that 3GPP did not really appraise the policy change and did not modify accordingly their use of port numbers in 3GPP systems. The port number assignment was recently still considered as a by default solution for service identification even if other solutions were applicable.\nTable C.5-1 hereafter lists the port numbers assigned to 3GPP since 2009. In this table, it can be noticed that most of the applications were for SCTP and protocols only inside 3GPP networks, without inter-domain interfaces.\nTable C.5-1: Service Name/port number assigned to 3GPP since 2009\nService Name\nPort Number\nTransport Protocol\nDescription\nRegistration Date\nIntra/Inter\nsgsap\n29118\nsctp\nSGsAP\n11/06/2009\nIntra (MME/MSC)\nsbcap\n29168\nsctp\nSBcAP\n11/06/2009\nIntra (MME/CBC)\ns102\n23272\nudp\nS102 application\n26/08/2009\nIntra (1xCS IWS/MME)\ns1-control\n36412\nsctp\nS1-Control Plane\n01/09/2009\nIntra (MME/eNB)\nx2-control\n36422\nsctp\nX2-Control Plane\n01/09/2009\nIntra (eNB/eNB)\niuhsctpassoc\n29169\nsctp\nHNBAP and RUA Common Association\n08/09/2009\nInter (HNB/HNB-GW)\n3gpp-cbsp\n48049\ntcp\nCell Broadcast Service Protocol\n07/12/2009\nIntra (BSC/CBC)\nlcs-ap\n9082\nsctp\nLCS Application Protocol\n04/06/2010\nIntra (MME/E-SMLC)\nwlcp\n36411\nudp\nWireless LAN Control plane Protocol (WLCP)\n14/11/2014\nIntra (UE/TWAG)\nslmap\n36423\nsctp\nSLm Interface Application Protocol\n18/06/2015\nIntra (E-SMLC/LMU)\nnq-ap\n36424\nsctp\nNq/Nq' Application Protocol\n18/06/2015\nIntra (the RCAF/MME or SGSN)\nxw-control\n36462\nsctp\nXw-Control Plane\n13/11/2015\nIntra (eNB/WT)\npfcp\n8805\nudp\nDestination Port number for PFCP\n08/05/2017\nIntra (CU/UP)\nng-control\n38412\nsctp\nNG Control Plane\n18/05/2017\nIntra (gNB/ng-eNB-AMF)\nxn-control\n38422\nsctp\nXn Control Plane\n18/05/2017\nIntra (gNB-gNB/ng-eNB)\nf1-control\n38472\nsctp\nF1 Control Plane\n23/06/2017\nIntra (gNBCU/gNBDU)\ne1-interface\n38462\nsctp\nE1 signalling transport\n06/11/2018\nIntra (gNB-CU-CP/gNB-CU-UP)\n3gpp-monp\n8809\nudp\nMCPTT Off-Network Protocol (MONP)\n15/04/2019\nIntra (MCPTT client/MCPTT client)\n3gpp-w1ap\n37472\nsctp\nW1 signalling transport\n16/07/2020\nIntra (ng-eNB-DU/ng-eNB-CU\nSince 2015, IANA had gradually warned 3GPP that a solution should be found to avoid port assignments for protocols only used in 3GPP. Exceptions were made at the beginning and the last requests were granted by IESG only at the conditions that it was the last one(s). Now, it is clear that application for a new port will not be granted without a strong justification for it, only if the recommendations given in IETF RFC 7605 [3] have been carefully followed and it is proved that there is no other solution than port assignment for service port discovery.\nAnnex D:Change history\nChange history\nDate\nMeeting\nTDoc\nCR\nRev\nCat\nSubject/Comment\nNew version\n2020-09\nCT4#101e\nC4-205007\nSkeleton\n0.0.0\n2020-11\nCT4#101e\nC4-205774\nC4-205481 was incorporated.\n0.1.0\n2021-04\nCT4#103e\nC4-212403\nC4-212403 was implemented, which updates the skeleton\n0.1.1\n2021-04\nCT4#103e\nC4-212591\nThe following pCRs were implemented:  C4-212402, C4-212404, C4-212405, C4-212406.\n0.2.0\n2021-05\nCT4#104e\nC4-213521\nThe following pCRs were implemented:  C4-213024, C4-213025, C4-213026, C4-213027, C4-213039, C4-2133365.\n0.3.0\n2021-06\nCT#92e\nCP-211086\nTR presented for information\n1.0.0\n2021+06\nCT'92e\nCP-211339\nPresentation sheet updated\n1.0.1\n2021-08\nCT4#105e\nC4-314748\nThe following pCRs were implemented:  C4-214038, C4-214053, C4-214054, C4-214055, C4-214056, C4-214542, C4-214579 and C4-214745.\n1.1.0\n2021-10\nCT4#106e\nC4-315511\nThe following pCRs were implemented: C4-215343, C4-215499.\n1.2.0\n2021-11\nCT4#107e\nC4-316464\nThe following pCR was implemented: C4-216017.\n1.3.0\n2021-12\nCT#94e\nCP-213151\nV2.0.0 presented for approval\n2.0.0\n2021-12\nCT#94e\nV17.0.0 published after CT#94\n17.0.0\n2022-03\nCT#95e\n0001\n1\nF\nMoving Annex D into new TS\n17.1.0\n2022-06\nCT#96\nCP-221027\n0002\n-\nD\nEditorial corrections\n17.2.0\n2024-03\n-\n-\n-\n-\n-\nUpdate to Rel-18 version (MCC)\n18.0.0",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.4",
        "clause_8.1.2",
        "clause_6",
        "clause_5.1",
        "ts_29.641",
        "ts_17.1"
      ]
    }
  ]
}