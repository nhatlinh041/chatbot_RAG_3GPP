{
  "metadata": {
    "specification_id": "ts_29.573",
    "version": "18.10.0",
    "title": "3GPP TS 29.573",
    "file_path": "/content/drive/MyDrive/RAG_thesis/data/29_series/29573-ia0/29573-ia0.docx"
  },
  "export_info": {
    "export_date": "2025-07-26T09:03:19.879702",
    "total_chunks": 168
  },
  "chunks": [
    {
      "chunk_id": "ts_29.573_1",
      "section_id": "1",
      "section_title": "Scope",
      "content": "The present document specifies the stage 3 protocol and data model for the PLMN and/or SNPN interconnection Interface. It provides stage 3 protocol definitions and message flows, and specifies the APIs for the procedures on the PLMN interconnection interface (i.e N32).\nThe 5G System stage 2 architecture and procedures are specified in 3GPP TS 23.501 [2] and 3GPP TS 23.502 [3].\nThe Technical Realization of the Service Based Architecture and the Principles and Guidelines for Services Definition are specified in 3GPP TS 29.500 [4] and 3GPP TS 29.501 [5].\nThe stage 2 level N32 procedures are specified in 3GPP TS 33.501 [6].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.501",
        "ts_23.502",
        "ts_29.500",
        "ts_29.501",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_2",
      "section_id": "2",
      "section_title": "References",
      "content": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non‑specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 23.501: \"System Architecture for the 5G System; Stage 2\".\n[3]\t3GPP TS 23.502: \"Procedures for the 5G System; Stage 2\".\n[4]\t3GPP TS 29.500: \"5G System; Technical Realization of Service Based Architecture; Stage 3\".\n[5]\t3GPP TS 29.501: \"5G System; Principles and Guidelines for Services Definition; Stage 3\".\n[6]\t3GPP TS 33.501: \"Security architecture and procedures for 5G system\".\n[7]\tIETF RFC 9113: \"HTTP/2\".\n[8]\tIETF RFC 8259: \"The JavaScript Object Notation (JSON) Data Interchange Format\".\n[9]\tIETF RFC 9110: \"HTTP Semantics\".\n[10]\tVoid.\n[11]\tIETF RFC 793: \"Transmission Control Protocol\".\n[12]\t3GPP TS 29.571: \"5G System; Common Data Types for Service Based Interfaces Stage 3\".\n[13]\tIETF RFC 7518: \"JSON Web Algorithms (JWA)\".\n[14]\tIETF RFC 7516: \"JSON Web Encryption (JWE)\".\n[15]\tIETF RFC 4648: \"The Base16, Base32, and Base64 Data Encodings\".\n[16]\tIETF RFC 7515: \"JSON Web Signature (JWS)\".\n[17]\tIETF RFC 6901: \"JavaScript Object Notation (JSON) Pointer\".\n[18]\t3GPP TS 29.510: \"Network Function Repository Services; Stage 3\".\n[19]\t3GPP TS 23.003: \"Numbering, addressing and identification\".\n[20]\t3GPP TR 21.900: \"Technical Specification Group working methods\".\n[21]\tIETF RFC 7468: \"Textual Encodings of PKIX, PKCS, and CMS Structures\".\n[22]\tIETF RFC 9457: \"Problem Details for HTTP APIs\".\n[23]\tIETF RFC 1952: \"GZIP file format specification version 4.3\".\n[24]\tVoid\n[25]\t3GPP TS 29.518: \"5G System; Access and Mobility Management Service; Stage 3\".\n[26]\t3GPP TS 29.503: \"5G System; Unified Data Management Services; Stage 3\".\n[27]\tOpenAPI: \"OpenAPI Specification Version 3.0.0\", https://spec.openapis.org/oas/v3.0.0.\n[28]\t3GPP TS 22.261: \"Service requirements for the 5G system; Stage 1\".\n[29]\t3GPP TS 23.288: \"Architecture enhancements for 5G System (5GS) to support network data analytics services; Stage 2\".\n[30]\tGSMA PRD IR.67: \"DNS Guidelines for Service Providers and GRX and IPX Providers version 23.0\".",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905",
        "ts_23.501",
        "ts_23.502",
        "ts_29.500",
        "ts_29.501",
        "ts_33.501",
        "ts_29.571",
        "ts_29.510",
        "ts_23.003",
        "ts_21.900",
        "ts_29.518",
        "ts_29.503",
        "ts_22.261",
        "ts_23.288"
      ]
    },
    {
      "chunk_id": "ts_29.573_3.1",
      "section_id": "3.1",
      "section_title": "Definitions",
      "content": "For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\nc-SEPP: The SEPP that is present on the NF service consumer side is called the c-SEPP.\np-SEPP: The SEPP that is present on the NF service producer side is called the p-SEPP.\nNOTE:\tFor the purpose of N32-c procedures, the two interacting SEPPs are called \"initiating\" SEPP and \"responding\" SEPP. The c-SEPP and p-SEPP terminology is not used in this specification though it is used in 3GPP TS 33.501 [6].\nc-IPX: The IPX on the NF service consumer side.\np-IPX: The IPX of the NF service producer side.\nN32-c context: This context is set up at the SEPP after the Security Capability Exchange procedure is finalized. It defines the security capability that is mutually agreed and effective for both the cSEPP and the pSEPP.\nRoaming Hub: A type of Roaming Intermediary that provides a set of services to client PLMNs to facilitate the deployment and the operation of roaming and interworking services; as defined by GSMA (see clause 3.1 of 3GPP TS 33.501 [6]).\nRoaming Intermediary: an entity that provides roaming related services (see clause 3.1 of 3GPP TS 33.501 [6]).\nLeaf IE: it is a JSON attribute defined as a simple data type, an enumeration or an array of simple data type.\nNon-Leaf IE: it is a JSON attribute defined as an object (i.e. structured data type) or an array of structured data type.\nRecursive non-leaf IE: it is a non-leaf attribute defined with the same data type as one of its ancestor attributes (see examples in Annex F.3).",
      "chunk_type": "definition",
      "cross_references": [
        "ts_33.501_clause_3.1",
        "ts_21.905",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_3.2",
      "section_id": "3.2",
      "section_title": "Abbreviations",
      "content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\nGZIP\tGNU ZIP\nIPX\tIP Exchange Service\nJOSE\tJavascript Object Signing and Encryption\nJWE\tJSON Web Encryption\nJWS\tJSON Web Signature\nPRINS\tPRotocol for N32 INterconnect Security\nRI\tRoaming Intermediary\nSEPP\tSecurity and Edge Protection Proxy\nTLS\tTransport Layer Security\nUPU\tUE Parameters Update",
      "chunk_type": "general",
      "cross_references": [
        "ts_21.905"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.1",
      "section_id": "4.1",
      "section_title": "Introduction",
      "content": "This clause provides a general description of the interconnect interfaces used between the PLMNs and/or SNPNs for transporting the service based interface message exchanges.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_4.2.1",
      "section_id": "4.2.1",
      "section_title": "General",
      "content": "The N32 interface is used between SEPPs of different PLMNs for both roaming and PLMN interconnect scenarios.\nThe N32 interface may also be used between SEPPs from an SNPN and another SNPN or PLMN, for SNPN interconnect scenarios (e.g. for SNPN connectivity with a Credentials Holder network, see clause 5.30.2.9.3 of 3GPP TS 23.501 [2]). Unless specified otherwise, references to \"PLMN\" throughout this specification shall be substituted by \"SNPN\" for a SEPP that is deployed in an SNPN.\nThe SEPP that is on the NF service consumer side is called the c-SEPP and the SEPP that is on the NF service producer is called the p-SEPP. The NF service consumer or SCP may be configured with the c-SEPP or discover the c-SEPP by querying the NRF. The NF service producer or SCP may be configured with the p-SEPP or discover the p-SEPP by querying the NRF.\nThe N32 interface can be logically considered as 2 separate interfaces as given below.\n-\tN32-c, a control plane interface between the SEPPs for performing initial handshake and negotiating the parameters to be applied for the actual N32 message forwarding.\n-\tN32-f, a forwarding interface between the SEPPs which is used for forwarding the communication between the NF service consumer and the NF service producer after applying application level security protection or TLS security protection.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_23.501_clause_5.30.2.9.3",
        "ts_23.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.2.2",
      "section_id": "4.2.2",
      "section_title": "N32-c Interface",
      "content": "The following figure shows the scope of the N32-c interface.\nFigure 4.2.2-1: N32-c Interface\nThe N32-c interface provides the following functionalities:\n-\tInitial handshake procedure between the SEPP in PLMN A (called the initiating SEPP) and the SEPP in PLMN B (called the responding SEPP), that involves capability negotiation and parameter exchange as specified in 3GPP TS 33.501 [6].",
      "chunk_type": "general",
      "cross_references": [
        "figure_4.2.2-1",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.2.3",
      "section_id": "4.2.3",
      "section_title": "N32-f Interface",
      "content": "The following figures shows the scope of the N32-f interface.\nFigure 4.2.3-1a: N32-f Interface with TLS security\nFigure 4.2.3-1b: N32-f Interface with PRINS\nThe N32-f interface shall be used to forward the HTTP/2 messages of the NF service producers and the NF service consumers in different PLMN, through the SEPPs of the respective PLMN.\nIf TLS is the negotiated security policy between the SEPP, then the N32-f shall involve only the forwarding of the HTTP/2 messages of the NF service producers and the NF service consumers without any reformatting at the SEPPs and/or the IPXs (see figure 4.2.3-1a).\nThe application layer security protection functionality of the N32-f is used only if the PRotocol for N32 INterconnect Security (PRINS) is negotiated between the SEPPs using N32-c (see figure 4.2.3-1b).\nThe N32-f interface provides the following application layer security protection functionalities:\n-\tMessage protection of the information exchanged between the NF service consumer and the NF service producer across PLMNs by applying application layer security mechanisms as specified in 3GPP TS 33.501 [6].\n-\tForwarding of the application layer protected message from a SEPP in one PLMN to a SEPP in another PLMN. Such forwarding may involve RIs on path.\n-\tIf RIs are on the path from SEPP in PLMN A to SEPP in PLMN B, the forwarding on the N32-f interface may involve the insertion of content modification instructions which the receiving SEPP applies after verifying the integrity of such modification instructions.",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_4.2.3-1",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.3.1",
      "section_id": "4.3.1",
      "section_title": "General",
      "content": "The protocol stack for the N32 interface is shown below in Figure 4.3.1-1.\nFigure 4.3.1-1: N32 Protocol Stack\nThe N32 interfaces (N32-c and N32-f) use HTTP/2 protocol (see clause 4.2.2 and 4.2.3, respectively) with JSON (see clause 4.2.4) as the application layer serialization protocol. For the security protection at the transport layer, the SEPPs shall support TLS as specified in clause 13.1.2 of 3GPP TS 33.501 [6].\nFor the N32-f interface, the application layer (i.e the JSON content) encapsulates the complete HTTP/2 message between the NF service consumer and the NF service producer, by transforming the HTTP/2 headers and the body into specific JSON attributes as specified in clause 6.2. For the scenarios when there are RIs between SEPPs, see clause 4.3.2 for TLS/PRINS usage.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.2.2",
        "clause_4.2.4",
        "ts_33.501_clause_13.1.2",
        "clause_6.2",
        "clause_4.3.2",
        "figure_4.3.1-1",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.3.2.1",
      "section_id": "4.3.2.1",
      "section_title": "General",
      "content": "HTTP/2 as described in IETF RFC 9113 [7] shall be used for N32 interface.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_4.3.2.2",
      "section_id": "4.3.2.2",
      "section_title": "HTTP standard headers",
      "content": "The HTTP request standard headers and the HTTP response standard headers that shall be supported on the N32 interface are defined in Table 4.3.2.2-1 and in Table 4.3.2.2-2 respectively.\nTable 4.3.2.2-1: Mandatory to support HTTP request standard headers\nName\nReference\nDescription\nAccept\nIETF RFC 9110 [9]\nThis header is used to specify response media types that are acceptable.\nAccept-Encoding\nIETF RFC 9110 [9]\nThis header may be used to indicate what response content-encodings (e.g gzip) are acceptable in the response.\nContent-Length\nIETF RFC 9110 [9]\nThis header is used to provide the anticipated size, as a decimal number of octets, for a potential content.\nContent-Type\nIETF RFC 9110 [9]\nThis header is used to indicate the media type of the associated representation.\nVia\nIETF RFC 9110 [9]\nThis header is used to indicate the intermediate proxies in the service request path. Please refer to clause 6.10.8 of 3GPP TS 29.500 [4] for encoding of the via header\nTable 4.3.2.2-2: Mandatory to support HTTP response standard headers\nName\nReference\nDescription\nContent-Length\nIETF RFC 9110 [9]\nThis header may be used to provide the anticipated size, as a decimal number of octets, for a potential content.\nContent-Type\nIETF RFC 9110 [9]\nThis header shall be used to indicate the media type of the associated representation.\nContent-Encoding\nIETF RFC 9110 [9]\nThis header may be used in some responses to indicate to the HTTP/2 client the content encodings (e.g gzip) applied to the response body beyond those inherent in the media type.\nVia\nIETF RFC 9110 [9]\nThis header is used to indicate the intermediate proxies in the service response path. Please refer to clause 6.10.8 of 3GPP TS 29.500 [4] for encoding of the via header.\nServer\nIETF RFC 9110 [9]\nThis header is used to indicate the originator of an HTTP error response.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_6.10.8",
        "table_4.3.2.2-1",
        "table_4.3.2.2-2",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.3.2.3",
      "section_id": "4.3.2.3",
      "section_title": "HTTP custom headers",
      "content": "The HTTP custom headers specified in clause 5.2.3 of 3GPP TS 29.500 [4] shall be supported on the N32 interface.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_5.2.3",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.3.2.4",
      "section_id": "4.3.2.4",
      "section_title": "HTTP/2 connection management",
      "content": "Each SEPP initiates HTTP/2 connections towards its peer SEPP for the following purposes\n-\tN32-c interface\n-\tN32-f interface\nThe scope of the HTTP/2 connection used for the N32-c interface is short-lived. Once the initial handshake is completed the connection is torn down as specified in 3GPP TS 33.501 [6]. The HTTP/2 connection used for N32-c is end to end between the SEPPs and does not involve an RI to intercept the HTTP/2 connection, though an RI may be involved for IP level routing.\nNOTE:\tRoaming Hubs as Roaming Intermediaries may disallow the establishment of the N32-c connection (see clause 5.5.2).\nThe scope of the HTTP/2 connection used for the N32-f interface is long-lived. The N32-f HTTP/2 connection at a SEPP can be:\n-\tCase A: Towards a SEPP of another PLMN without involving any RI or involving RI where RI does not require modification or observation of the information; or\n-\tCase B: Towards a SEPP of another PLMN via RI where RI requires modification or observation of the information. In this case, the HTTP/2 connection from a SEPP terminates at the next hop RI with the RI acting as a HTTP proxy.\nFor the N32-f interface the HTTP/2 connection management requirements specified in clause 5.2.6 of 3GPP TS 29.500 [4] shall be applicable. The URI scheme used for the N32-f JOSE protected message forwarding API shall be \"http\". If confidentiality protection of all IEs for the N32-f JOSE protected message forwarding procedure is required, then:\n-\tFor case A, the security between the SEPPs shall be ensured by means of an IPSec or TLS connection;\n-\tFor case B, hop-by-hop security between the SEPP and the RIs should be established on N32-f. This hop-by-hop security shall be established using an IPSec or TLS connection.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.5.2",
        "ts_29.500_clause_5.2.6",
        "ts_33.501",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.3.3",
      "section_id": "4.3.3",
      "section_title": "Transport Protocol",
      "content": "The Transmission Control Protocol as described in IETF RFC 793 [11] shall be used as transport protocol as required by HTTP/2 (see IETF RFC 9113 [7]).\nWhen there is no RI between the SEPPs or RI(s) are offering only IP routing service without modification or observation of the content, TLS shall be used for security protection (see clause 13.1.2 of 3GPP TS 33.501 [6]). When there is RI between the SEPPs and RI requires modification or observation of the content, TLS or NDS/IP should be used for security protection as specified in clause 13.1.2 of 3GPP TS 33.501 [6].\nNOTE:\tWhen using TCP as the transport protocol, an HTTP/2 connection is mapped to a TCP connection.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_33.501_clause_13.1.2",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_4.3.4",
      "section_id": "4.3.4",
      "section_title": "Serialization Protocol",
      "content": "The JavaScript Object Notation (JSON) format as described in IETF RFC 8259 [8] shall be used as the serialization protocol.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_5.1",
      "section_id": "5.1",
      "section_title": "Introduction",
      "content": "The procedures on the N32 interface are split into two categories:\n-\tProcedures that happen end to end between the SEPPs on the N32-c interface;\n-\tProcedures that are used for the forwarding of messages on the service based interface between the NF service consumer and the NF service producer via the SEPP across the N32-f interface.\nTable 5.1-1 summarizes the corresponding APIs defined for this specification.\nTable 5.1-1: API Descriptions\nService Name\nClause\nDescription\nOpenAPI Specification File\napiName\nAnnex\nN32 Handshake\n6.1\nN32-c Handshake Service\nTS29573_N32_Handshake.yaml\nn32c-handshake\nA.2\nJOSE Protected Message Forwarding\n6.2\nN32-f Message Forwarding Service\nTS29573_JOSEProtectedMessageForwarding.yaml\nn32f-forward\nA.3\nNsepp_Telescopic_FQDN_Mapping\n6.3\nSEPP Telescopic FQDN Mapping\nTS29573_SeppTelescopicFqdnMapping.yaml\nnsepp-telescopic\nA.4",
      "chunk_type": "general",
      "cross_references": [
        "table_5.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.2.1",
      "section_id": "5.2.1",
      "section_title": "General",
      "content": "The N32 handshake procedure is used between the SEPPs in two PLMNs to mutually authenticate each other and negotiate the security mechanism to use over N32-f along with associated security configuration parameters.\nA HTTP/2 connection shall be established between the initiating SEPP and the responding SEPP end to end over TLS. The following N32 handshake procedures are specified in the clauses below.\n-\tSecurity Capability Negotiation Procedure\n-\tParameter Exchange Procedure\n-\tN32-f Context Termination Procedure\n-\tN32-f Error Reporting Procedure",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_5.2.2",
      "section_id": "5.2.2",
      "section_title": "Security Capability Negotiation Procedure",
      "content": "The initiating SEPP shall initiate a Security Capability Negotiation procedure towards the responding SEPP to agree on a security mechanism to use for protecting NF service related signalling over N32-f. An end to end TLS connection shall be setup between the SEPPs before the initiation of this procedure. This procedure may also be used to tear down the N32-f TLS connection if the remote SEPP indicated support of the feature NFTLST during the setup of the N32-c connection. The procedure is described in Figure 5.2.2-1 below.\nFigure 5.2.2-1: Security Capability Negotiation Procedure\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecNegotiateReqData\" IE carrying the following information:\n-\tSupported security capabilities (i.e., PRINS and/or TLS);\n-\tWhether the 3gpp-Sbi-Target-apiRoot HTTP header is supported, if TLS security is supported;\n-\tSender PLMN ID(s) or SNPN ID(s);\n-\tTarget PLMN ID or SNPN ID;\n-\tPurpose of the intended usage of N32 connection;\n-\tThe senderN32fFqdn IE, if both the initiating SEPP and the responding SEPP support the SNDN32F feature and the initiating SEPP wishes the responding SEPP to establish the N32-f connection towards a specific FQDN (of the initiating SEPP);\n-\tThe senderN32fPortList IE, if both the initiating SEPP and the responding SEPP support the SNDN32F feature and the initiating SEPP wishes the responding SEPP to establish the N32-f connection using a specific port number. When present, the list shall contain one port number per supported security capability (i.e., PRINS and/or TLS);\n-\tThe n32HandshakeId IE, if the N32 handshake identifier is supported by the initiating SEPP, that may be used to correlate the N32-f connection to the parent N32-c context for TLS security (see clause 5.3.3.2). If the responding SEPP supports the N32 handshake identifier, the responding SEPP shall include the received N32 handshake identifier in TLS protected message forwarding procedure via correlated N32-f connection(s) towards the initiating SEPP and the subsequent N32-c signaling request related to this N32-c context (e.g. to request to tear down the N32-f TLS connection).\n-\tThe n32KeepaliveTimer IE, if the initiating SEPP wishes to indicate for how long it maintains the N32-f connection in the absence of incoming traffic (see clause 5.3.3.5).\nIf different PLMNs or SNPNs are represented by different PLMN IDs or SNPN IDs (respectively) supported by a SEPP, then the SEPP shall use separate N32-connections for each pair of local and remote PLMN or SNPN. Both SEPPs shall store the mapping between the N32 connections and their pair of PLMN IDs or SNPN IDs.\nNOTE 1:\tIf SEPPs support separate FQDN per PLMN or SNPN, then Target PLMN Id or Target SNPN Id is not required as target PLMN or SNPN can be selected by the FQDN.\nTo tear down the N32-f connection when negotiated security scheme is TLS, the \"SecNegotiateReqData\" IE shall contain:\n-\tSupported security capability set to \"NONE\"\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains \"SecNegotiateRspData\" IE carrying the following information:\n-\tSelected security capability (i.e., PRINS or TLS);\n-\tWhether the 3gpp-Sbi-Target-apiRoot HTTP header is supported, if TLS security is selected;\n-\tSender PLMN ID(s) or SNPN ID(s).\n-\tPurpose of the accepted usage of N32 connection.\n-\tThe senderN32fFqdn IE, if the responding SEPP wishes the initiating SEPP to establish the N32-f connection towards a specific FQDN (of the responding SEPP).\n-\tThe senderN32fPort IE, if the responding SEPP wishes the initiating SEPP to establish the N32-f connection using a specific port number.\n-\tThe n32HandshakeId IE, if the N32 handshake identifier was received in the request and the responding SEPP supports the N32 handshake identifier. The initiating SEPP shall include the received N32 handshake identifier in TLS protected message forwarding procedure via correlated N32-f connection(s) towards the responding SEPP and the subsequent N32-c signaling request related to this N32-c context (e.g. to request to tear down the N32-f TLS connection).\n-\tThe n32KeepaliveTimer IE, if the responding SEPP wishes to indicate for how long it maintains the N32-f connection in the absence of incoming traffic (see clause 5.3.3.5).\nNOTE 2:\tSame SEPP endpoints can serve all accepted purposes over the same N32-f connection established as the result of request/response messages.\nThe responding SEPP compares the initiating SEPP's supported security capabilities to its own supported security capabilities and selects, based on its local policy, a security mechanism, which is supported by both the SEPPs. If the selected security capability indicates any other capability other than PRINS, then the HTTP/2 connection initiated between the two SEPPs for the N32 handshake procedures shall be terminated. The negotiated security capability shall be applicable on both the directions. If the selected security capability is PRINS, then the two SEPPs may decide to create (if not available) / maintain HTTP/2 connection(s) where each SEPP acts as a client towards the other (which acts as a server). This may be used for later signalling of N32-f error reporting procedure (see clause 5.2.5) and N32-f context termination procedure (see clause 5.2.4).\nIf different PLMNs or SNPNs are represented by different PLMN IDs or SNPN IDs (respectively) supported by a SEPP, then the SEPP shall use separate N32-connections for each pair of local and remote PLMN or SNPN. Both SEPPs shall store the mapping between the N32 connections and their pair of PLMN IDs or SNPN IDs.\nThe SEPP shall select the PLMN or SNPN from the list of supported PLMN(s) or SNPN(s) based on the received Target PLMN ID or SNPN ID, or based on PLMN or SNPN specific FQDN used in the request, and provide the selected PLMN's PLMN Id(s) in the plmnIdList or the selected SNPN's SNPN Id(s) in the snpnIdList.\nIn case no purposes are exchanged, the receiving SEPP shall assume by default that purposes are for Roaming and inter-PLMN mobility as described in clause 6.1.5.3.9.\nThe initiating SEPP and/or responding SEPP may enable the establishment of an N32 connection for the purpose of Disaster Roaming only during disaster conditions.\nWhen the request is for tearing down the existing N32-f TLS connection, the \"SecNegotiateRspData\" IE shall contain:\n-\tSupported security capability set to \"NONE\"\nand, subsequently, both SEPP shall terminate the N32-c and N32-f TLS connection.\nIf the initiating SEPP receives the indication that the responding SEPP supports the feature SNDN32F in the response, the initiating SEPP shall consider that the responding SEPP supports and has accepted the senderN32fFqdn IE and/or senderN32fPortList sent by the initiating SEPP in the request message. Otherwise, the initiating SEPP shall consider that the responding SEPP has ignored the senderN32fFqdn IE and/or senderN32fPortList sent by the initiating SEPP. If the initiating SEPP supports the feature SNDN32F and receives the senderN32fFqdn IE and/or the senderN32fPort IE from the responding SEPP, the initiating SEPP shall establish the N32-f connection towards the responding SEPP using the received N32-f FQDN and/or the senderN32fPort IE.\nIf the responding SEPP receives the indication that the initiating SEPP supports the feature SNDN32F in the request, the responding SEPP shall consider that the initiating SEPP supports receiving the senderN32fFqdn IE and/or senderN32fPort from the responding SEPP in the response message. Otherwise, the responding SEPP shall consider that the initiating SEPP does not support the senderN32fFqdn IE and/or senderN32fPort, and the responding SEPP shall not send these attributes to initiating SEPP. If the responding SEPP supports the feature SNDN32F and receives the senderN32fFqdn IE and/or the senderN32fPortList IE from the initiating SEPP, the responding SEPP shall establish the N32-f connection towards the initiating SEPP using the received N32-f FQDN and/or the N32-f port number received in the senderN32fPortList IE corresponding to the selected security capability (i.e., TLS or PRINS).\nIf the N32-f context exists between the peer SEPPs, and the N32 exchange capability request is not for tearing down the N32-f connections, the responding SEPP shall:\n-\tstop sending any further messages over the N32-f towards the initiating SEPP;\n-\tdelete the current N32-f context and terminate any N32-f connection with the initiating SEPP; and\n-\tprocess the received exchange capability request.\n2b.\tOn failure or redirection, the responding SEPP shall respond to the initiating SEPP with an appropriate status code as specified in clause 6.1.4.2.\nIf the responding SEPP has sent an outgoing Security Capability Negotiation request to the initiating SEPP, the responding SEPP shall compare the FQDN of the initiating SEPP that has been received in the incoming Security Capability Negotiation request message with the FQDN of the responding SEPP that has been sent in the outgoing Security Capability Negotiation request. If the responding SEPP's FQDN lexicographically precedes, it shall reject the incoming HTTP request message with the cause \"N32C_EXCHANGE_CAPABILITY_ONGOING\" and it shall continue with its initiated procedure and vice versa.\nEXAMPLE: assuming SEPP A's FQDN is \"sepp.5gc.mnc345.mcc012.3gppnetwork.org\" and SEPP B's FQDN is \"sepp.5gc.mnc346.mcc012.3gppnetwork.org\", then SEPP A's FQDN precedes SEPP B's FQDN and SEPP A proceeds with its exchange capability procedure.\nA SEPP may be configured to accept an HTTP request from a given PLMN and not to send an HTTP request for exchange capability towards that PLMN.",
      "chunk_type": "procedure",
      "cross_references": [
        "clause_5.3.3.2",
        "clause_5.3.3.5",
        "clause_5.2.5",
        "clause_5.2.4",
        "clause_6.1.5.3.9",
        "clause_6.1.4.2",
        "figure_5.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.2.3.1",
      "section_id": "5.2.3.1",
      "section_title": "General",
      "content": "The parameter exchange procedure shall be executed if the security capability negotiation procedure selected the security capability as PRINS. The parameter exchange procedure is performed to:\n-\tAgree on a cipher suite to use for protecting NF service related signalling over N32-f; and\n-\tOptionally, exchange the protection policies to use for protecting NF service related signalling over N32.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_5.2.3.2",
      "section_id": "5.2.3.2",
      "section_title": "Parameter Exchange Procedure for Cipher Suite Negotiation",
      "content": "The parameter exchange procedure for cipher suite negotiation shall be performed after the security capability negotiation procedure if the selected security policy is PRINS. If there is a change in the cipher suite and the SEPP wants to renegotiate it, then the SEPP may reuse the parameter exchange procedure to override what was exchanged before.\nThe procedure is described in Figure 5.2.3.2-1 below.\nFigure 5.2.3.2-1: Parameter Exchange Procedure for Cipher Suite Negotiation\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecParamExchReqData\" IE carrying the following information\n-\tSupported cipher suites;\nThe supported cipher suites shall be an ordered list with the cipher suites mandated by 3GPP TS 33.501 [6] appearing at the top of the list.\nThe initiating SEPP also provides a N32-f context identifier for the responding SEPP to use towards the initiating SEPP for subsequent JOSE Protected Message Forwarding procedures over N32-f (see clause 5.3.3) when the responding SEPP acts as the forwarding SEPP.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the following information\n-\tSelected cipher suite\nThe responding SEPP compares the initiating SEPP's supported cipher suites to its own supported cipher suites and selects, based on its local policy, a cipher suite, which is supported by both the SEPPs. The responding SEPP's supported cipher suites shall be an ordered list with the cipher suites mandated by 3GPP TS 33.501 [6] appearing at the top of the list. The selected cipher suite is applicable for both the directions of communication between the SEPPs.\nThe responding SEPP also provides a N32-f context identifier for the initiating SEPP to use towards the responding SEPP for subsequent JOSE Protected Message Forwarding procedures over N32-f (see clause 5.3.3) when the initiating SEPP acts as the forwarding SEPP.\nIf the receiving SEPP already has a previously negotiated cipher suite, the SEPP shall overwrite it with the new one.\n2b.\tOn failure, the responding p-SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code as specified in clause 6.1.4.3. If the SEPP already has a previously negotiated cipher suite, the SEPP shall continue to use the same.\nNOTE :\tIf a SEPP already has a previously negotiated cipher suite and a new cipher suite is also received, the SEPP starts applying the new cipher suite immediately and also continues with the old cipher suite for a limited time period. This allows messages with old policies to be completed gracefully.\nIf the initiating SEPP receives a security parameter exchange request from the responding SEPP before receiving a response for its request (i.e security parameter exchange procedure collision), the initiating SEPP shall compare its FQDN that was sent in its request with the FQDN of the responding SEPP that is received in the security parameter exchange request message. If the initiating SEPP's FQDN lexicographically precedes, it shall reject the incoming HTTP request message with the cause \"SECURITY_PARAM_EXCHANGE_COLLISION\" and it shall continue with its initiated procedure and vice versa.\nEXAMPLE:\tAssuming SEPP A's FQDN is \"sepp.5gc.mnc345.mcc012.3gppnetwork.org\" and SEPP B's FQDN is \"sepp.5gc.mnc346.mcc012.3gppnetwork.org\", then SEPP A's FQDN precedes SEPP B's FQDN and SEPP A proceeds with its security parameter exchange procedure.",
      "chunk_type": "procedure",
      "cross_references": [
        "clause_5.3.3",
        "clause_6.1.4.3",
        "figure_5.2.3.2-1",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.2.3.3",
      "section_id": "5.2.3.3",
      "section_title": "Parameter Exchange Procedure for Protection Policy Exchange",
      "content": "The parameter exchange procedure for protection policy exchange may be performed after the Parameter Exchange Procedure for Cipher Suite Negotiation (see clause 5.2.3.2). If a HTTP/2 connection does not exist towards the peer SEPP at the time of initiating this procedure, the HTTP/2 connection shall be established. If there is a change in the protection policy exchange and the SEPP wants to renegotiate it, then the SEPP may reuse the parameter exchange procedure for the protection policy exchange to override what was exchanged before. If the parameter exchange procedure for the protection policy exchange is not performed, then the protection policies between the SEPP shall be exchanged out of bands.\nThe procedure is described in Figure 5.2.3.3-1 below.\nFigure 5.2.3.3-1: Parameter Exchange Procedure for Protection Policy Exchange\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecParamExchReqData\" IE carrying the following information:\n-\tProtection policy information\nThe protection policy information contains:\n-\tAPI to IE mapping containing the mapping information of list of leaf IEs and recursive non-leaf IEs for each:\n-\tRequest/response and Subscribe / Unsubscribe service operation, identified by the API URI and method; and/or\n-\tCallbacks (e.g Notification service operation), identified by the value of the 3GPP custom HTTP header \"3gpp-Sbi-Callback\" (see clause 5.2.3 of 3GPP TS 29.500 [4]).\n-\tList of IE types that are to be protected across N32-f (i.e the data type encryption policy as specified in clause 13.2.3.2 of 3GPP TS 33.501 [6]); and\n-\tModification policy: Against each leaf IE and recursive non-leaf IEs in the API to IE mapping information, a boolean flag indicating whether that IE is allowed to be modified by an RI on the side of the SEPP sending the protection policy information.\nAlternatively, if both the initiating SEPP and the responding SEPP support the PSEPRO feature (PRINS Security Profiles Support, see clause 6.1.7), the initiating SEPP may include a candidate list of security profiles instead of Protection policy information in the parameter exchange request message towards the responding SEPP.\nNOTE 1:\tThe definition of security profiles is out of scope of 3GPP.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the following information\n-\tSelected protection policy information\nThe Selected protection policy information contains the IEs allowed to be modified by an RI on the side of the responding SEPP. If the responding SEPP connects to several RIs, an isModifiable IE may be included to indicate an IE is allowed to be modified by all RI(s) or an map type of isModifiableByIpx IE may be included to indicate an IE is allowed to be modified by an RI identified by the key of ipxProviderId IE if this IE is allowed to be modified by some of (but not all) the RI(s), as specified in clause 13.2.3.4 of 3GPP TS 33.501 [6].\nThe initiating SEPP shall store the modification policy which are sent from responding SEPP in selected protection policy information and the responding SEPP shall store the modification policy which are sent from the initiating SEPP in the protection policy information. The SEPP receiving the subsequent message transfers over N32-f shall check whether the modifications performed by the RIs were permitted by the respective modification policy.\nThe SEPPs shall store the encryption policy in selected protection policy information and shall apply this policy for subsequent message transfers over N32-f. The encryption policy in selected protection policy is applicable for both the directions of communication between the SEPPs.\nAlternatively, the responding SEPP shall return the selected security profiles to the initiating SEPP, if the responding SEPP supports the PSEPRO feature, and the initiating SEPP sent a candidate list of security profiles in the exchange parameter request message to the responding SEPP.\nThe protection policy to apply for a recursive non-leaf IE shall be the same as the protection policy defined for the ancestor attribute with the same data type. Accordingly, the IeList signaled over N32-c shall not repeat/include the protection policies of the child attributes of the recursive non-leaf IE (see example in Annex F).\nIf the receiving SEPP already has a previously negotiated protection policy information, the SEPP shall overwrite it with the new one.\nThe HTTP/2 connection used for the N32 handshake procedures may be terminated after the completion of this procedure.\n2b.\tOn failure, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code as specified in clause 6.1.4.3. If the SEPP already has previously negotiated protection policy information, the SEPP shall continue to use the same.\nNOTE 2:\tIf a SEPP already has a previously negotiated cipher suite and a new cipher suite is also received, the SEPP starts applying the new cipher suite immediately and also continues with the old cipher suite for a limited time period. This allows messages with old policies to be completed gracefully.\nAn illustration of how the protection policy is stored and looked up in the SEPP is provided in figure 5.2.3.3-2\nFigure 5.2.3.3-2: Protection Policy Storage and Lookup in SEPP\nDuring the N32-f message forwarding, the SEPP looks at a HTTP request or response it receives from an NF service consumer or NF service producer and then uses the above tables to decide which IEs and headers in the message it shall cipher and integrity protect and which IEs it shall allow the RIs to modify.",
      "chunk_type": "procedure",
      "cross_references": [
        "clause_5.2.3.2",
        "ts_29.500_clause_5.2.3",
        "ts_33.501_clause_13.2.3.2",
        "clause_6.1.7",
        "ts_33.501_clause_13.2.3.4",
        "clause_6.1.4.3",
        "figure_5.2.3.3-1",
        "figure_5.2.3.3-2",
        "ts_29.500",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.2.3.4",
      "section_id": "5.2.3.4",
      "section_title": "Parameter Exchange Procedure for Security Information list Exchange",
      "content": "The initiating SEPP shall initiate a Security Information list exchange procedure towards the responding SEPP to exchange the Security Information lists that contain information on RI public keys or certificates that are needed to verify RI modifications at the receiving SEPP as specified in clause 13.2.2.2 of 3GPP TS 33.501 [6]. If there is a change in the security information list and the SEPP wants to renegotiate it, then the SEPP may reuse the parameter exchange procedure for the security information list exchange to override what was exchanged before.\nThe procedure is described in Figure 5.2.3.4-1 below.\nFigure 5.2.3.4-1: Parameter Exchange Procedure for Security Information List exchange\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecParamExchReqData\" IE carrying the following information:\n-\tRI identifier connected to the initiating SEPP;\n-\tList of raw public keys or certificates for that RI.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the \"SecParamExchRspData\" IE carrying the following information:\n-\tRI identifier connected to the responding SEPP;\n-\tList of raw public keys or certificates for that RI.\nIf the receiving SEPP already has a previously negotiated security information list, the SEPP shall overwrite it with the new one.\n2b.\tOn failure, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code as specified in clause 6.1.4.3. If the SEPP already has previously negotiated security information list, the SEPP shall continue to use the same.\nNOTE :\tIf a SEPP already has a previously negotiated cipher suite and a new cipher suite is also received, the SEPP starts applying the new cipher suite immediately and also continues with the old cipher suite for a limited time period. This allows messages with old policies to be completed gracefully.",
      "chunk_type": "procedure",
      "cross_references": [
        "ts_33.501_clause_13.2.2.2",
        "clause_6.1.4.3",
        "figure_5.2.3.4-1",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.2.4",
      "section_id": "5.2.4",
      "section_title": "N32-f Context Termination Procedure",
      "content": "After the completion of the security capability negotiation procedure and/or the parameter exchange procedures, an N32-f context is established between the two SEPPs. The \"n32fContextId\" of each SEPP is provided to the other SEPP. This context identifier shall be stored in each SEPP until the context is explicitly terminated by the N32-f context termination procedure. The SEPP that is initiating the N32-f context termination procedure shall use the HTTP method POST on the URI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-terminate. If a HTTP/2 connection does not exist towards the receiving SEPP, a HTTP/2 connection shall be created before initiating this procedure. The procedure is shown below in Figure 5.2.4-1.\nFigure 5.2.4-1: N32f Context Termination Procedure\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the N32-f context id information that is to be terminated.\n2a.\tOn success, the responding SEPP, shall:\n-\tstop sending any further messages over the N32-f towards the initiating SEPP;\n-\tonce all the ongoing N32-f message exchanges with the initiating SEPP are completed or timed out, delete the N32-f context identified by the \"n32fContextId\" provided in the request.\nThe N32-f HTTP/2 connections from the responding SEPP shall not be deleted if they terminate at an RI, since that HTTP/2 connection may carry traffic towards other PLMN SEPPs as well. The responding SEPP shall return the status code \"200 OK\" together with an N32ContextInfo content that carries the \"n32fContextId\" of the initiating SEPP that the responding SEPP has stored.\nThe initiating SEPP shall:\n-\tstop sending any further messages over the N32-f towards the responding SEPP;\n-\tonce all the ongoing N32-f message exchanges with the responding SEPP are completed or timed out, delete the local N32-f context identified by this \"n32fContextId\".\nIf the initiating SEPP receives a N32-f termination request from the responding SEPP before receiving a response for its request (i.e N32-f Context Termination Procedure collision), the initiating SEPP shall process the received N32-f termination request from the responding SEPP and shall return the status code \"200 OK\" together with an N32ContextInfo content that carries the \"n32fContextId\" of the responding SEPP that the initiating SEPP has stored. The initiating SEPP shall behave as specified above without waiting for a response from the responding SEPP for its N32-f Context Termination request.\n2b.\tOn failure, the responding SEPP shall return an appropriate 4xx/5xx status code together with the \"ProblemDetails\" JSON body.",
      "chunk_type": "procedure",
      "cross_references": [
        "figure_5.2.4-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.2.5",
      "section_id": "5.2.5",
      "section_title": "N32-f Error Reporting Procedure",
      "content": "When a SEPP is not able to process a message it received over the N32-f interface due to errors, the error information is conveyed to the sending SEPP by using the N32-f error reporting procedure over the N32-c interface. The SEPP that is initiating the N32-f error reporting procedure shall use the HTTP method POST on the URI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-error. If a HTTP/2 connection does not exist towards the receiving SEPP, a HTTP/2 connection shall be created before initiating this procedure. The procedure is shown below in Figure 5.2.5-1.\nFigure 5.2.5-1: N32f Error Reporting Procedure\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the N32-f error information that is to be reported.\n2a.\tOn success, the responding SEPP, shall:\n-\tlog that the N32-f request / response message identified by the \"n32fMessageId\" is not processed by the receiving SEPP;\nThe responding SEPP shall return the status code \"204 No Content\".\n2b.\tOn failure, the responding SEPP shall return an appropriate 4xx/5xx status code together with the \"ProblemDetails\" JSON body.",
      "chunk_type": "procedure",
      "cross_references": [
        "figure_5.2.5-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.1",
      "section_id": "5.3.1",
      "section_title": "Introduction",
      "content": "The N32-f interface is used between two SEPPs for:\n-\tThe forwarding of JOSE protected HTTP/2 messages between the NF service consumer and the NF service producer across two PLMNs, when PRINS is the negotiated security policy. The message forwarding on N32-f shall be based on the negotiated security capability and the exchanged security parameters between the two SEPPs (see clause 5.2).\n-\tForwarding of the HTTP/2 messages between the NF service consumer and the NF service producer without any reformatting and application layer protection, when TLS is the negotiated security policy.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.2.1",
      "section_id": "5.3.2.1",
      "section_title": "General",
      "content": "If the negotiated security capability between the two SEPPs is PRINS, one or more HTTP/2 connections between the two SEPPs for the forwarding of JOSE protected message shall be established, which may involve RIs on path. The forwarding of messages over the N32-f interface involves the following steps at the sending SEPP:\n1.\tIdentification of the protection policy applicable for the API being invoked (i.e either a request/response NF service API or a subscribe/unsubscribe service API or a notification API).\n2.\tMessage reformatting as per the identified protection policy.\n3.\tForwarding of the reformatted message over the N32 interface.\nThe processing of a message received over the N32-f interface at the receiving RI involves the following steps:\n1.\tApply the modifications in the \"modificationsBlock\" appended by the sending RI as JSON patches in the DataToIntegrityProtectBlock (from the decoded \"aad\" part), if the \"modificationsBlock\" is received in the message.\n2.\tDetermine further modifications required based on modification policy and insert the modification entries in \"modificationsBlock\".\n3.\tForwarding the received message with the above inserted modification entries in \"modificationsBlock\" over the N32 interface.\nThe processing of a message received over the N32-f interface at the receiving SEPP involves the following steps.\n1.\tIdentify the N32-f context using the N32-f context Id received in the message.\n2.\tVerify the integrity protection of the message using the keying material obtained from the TLS layer during the parameter exchange procedure for that N32-f context (see 3GPP TS 33.501 [6]). The TLS connection from which the keying material is obtained is the N32-c TLS connection used for the parameter exchange procedure.\n3.\tDecrypt the ciphertext part of the received JWE message. Decode the \"aad\" part of the JWE message using BASE64URL decoding.\n4.\tFor each entry in the \"modificationsBlock\" of the received message:\n-\tFirst verify the integity protection of that entry using the keying material applicable for the RI that inserted that block (using the \"identity\" IE in the \"modificationsBlock\");\n-\tIdentify the modifications policy exchanged during the parameter exchange procedure with the sending SEPP if the RI that inserted the modificationsBlock is from the sending SEPP side; else identify the modifications policy applicable for the RI based on local configuration;\n-\tCheck if the inserted modifications are as per the identified modifications policy;\n-\tApply the modifications as a JSON patch in the DataToIntegrityProtectBlock (from the decoded \"aad\" part).\n5.\tForm the original JSON request / response body from the decrypted ciphertext and the decoded integrity verified \"aad\" block possibly modified as described in step 4.\n6.\tIf the reconstructed HTTP message has an \"Authorization\" header, then the SEPP shall check whether the service consumer's PLMN ID or SNPN ID is present in the Bearer token contained in the Authorization header (see 3GPP TS 29.510 [18], clause 6.3.5.2.4) and if it matches with the \"Remote PLMN ID\" or \"Remote SNPN ID\" of the N32-f context. If they do not match, the SEPP shall respond to the sending SEPP with \"403 Forbidden\" status code with the application specific cause set as \"PLMNID_MISMATCH\" or \"SNPNID_MISMATCH\".\nNOTE 1:\tIn this case, the N32-f Error Reporting procedure specified in clause 5.2.5 is not used since the processing of the complete N32-f message fails at the receiving SEPP.\nNOTE 2:\tIf the service consumer's PLMN ID or SNPN ID is present in the reconstructed HTTP message, then the receiving SEPP compares this with the sending SEPP's PLMN ID or SNPN ID, which is retrieved from N32f Context (see clause 5.9.3 in 3GPP TS 33.501 [6]). See the above step 6 for the receiving SEPP behaviour. If the service consumer's PLMN ID and SNPN ID are not present, the comparison is not done.\nSEPPs and RI should support gzip coding (see IETF RFC 1952 [23]) in HTTP requests and responses and indicate so in the Accept-Encoding header, as described in clause 6.9 of 3GPP TS 29.500 [4] and clause 6.2.2.2.3.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.510_clause_6.3.5.2.4",
        "clause_5.2.5",
        "ts_33.501_clause_5.9.3",
        "ts_29.500_clause_6.9",
        "ts_29.500_clause_6.2.2.2.3",
        "ts_33.501",
        "ts_29.510",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.2.2",
      "section_id": "5.3.2.2",
      "section_title": "Protection Policy Lookup",
      "content": "When a SEPP receives a HTTP/2 request or response message intended to be routed towards another PLMN, the sending SEPP shall identify the protection policy as given below\n1.\tIdentify the target PLMN from the \":aurthority\" part of the message using the format specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n2.\tCheck if the incoming HTTP/2 message has the \"3gpp-Sbi-Callback\" header. When present, the SEPP shall select the data encryption and modification policy applicable for the specific notification type, identified by the value of the \"3gpp-Sbi-Callback\" header and the target PLMN, using the notification type list stored as specified in subclase 5.2.3.3.\n3.\tElse, if it is a HTTP/2 request message, then from the \":authority\" and \":path\" part of the received HTTP/2 request message, form the API URI. For the identified PLMN, check if a protection policy exists for the API URI using the table stored as specified in clause 5.2.3.3.\n4.\tElse, if it is a HTTP/2 response message, then based on the HTTP/2 stream ID on which the response is received, identify the corresponding request that was sent by the SEPP and the protection policy applicable for that request, as specified in step 3.\n5.\tIf an entry is not found, then it means that either the particular API has no protection policy exchanged.\nOnce a protection policy is identified, the SEPP shall apply the application layer security as per the identified protection policy.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_6.1.4.3",
        "clause_5.2.3.3",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.2.3",
      "section_id": "5.3.2.3",
      "section_title": "Message Reformatting",
      "content": "A SEPP on the sending side PLMN applies message reformatting in the following cases:\n-\tWhen it receives a HTTP/2 request message from an NF service consumer to a an NF service producer in another PLMN;\n-\tWhen it receives a response HTTP/2 response message from an NF service producer to an NF service consumer in another PLMN.\n-\tWhen it receives a HTTP/2 notification request message from an NF service producer to an NF service consumer in another PLMN;\n-\tWhen it receives a HTTP/2 notification response message from an NF service consumer to an NF service producer in another PLMN\nThe SEPP shall reformat the HTTP/2 message by encapsulating the whole message into the body of a new HTTP POST message. The body of the HTTP POST request / response message shall contain the reformatted original HTTP/2 request/response message respectively. The HTTP POST request/response body shall be encoded as the \"N32fReformattedReqMsg\"/\"N32fReformattedRspMsg\" JSON bodies respectively, as specified in clause 6.2.5.\nThe \"N32fReformattedReqMsg\"/\"N32fReformattedRspMsg\" are structured as given below:\nFigure 5.3.2.3-1 JSON representation of a reformatted HTTP message\nThe \"cipherText\" part of the reformatted message in FlatJweJson shall be prepared as given below\nFigure 5.3.2.3-2 Transformation of Sensitive Information Elements to Encrypt into CipherText\n1.\tBased on the protection policy exchanged between the SEPPs, the sending SEPP prepares an input for the JWE ciphering and integrity protection as an array of arbitrary types in the \"DataToIntegrityProtectAndCipher\" block with each entry containing either a HTTP header value, the value of a variable in URI path, the value of an URI query parameter or the value of a JSON payload IE of the API message being reformatted. The index value \"encBlockIdx\" in the contentpart of DataToIntegrityProtectBlock shall point to the index of a header value or IE value in this input array.\n2.\tThe input block is fed into an encryption function along with the other required inputs for JWE as specified in IETF RFC 7516 [14].\n3.\tThe encryption function outputs the cipher text information. This cipher text is then subjected to BASE64URL transformation as specified in IETF RFC 4648 [15] clause 5.\n4. The output of the BASE64URL transform is them encoded as the ciphertext part of FlatJweJson IE specified in clause 6.2.5.2.11.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.5",
        "clause_5",
        "clause_6.2.5.2.11",
        "figure_5.3.2.3-1",
        "figure_5.3.2.3-2"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.2.4",
      "section_id": "5.3.2.4",
      "section_title": "Message Forwarding to Peer SEPP",
      "content": "Once a SEPP reformats the HTTP/2 message into the \"N32ReformattedReqMsg\"/\"N32ReformattedRspMsg\" JSON object as specified in clause 5.3.2, the SEPP forwards the message to the receiving SEPP by invoking a HTTP POST method as shown in figure 5.3.2.4-1 below.\nFigure 5.3.2.4-1 Message Forwarding between SEPP on N32-f\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"N32ReformattedReqMsg\" IE carrying the reformatted HTTP/2 message. The request message shall contain the \"n32fContextId\" information provided by the responding SEPP to the initiating SEPP earlier during the parameter exchange procedure (see clause 5.2.3). The responding SEPP shall use the \"n32fContextId\" information to:\n-\tLocate the agreed cipher suite and protection policy;\n-\tLocate the n32ContextId to be used in the response.\nIf the HTTP request/response message to be forwarded over N32-f includes an 3gpp-Sbi-Message-Priority header, the initiating/responding SEPP should additionally insert a 3gpp-Sbi-Message-Priority header in the N32-f message with the same contents as the 3gpp-Sbi-Message-Priority header encoded within the \"N32ReformattedReqMsg\"/ N32ReformattedRspMsg IE respectively.\nNOTE 1:\tReplicating the information in a N32-f message header enables the receiving SEPP to determine the priority of the forwarded HTTP request/response without having to parse the N32-f message content.\nThe HTTP request content may be compressed hop by hop over N32-f, if the initiating SEPP or RI and its next hop (RI or SEPP) support gzip coding (see IETF RFC 1952 [23]).\n2a.\tOn successful processing of the request, the responding SEPP shall:\n-\tdecompress the N32-f HTTP request content, if it is compressed;\n-\treconstruct the HTTP/2 message towards the NF service producer;\n-\tcompress the reconstructed HTTP request if the reconstructed HTTP content contains a Content-Encoding header indicating gzip compression;\n-\tforward the reconstructed HTTP/2 message to the NF service producer;\n-\twait for the response from the NF service producer; and then\n-\tonce the response from the NF service producer is received, respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the \"N32ReformattedRspMsg\". The \"N32ReformattedRspMsg\" shall contain the reformatted HTTP response message from the responding PLMN. The response message shall contain the \"n32fContextId\" information provided by the initiating SEPP to the responding SEPP earlier during the parameter exchange procedure (see clause 5.2.3).\nNOTE 2:\tFor unsuccessful processing of the request with \"PLMNID_MISMATCH\", see clause 5.3.2.1.\nThe responding SEPP shall be able to map the response received from the NF service producer to the HTTP/2 stream ID for the corresponding response it needs to generate towards the initiating SEPP. The HTTP/2 stream ID and the HTTP/2 connection information on either side shall be used to derive this mapping.\nThe HTTP response content may be compressed hop by hop over N32-f, if the responding SEPP or RI and its next hop (RI or SEPP) support gzip coding (see IETF RFC 1952 [23]).\n2b.\tOn failure or unsuccessful processing of the request, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code, the message body shall contain a ProblemDetails structure with the \"cause\" attribute set to one of the application error as specified in clause 6.2.4.2. The \"cause\" attribute shall be set to \"UNSPECIFIED\", if the responding SEPP fails to process the reconstructed message, and the error is reported by N32f error reporting procedure as specified in clause 5.2.5.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.3.2",
        "clause_5.2.3",
        "clause_5.3.2.1",
        "clause_6.2.4.2",
        "clause_5.2.5",
        "figure_5.3.2.4-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.2.5",
      "section_id": "5.3.2.5",
      "section_title": "JOSE Protected Forwarding Options",
      "content": "The JOSE Protected Forwarding Options is used by the sending SEPP or RI to discover the communication options supported by its next hop (RI or SEPP) for N32-f message processing.\nFigure 5.3.2.5-1: Procedure for the discovery of communication options supported by the next hop\n1.\tThe sending SEPP or RI shall send an OPTIONS request to discover the communication options supported by its next hop (RI or SEPP) for N32-f message processing.\n2.\tIf the request is accepted, the next hop (RI or SEPP) shall respond with the status code 204 No Content and include an Accept-Encoding header (as described in IETF RFC 9110 [9]).\nOn failure, the next hop shall return one of the HTTP status code listed in Table 6.2.4.3.2.1-3.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.2.4.3.2.1-3",
        "figure_5.3.2.5-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.3.1",
      "section_id": "5.3.3.1",
      "section_title": "General",
      "content": "When the negotiated security policy between the SEPPs is TLS, then the procedures described in clause 5.3.2 shall not be applied. Messages shall be forwarded to the peer SEPP as specified in clause 6.1.4.3.4 of 3GPP TS 29.500 [4].",
      "chunk_type": "definition",
      "cross_references": [
        "clause_5.3.2",
        "ts_29.500_clause_6.1.4.3.4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.3.2.1",
      "section_id": "5.3.3.2.1",
      "section_title": "General",
      "content": "This clause addresses the correlation between a N32-f connection and its parent N32-c context when the negotiated security mode is TLS. When TLS Security is used, the correlation between a N32-f connection to its parent N32-c context shall be identified with following mechanism:\n-\tWhen there is only one N32-c context successfully negotiated between a pair of SEPPs, one SEPP shall correlate a N32-f connection to its N32-c context by matching the peer SEPP's identifier (i.e. the FQDN of the peer SEPP) in the received TLS certificate with the FQDN(s) of the peer SEPP in the corresponding N32-c context (i.e. the FQDNs carried in the \"sender\" IE and/or the \"senderN32fFqdn\" IE); or\nNOTE: \tIf the received certificate contains FQDNs for different SEPPs (e.g. one common certificate used for all the SEPPs in the whole network), one SEPP can use the peer SEPP FQDN in the Via header (see clause 6.10.10.3 of 3GPP TS 29.500 [4]) of the incoming N32-f HTTP message to perform the matching with the FQDN in the corresponding N32-c context.\n-\tWhen multiple N32-c contexts were successfully negotiated between a pair of SEPPs, then\n-\tif the N32 Handshake Ids were exchanged during the N32-c negotiation, one SEPP shall correlate the N32-f connection to its parent N32-c context by matching the N32 Handshake Id in the incoming N32-f HTTP messages (carried in the \"3gpp-Sbi-N32-Handshake-Id\" header) with the received N32 Handshake Id (carried in the \"n32HandshakeId\" IE) in corresponding N32-c context; or\n-\tif the N32 Handshake Ids were not successfully exchanged during the N32-c negotiation (i.e. if at least one SEPP did not signal its N32 Handshake Id during the Security Capability Negotiation Procedure) and if different N32 purposes were successfully negotiated for N32-c contexts, one SEPP shall correlate the N32-f connection to its parent N32-c context by matching the N32 purpose of the incoming N32-f HTTP messages (as stated in the \"3gpp-Sbi-Interplmn-Purpose\" HTTP header if present or as \"ROAMING\" if the \"3gpp-Sbi-Interplmn-Purpose\" HTTP header is not present, see clause 6.14 of 3GPP TS 29.500 [4]) with the supported N32 purpose(s) in the corresponding N32-c context.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_6.10.10.3",
        "ts_29.500_clause_6.14",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.3.2.2",
      "section_id": "5.3.3.2.2",
      "section_title": "Use of HTTP OPTIONS for N32-c and N32-f connections correlation",
      "content": "When multiple N32-c contexts were successfully negotiated between a pair of SEPPs and if the initiating SEPP does not send any HTTP service request message to the responding SEPP after establishing TLS session for the N32-f connection and both SEPPs indicated the support of the feature TLSCOR, i.e. support of autonomous correlation of N32-c and N32-f, the initiating SEPP shall send a HTTP OPTIONS request towards the Authority of the responding SEPP over the established TLS session for N32-f to correlate TLS sessions established for N32-c and N32-f, immediately after each N32-f TLS connection is established, as shown in Figure 5.3.3.2.2-1.\nThe HTTP OPTIONS request shall include \"3gpp-Sbi-N32-Handshake-Id\" header and \"3gpp-Sbi-Interplmn-Purpose\" header along with the corresponding values as same as all other messages sent over N32-f. This HTTP OPTIONS request will avoid pending TLS session waiting for long duration before the first N32-f message is sent when the correlation can be done for the first time.\nFigure 5.3.3.2.2-1: Use of HTTP OPTIONS for N32-c and N32-f connections correlation",
      "chunk_type": "general",
      "cross_references": [
        "figure_5.3.3.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.3.3.3",
      "section_id": "5.3.3.3",
      "section_title": "3gpp-Sbi-N32-Handshake-Id",
      "content": "This header contains the N32 Handshake ID that is negotiated during the N32-c handshake, when TLS security is used. This header is included in the N32-f request by the sending SEPP and removed from the N32-f request by the receiving SEPP.\nThe encoding of the header follows the ABNF as defined in IETF RFC 9110 [9].\nSbi-N32-Handshake-Id-Header = \"3gpp-Sbi-N32-Handshake-Id:\" OWS n32HandshakeId OWS\nn32HandshakeId = 16HEXDIG\nEXAMPLE:\t3gpp-Sbi-N32-Handshake-Id: 955cac631f953ed8",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_5.3.3.4",
      "section_id": "5.3.3.4",
      "section_title": "Error Handling",
      "content": "On failure or unsuccessful processing of the incoming N32-f request, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code including a ProblemDetails structure with the \"cause\" attribute set to one of the following application errors as specified in Table 5.3.3.4-1.\nTable 5.3.3.4-1: Protocol and application errors generated by SEPP\nProtocol or application Error\nHTTP status code\nDescription\n\"CONTEXT_NOT_FOUND\"\n403 Forbidden\nThe N32-f request which was received over TLS connection is rejected due to having no related N32-c context.\nFor correlation of a N32-f connection to its parent N32-c context, please refer to clause 5.3.3.2.\n5.3.3.5\tN32-f connection keepalive\nIn order to maintain the N32-f connection alive in absence of traffic, a SEPP may send HTTP/2 PING frames towards the peer SEPP in the absence of traffic. Each SEPP may consider the keepalive timer received from the peer SEPP (if any) to determine when to send HTTP/2 PING frames in the absence of traffic.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.3.3.2",
        "table_5.3.3.4-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.4.1",
      "section_id": "5.4.1",
      "section_title": "General",
      "content": "The Nsepp_Telescopic_FQDN_Mapping service is used between any Network Function and the SEPPs in the same PLMN, if TLS protection between the Network Function and the SEPP relies on using telescopic FQDN. See clause 28.5.2 of 3GPP TS 23.003 [19] and clause 6.1.4.3 of 3GPP TS 29.500 [4]) for the definition and use of Telescopic FQDN.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_23.003_clause_28.5.2",
        "ts_23.003_clause_6.1.4.3",
        "ts_29.500_clause_6.1.4.3",
        "ts_23.003",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.4.2",
      "section_id": "5.4.2",
      "section_title": "Foreign FQDN to Telescopic FQDN Mapping Procedure",
      "content": "This procedure is initiated by an NF Service Consumer (typically an NRF or an NSSF) that needs to interact with a NF in a foreign PLMN (typically the corresponding NRF or NSSF), and to do so, it needs to build a telescopic FQDN of said NF (i.e. concatenation of the FQDN of the foreign FQDN, and the FQDN of the local SEPP), and then the resulting telescopic FQDN needs to be \"flattened\" (i.e. the FQDN of the NF in the foreign PLMN needs to be converted to a singel label). The procedure is described in Figure 5.4.2-1 below.\nFigure 5.4.2-1: Foreign FQDN to Telescopic FQDN Mapping Procedure\n1.\tThe NF Service Consumer issues an HTTP GET request towards the local SEPP with a query parameter \"foreign-fqdn\" containing the FQDN of the NF in the foreign PLMN, that needs to be transformed into a flattened telescopic FQDN.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the NF Service Consumer with a \"200 OK\" status code and a response body that contains a JSON object of type \"TelescopicMapping\", containing as attributes the label to be used as first label in the telescopic FQDN, and the domain of the local SEPP to be appended after such first label. The resulting FQDN shall be used by the NF Consumer to setup a TLS session terminated in the local SEPP, where the SEPP shall present a server certificate with a wildcard domain matching the returned telescopic FQDN.",
      "chunk_type": "procedure",
      "cross_references": [
        "figure_5.4.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.4.3",
      "section_id": "5.4.3",
      "section_title": "Telescopic FQDN to Foreign FQDN Mapping Procedure",
      "content": "This procedure is initiated by an NF Service Consumer (typically another SEPP) that has received a service request with an unknown first label of a telescopic FQDN. Typically, this SEPP may interact with other SEPPs in the same PLMN in order to determine if there is an existing mapping for a given label to an FQDN of a foreign FQDN; this procedure is only expected to be used when multiple SEPPs are deployed in a PLMN. The procedure is described in Figure 5.4.3-1 below.\nFigure 5.4.3-1: Foreign FQDN to Telescopic FQDN Mapping Procedure\n1.\tThe NF Service Consumer issues an HTTP GET request towards another SEPP with a query parameter \"telescopic-label\" containing the first label of a given telescopic FQDN, whose mapping towards an FQDN of an NF in a foreign PLMN needs to be verified.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the NF Service Consumer with a \"200 OK\" status code and a response body that contains a JSON object of type \"TelescopicMapping\", containing as attribute \"foreignFqdn\", containing the FQDN of the NF in the foreign PLMN.",
      "chunk_type": "procedure",
      "cross_references": [
        "figure_5.4.3-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.1",
      "section_id": "5.5.1",
      "section_title": "General",
      "content": "Roaming services providers provide the technical and commercial means to facilitate the deployment and operation of roaming services between a client operator and a set of selected connected operators (see clause 6.45 of 3GPP TS 22.261 [28]).\nThe communication between two SEPPs may pass up to two RIs. The changes made by RIs to messages originated by a SEPP, based on the originating PLMNs policy, shall be identifiable by the receiving SEPP.\nNOTE 1:\tIn this release of the specification, the descriptions in clause 5.5 are provided for Roaming Hubs as Roaming Intermediary, only.\nNOTE 2:\tThe requirements specified in this clause for supporting Roaming Intermediaries can be applicable to SEPPs starting from Release 16. It is implementation specific how to support scenarios where the Release 16 and 17 SEPP of the roaming partners are not aligned regarding the support of Roaming Hub/Intermediaries.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_22.261_clause_6.45",
        "clause_5.5",
        "ts_22.261"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.2.1.1",
      "section_id": "5.5.2.1.1",
      "section_title": "General",
      "content": "This clause specifies the requirements that apply in scenarios where a PLMN SEPP makes use of RIs and support messages generated by RIs as specified in clause 5.9.3.2a of 3GPP TS 33.501 [6].\nThe N32 Handshake procedures specified in clause 5.2 shall apply between the c-SEPP and p-SEPP with the following additions:\n-\tPrior to establishing the (end-to-end) N32-c TLS connection with the pSEPP, the c-SEPP shall send an HTTP CONNECT Request to the RI to request the RI to set up a TCP connection towards the p-SEPP as specified in clause 5.5.2.1.2 (with one RI between the SEPPs) and clause 5.5.2.1.3 (with two RIs between the SEPPs); upon receipt of a successful HTTP CONNECT response, the c-SEPP shall establish the N32-c TLS connection and proceed with the N32 Handshake procedures;\n-\tIf a RI disallows the establishment of the N32-c connection, the RI shall reject the HTTP CONNECT request as specified in clause 5.5.2.2.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_33.501_clause_5.9.3.2",
        "clause_5.2",
        "clause_5.5.2.1.2",
        "clause_5.5.2.1.3",
        "clause_5.5.2.2",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.2.1.2",
      "section_id": "5.5.2.1.2",
      "section_title": "Successful N32-c connection establishment via one RI",
      "content": "Figure 5.5.2.1.2-1 depicts the successful establishment of the N32-c connection between c-SEPP and p-SEPP via one RI (RI-A).\nFigure 5.5.2.1.2-1: Successful N32-c connection establishment via one RI\n1.\tThe c-SEPP shall establish a TCP connection with the RI-A.\n2.\tThe c-SEPP shall send an HTTP CONNECT request to the RI-A to request the RI-A to establish a TCP connection towards the p-SEPP. The authority of the HTTP CONNECT request shall contain the p-SEPP's FQDN.\nThe c-SEPP shall include the following information in the 3gpp-Connect-Req-Info header in the HTTP CONNECT request:\n-\tthe HTTP connect purpose set to \"n32c\" to indicate that the TCP connection requested to be established is to set up an N32-c connection between the c-SEPP and p-SEPP;\n-\tthe c-SEPP's PLMN ID or SNPN ID; and\n-\tthe c-SEPP's FQDN.\nThe c-SEPP may also include the following information in the HTTP CONNECT request in the 3gpp-Connect-Req-Info header:\n-\tthe intended N32 purpose(s) of the N32 connection.\nThe HTTP CONNECT request shall not contain any content (i.e. payload).\n3.\tThe RI shall determine whether to (dis)allow the N32-c connection establishment based on its roaming contractual agreements and the following parameters:\n-\tthe source PLMN ID or SNPN-ID; and\n-\tthe target PLMN ID or SNPN ID.\nThe RI may also consider the following information for the above determination:\n-\tthe HTTP connect purpose, e.g. the RI may accept an HTTP CONNECT request only for the purpose of establishing a N32-c connection; and/or\n-\tthe intended N32 purposes, e.g. the RI may accept to establish the N32-c connection between the two PLMNs only for specific purposes.\n4.\tIf the RI-A allows the establishment of the N32-c connection, it shall establish the TCP connection towards the p-SEPP.\n5.\tOn successful processing of the request and establishment of the TCP connection towards the p-SEPP, the RI-A shall respond to the c-SEPP with a \"200 OK\" status code and may include the following information in the 3gpp-Connect-Resp-Info header in the HTTP CONNECT response:\n-\tthe allowed N32 purposes for the N32 connection, which may be a subset of the N32 purposes signalled in the request; and/or.\n-\tthe p-SEPP FQDN, if the RI has overwritten the p-SEPP FQDN received from the c-SEPP that the c-SEPP should use for sending its N32-c requests to the p-SEPP.\n6\tThe c-SEPP shall establish the (end to end) N32-c TLS connection with the p-SEPP.\n7.\tThe c-SEPP shall proceed with the N32-c Handshake procedures specified in clause 5.2.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2",
        "figure_5.5.2.1.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.2.1.3",
      "section_id": "5.5.2.1.3",
      "section_title": "Successful N32-c connection establishment via two RIs",
      "content": "Figure 5.5.2.1.3-1 depicts the successful establishment of the N32-c connection between c-SEPPs and p-SEPP via two RI’s (RI-A and RI-B).\nFigure 5.5.2.1.3-1: Successful N32-c connection establishment via 2 RIs\nSteps 1 to 3: same as steps 1 to 3 of Figure 5.5.2.1.2-1.\n4. If the RI-A allows the establishment of the N32-c connection, it shall establish a TCP connection towards the RI-B and send an HTTP CONNECT request to the RI-B, as described in for step 2 but with the following modification:\n-\tthe RI-A shall include the RI-A's FQDN in the 3gpp-Connect-Req-Info header, instead of including the c-SEPP's FQDN.\nsteps 5 and 6: same as steps 3 and 4 of Figure 5.5.2.1.2-1.\nSteps 7a and 7b: same as step 5 of Figure 5.5.2.1.2-1. The RI-A shall send the response to the c-SEPP only upon receiving the 200 OK response from the RI-B.\nSteps 8 and 9: same as steps 6 and 7 of Figure 5.5.2.1.2-1.",
      "chunk_type": "general",
      "cross_references": [
        "figure_5.5.2.1.3-1",
        "figure_5.5.2.1.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.2.2.1",
      "section_id": "5.5.2.2.1",
      "section_title": "General",
      "content": "The RI may reject an N32-c connection establishment request by rejecting the HTTP CONNECT request.\nThe following error scenarios are supported and further detailed in the following clauses.\n1)\tErrors determined upon receipt of the HTTP CONNECT request\nExamples: RI rejecting an HTTP CONNECT request due to:\n-\tthe N32-c connection cannot be setup due to contractual reasons;\n-\tthe N32-c connection cannot be setup due to a connectivity issue.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_5.5.2.2.2",
      "section_id": "5.5.2.2.2",
      "section_title": "N32-c connection establishment rejection by RI A",
      "content": "Figure 5.5.2.2.2-1: N32-c connection establishment rejection by RIs\n1.\tThe c-SEPP shall send an HTTP CONNECT request message as specified in step 2 of Figure 5.5.2.1.2-1.\n2.\tOn failure, if the RI A determines that an N32 connection shall not or cannot be established e.g. due to contractual reasons or connectivity issues, the RI shall return an 4xx or 5xx response with the ProblemDetails providing details on the N32 related error for the c-SEPP.",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_5.5.2.2.2-1",
        "figure_5.5.2.1.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.2.2.3",
      "section_id": "5.5.2.2.3",
      "section_title": "N32-c connection establishment rejection by RI B",
      "content": "Figure 5.5.2.2.3-1: N32-c connection establishment rejection by RIs\n-\tSteps 1 and 2:  same as steps 2 and 4 of Figure 5.5.2.1.3-1.\n-\tSteps 3 and 4: same as step 2 of Figure 5.5.2.2.2-1. The RI-A shall send the response to the c-SEPP only upon receiving the 4xx or 5xx response from the RI-B.",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_5.5.2.2.3-1",
        "figure_5.5.2.1.3-1",
        "figure_5.5.2.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.1.1",
      "section_id": "5.5.3.1.1",
      "section_title": "General",
      "content": "Error messages may be originated from either PLMN SEPPs or RIs to adjacent RIs or adjacent PLMN SEPPs, in an identifiable way. Furthermore, if allowed by the PLMN policy, the SEPP shall be able to send error messages on the N32 interface to a RI via the N32-f. See clause 5.9.3.2 of 3GPP TS 33.501 [6]).\nThe following error scenarios are supported and further detailed in the following clauses.\n1)\tN32-f related error determined upon receipt of an N32-f request\nExamples: RI rejecting an N32-f request due to:\n-\tthe N32-f connection cannot be setup due to contractual reasons;\n-\tthe N32-f connection cannot be setup due to a connectivity issue;\n-\tincompatible encryption/plain information in the request (e.g. an IE is encrypted while it was expected in clear);\n-\tN32-f request not delivered due contractual reasons.\n2)\tN32-f related error determined upon receipt of an N32-f response\nExample:\n-\tincompatible encryption/plain information in the N32-f response (e.g. an IE is encrypted while it was expected in clear).\n3)\tApplicative (i.e. SBI related) error determined upon receipt of an N32-f request\nExample:\n-\tRI rejecting a UE Registration on behalf of the involved PLMNs based on roaming agreements.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_33.501_clause_5.9.3.2",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.2.1",
      "section_id": "5.5.3.2.1",
      "section_title": "Error message originated by RI via N32-f",
      "content": "Figure 5.5.3.2.1-1: Error message originated by RI via N32-f\n1.\tThe cSEPP receives a service request (HTTP request) message from cNF.\n2.\tThe cSEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the pSEPP.\n3.\tThe RI detects an N32-f related error and returns an N32-f error response, e.g. \"403 Forbidden\" response, with the ProblemDetails data providing details on the N32-f related error for the cSEPP. If the error is due to an encryption policy mismatch, the ProblemDetails may include the invalidParams attribute indicating which IEs were received ciphered when they were expected to be received in clear, and vice-versa. The N32-f error response may additionally contain a suggested status code (e.g. \"504 Gateway Timeout\") and a suggested application error (e.g. \"TARGET_PLMN_NOT_REACHABLE\") that the RI suggests the cSEPP to forward in the error response to the cNF, if the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information.\n4.\tIf the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information, the cSEPP sends an error response to the cNF. The cSEPP may use the suggested status code and/or suggested application error for the error response sent to the cNF (e.g. the cSEPP may send a \"504 Gateway timeout\" response with the cause \"TARGET_PLMN_NOT_REACHABLE\" in the ProblemDetails).\n5. \tAlternatively, the cSEPP may re-send the N32-f request taking into account the N32-f error information that was received from the RI. For instance, if the cSEPP receives an error message with the application error \"POLICY_MISMATCH\", the cSEPP may change the data type encryption policy to 'Parameter shall be encrypted' or 'Parameter shall not be encrypted', if this is allowed by local policies, and if necessary, re-negotiate the data type encryption policy with the peer SEPP. After that, the cSEPP may re-send the N32-f Request based on the updated data type encryption policy to the RI.\n6-9.\tThe rest of procedures are processed accordingly.",
      "chunk_type": "general",
      "cross_references": [
        "figure_5.5.3.2.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.2.2",
      "section_id": "5.5.3.2.2",
      "section_title": "Error message originated by pSEPP on N32-f (and optionally N32-c)",
      "content": "Figure 5.5.3.2.2-1: Error message originated by pSEPP via N32-f (and optionally N32-c)\n1. \tThe cSEPP receives a service request (HTTP request) message from cNF.\n2.\tThe cSEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the pSEPP.\n3.\tThe pSEPP detects an N32-f related error and returns an N32-f error response, e.g. \"403 Forbidden\" response, with the ProblemDetails data providing details on the N32-f related error for the cSEPP. If the error is due to an encryption policy mismatch, the ProblemDetails may include the invalidParams attribute indicating which IEs were received ciphered when they were expected to be received in clear, and vice-versa. The N32-f error response may additionally contain a suggested status code (e.g. \"504 Gateway Timeout\") and a suggested application error (e.g. \"TARGET_PLMN_NOT_REACHABLE\") that the pSEPP suggests the cSEPP to forward in the error response to the cNF, if the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information.\n4.\tThe pSEPP may also send an N32-c request (HTTP POST request) towards the cSEPP with the content containing the N32-f error information that is to be reported (see clause 5.2.5).\n5.\tThe cSEPP shall return the status code \"204 No Content\" as the response to the N32-f Error Reporting. (see clause 5.2.5)\n6.\tIf the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information, the cSEPP sends an error response to the cNF. The cSEPP may use the suggested status code and/or suggested application error for the error response to the cNF (e.g. the cSEPP may send a\"504 Gateway timeout\" response with the cause \"TARGET_PLMN_NOT_REACHABLE\" in the ProblemDetails).\n7.\tAlternatively, the cSEPP may re-send the N32-f request taking into account the N32-f error information that was received from the pSEPP. For instance, if the cSEPP receives an error message with the application error \"POLICY_MISMATCH\", the cSEPP may change the data type encryption policy to 'Parameter shall be encrypted' or 'Parameter shall not be encrypted', if this is allowed by local policies, and if necessary, re-negotiate the data type encryption policy with the peer SEPP. After that, the cSEPP may re-send the N32-f Request based on the updated data type encryption policy to the RI.\n8-11.\tThe rest of procedures are processed accordingly.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2.5",
        "figure_5.5.3.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.3.1",
      "section_id": "5.5.3.3.1",
      "section_title": "Error message originated by RI via N32-f interface",
      "content": "The procedure below describes the situation in which RI B detects an error in the response.\nFigure 5.5.3.3.1-1: Error message originated by RI upon receipt of an N32-f response\n1.\tThe c-SEPP receives a service request (HTTP request) message from cNF.\n2.\tThe c-SEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the p-SEPP.\n3.\tThe pSEPP send the service request to the pNF (see clause 5.3.2.3)\n4.\tThe pNF returns the service response (e.g. 200 OK response) to the p-SEPP.\n5.\tThe p-SEPP encapsulates the service reponse in an N32-f response (i.e. JOSE protected message) and forwards the message to the c-SEPP (see clause 5.3.2.3).\n6-8.\tAs the RI B detects an N32-f related error (e.g. an IE is received ciphered while it should be in clear), depending on the RI’s policy, the RI B may forward the response message (200 OK) encapsulating the service response to the c-SEPP and the c-SEPP sends the Service Response to the cNF.\nNOTE:\tIn case the RI decides not to forward the response message to c-SEPP, NF consumers and NF producers can end up with de-synchronized status in case of a non-safe/idempotent operation. Mechanisms specified for 5GC SBI can be used for handling such situation (e.g. to detect the re-transmitted request).\n9.\tThe RI B sends a new N32-f request encapsulating an N32-c \"N32-f Error Reporting request\" message towards p-SEPP to report the error, as specified in clause 5.5.3.3.2. For instance, the Roaming Intermediary B reports the error \"POLICY_MISMATCH\" to the p-SEPP to indicate that IEs that should have been received unprotected have been ciphered.\nUpon receipt of an N32-f request encapsulating an N32-c message with a dummy N32-c apiRoot, the receiving N32-f service instance of the p-SEPP looks up for a N32-c service instance that can support the N32-f connection (identified by the n32fContextId received in the N32-f request), substitutes the dummy N32-c apiRoot of the N32-c message with the apiRoot of that N32-c service instance and forwards the N32-c message towards that N32-c service instance. The receiving N32-f service instance of the p-SEPP may also determine the message in which the error occurred, based on the messageId received in the N32-f request.\n10.\tThe p-SEPP returns \"204 No Content\" to the RI B.\n11.\tThe p-SEPP logs the error and, if possible and allowed by local policies, considers it for further N32-f messages the p-SEPP sends towards the c-SEPP (e.g. if the error indicated that IEs that should have been received unprotected have been ciphered, the p-SEPP may send the IEs in clear in further messages it forwards towards the c-SEPP).\n12.\tThe cNF may repeat its service request in case no response is being received from the c-SEPP.\n13.\tThe c-SEPP forwards the (repeated) service request from the cNF, if any. Alternatively, the c-SEPP may resend its N32-f request to the p-SEPP due to no response being received from the p-SEPP.\n14.\tThe pSEPP forwards the service request towards the pNF.\n15.\tThe pNF returns the service response (e.g. 200 OK response).\n16.\tThe p-SEPP encapsulates the service response in an N32-f response (i.e. JOSE protected message) and forwards the message to the c-SEPP, taking into account any error information earlier received from the cSEPP or RI, if possible and allowed by local policies (e.g. the IE previously reported in error in clear).\n17.\tThe c-SEPP send the service response to the cNF.\nThe procedure is identical if the RI A detects an error.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.3.2.3",
        "clause_5.5.3.3.2",
        "figure_5.5.3.3.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.3.2",
      "section_id": "5.5.3.3.2",
      "section_title": "Error message formatting by the RI",
      "content": "If a RI needs to generate an N32-f related error message upon receiving an N32-f response, the RI shall construct a new N32-f request as defined in clause 5.3.2.3 for a SEPP with the following modifications:\n-\tthe DataToIntegrityProtectBlock (see Table 6.2.5.2.2-1) shall only contain the MetaData with the n32fContextId and messageId of the N32-f response message for which an error was detected.\n-\tthe patch instructions in the modificationsBlock (see Table 6.2.5.2.2-1) shall be based on an  DataToIntegrityProtectBlock only containing the MetaData with the n32fContextId and messageId.\n-\tthe modifications in the \"modificationsBlock\" shall result in encoding a N32-c request for N32-f Error Reporting, i.e. it shall contain patch instructions:\n-\tadding the requestLine to form an HTTP POST request \"{n32c-apiRoot}/n32c-handshake/v1/n32f-error\"; the {n32c-apiRoot} shall be set to a dummy N32-c apiRoot defined as the N32-f apiRoot with the authority part prepended with the label \"n32c\".\nEXAMPLE:\tIf the n32-f apiRoot is https://sepp-n32f.5gc.mnc203.mcc422.3gppnetwork.org:443, the dummy N32-c apiRoot is:\nhttps://n32c.sepp-n32f.5gc.mnc203.mcc422.3gppnetwork.org:443\nNOTE:\tThe dummy N32-c apiRoot in the N32-c message encapsulated in the N32-f request needs not contain addressing information of any actual N32-c service instance of the p-SEPP. Instead, this indicates to the receiving N32-f service instance of the p-SEPP that it needs to look up for a N32-c service instance and route the request towards that N32-c service instance. See step 9 of clause 5.5.3.3.1.\n-\tadding headers, if applicable; and\n-\tadding the payload that shall be the content of the N32-f Error Reporting Request, i.e N32fErrorInfo.\n-\tthe modificationsBlock shall contain the JWS signature of the RI.\nThe RI shall then send its N32-f request towards the p-SEPP, (using the same N32-f apiRoot as the one that was used in the original N32-f request sent to the p-SEPP) possibly via another intermediate RI.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.3.2.3",
        "clause_5.5.3.3.1",
        "table_6.2.5.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.4.1",
      "section_id": "5.5.3.4.1",
      "section_title": "Applicative error originated by RI via N32-f",
      "content": "Figure 5.5.3.4.1-1: Applicative (i.e. SBI related) error originated by RI via N32-f\n1.\tThe c-SEPP receives a service request (HTTP request) message from cNF.\n2.\tThe c-SEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the p-SEPP.\n3.\tThe RI detects an applicative error within the service request encapsulated in the N32-f request, e.g. the UE registration needs to be rejected on behalf of the involved PLMNs. The RI responds back with a successful N32-f response encapsulating a service error response instead of forwarding the N32-f request to the p-SEPP, as defined in clause 5.5.3.2.\n4.\tThe c-SEPP forwards the service error response towards the cNF.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.5.3.2",
        "figure_5.5.3.4.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.4.2",
      "section_id": "5.5.3.4.2",
      "section_title": "Error message formatting by the RI",
      "content": "If a RI needs to generate a service error message upon receiving an N32-f request, the RI shall construct a service error response (to be sent within a successful N32-f response) as defined in clause 5.3.2.3 for a SEPP with the following modifications:\n-\tthe DataToIntegrityProtectBlock (see Table 6.2.5.2.3-1) shall only contain metadata with messageId and n32fContextId of the N32-f request message;\n-\tthe patch instructions in the modificationsBlock (see Table 6.2.5.2.3-1) shall be based on the intermediary originated DataToIntegrityProtectBlock only containing the MetaData with the messageId and n32fContextId.\n-\tthe modifications in the \"modificationsBlock\" shall result in encoding the service error response, i.e. it shall contain patch instructions;\n-\tadding the statusLine to form the desired service error response (e.g. 403 Forbidden response);\n-\tadding SBI headers, if applicable; and\n-\tadding the payload that shall be the content of the service error response (e.g. ProblemDetails with the reason why the registration request is rejected);\n-\tthe modificationsBlock shall contain the JWS signature of the RI.\nThe RI shall then send its N32-f response towards the c-SEPP, possibly via another intermediate RI, encapsulating the service error response.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.3.2.3",
        "table_6.2.5.2.3-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.5.1",
      "section_id": "5.5.3.5.1",
      "section_title": "Applicative request message originated by RI via N32-f",
      "content": "The procedure below describes the situation in which RI detects an event where there are no immediate N32-f messages corresponding to react on. An independent request message is initiated by the RI.\nFigure 5.5.3.5.1-1: Applicative request message originated by RI via N32-f\n1.\tThe RI detects an applicative event regarding the status of roaming where the RI requires to change the status on specific NF.\nNOTE 1:\tHow the RI becomes aware of n32fContextId is outside the scope of this specification.\n2. \tThe RI shall create a new N32-f request encapsulating a request for the appropriate NF as specified in clause 5.5.3.5.2, and shall send the request towards pSEPP for the message targeted to NF Producer.\nNOTE 2:\tThe encapsulated message itself is not in scope of N32 definition. Here only the transport is defined, the content is application specific.\n3a.\tThe p-SEPP shall verify that the RI is allowed to generate the given request according to operator policy. If allowed by the policy, the p-SEPP shall reconstruct the request to be forwarded to the NF and forward the request to the target NF.\n3b.\tIf the message is not allowed by the policy as in step 3a, then the responding SEPP shall return an appropriate 4xx/5xx status code together with the \"ProblemDetails\" in the content of the response.\n4.\tThe target NF shall return an appropriate response to the p-SEPP.\n5.\tThe pSEPP shall forward the response using PRINS security to RI. Since the RI is the NF consumer of the request, the response is not forwarded to any other entity from the RI.\nNOTE 3:\tStep 5 does not prohibit the RI to initiate any further signalling corresponding to the received HTTP response.\nThe procedure is analogous if the RI detects an event that is required on NF beyond the other RI. In this case the request is routed via the other RI to the p-SEPP.\nNOTE 4:\tAs there can only be two RIs between two SEPPs, the scenario described above refers to the case when the RI needs to send to the SEPP connected via the other RI.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.5.3.5.2",
        "figure_5.5.3.5.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.3.5.2",
      "section_id": "5.5.3.5.2",
      "section_title": "Originated request message formatting by the RI",
      "content": "If a RI needs to generate an applicative request message, the RI shall construct a new N32-f request as defined in clause 5.5.3.3.2, with the difference that the procedure applies to request instead of response. However, the modifications in the \"modificationsBlock\" shall result in encoding a request for NF API the i.e. it shall contain patch instructions:\n-\tadding the requestLine to form an HTTP POST request for the target NF the request is intended for;\n-\tadding headers, if applicable; and\n-\tadding the content that shall be the content of the requested NF service operation.\nNOTE:\tThe present document does not specify how the RI knows the apiRoot of the NF service.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.5.3.3.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.4.1",
      "section_id": "5.5.4.1",
      "section_title": "General",
      "content": "The RI may need to instruct the SEPP to terminate or re-establish an N32-f connection and/or an N32-f context.\nThe RI may do so either by:\n-\tsending an N32-f error reporting request encapsulated in a N32-f reformatted request message (e.g. when no N32-f messages are being received when the event triggering this procedure occurs); or\n-\tsending an N32-f error response message upon receiving an N32-f request.\nIn either case, the RI should indicate, in the error information, the cause of the error and whether the SEPP should terminate or re-establish the N32-f connection and/or the N32-f context. The RI may also indicate an alternative RI entity (from the same RI operator) through which the N32-f context or N32-f connection should be re-established.\nNOTE:\tA RI can trigger the above procedures towards a local SEPP or a remote SEPP.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_5.5.4.2",
      "section_id": "5.5.4.2",
      "section_title": "N32-f error reporting request encapsulated in a N32-f request",
      "content": "The RI may instruct the SEPP to terminate or re-establish an N32-f connection and/or an N32-f context by encapsulating an N32-f error reporting request within an N32-f request message.\nThe N32-f error reporting request message serves as an error notification to the SEPP and based or the reported error information (error cause and indication to release or re-establish the N32-f context and/or N32-f connection), the SEPP shall take the appropriate action e.g. by terminating or re-establishing the N32-f connection and/or N32-f context if so requested by the RI. If the RI requested to re-establish the N32-f context and/or the N32-f connection and provided an alternative RI entity in the error information, the SEPP should re-establish the N32-f connection and/or the N32-f context via the alternative RI entity.\nFigure 5.5.4.2.-1: N32-f Error Reporting Request encapsulated in a N32-f request\n1.\tThe RI-B decides to terminate the N32-f context. The RI-B sends an N32-f request message encapsulating an N32-f Error Reporting Request towards p-SEPP to report the error. The error message signals to the SEPP that the N32-f context is requested to be terminated.\n2.\tThe p-SEPP N32-f service instance sends the N32-c request message (i.e. N32-f Error Reporting Request) towards the target N32-c service instance, including the RI sender identity (so that the SEPP N32-c instance can determine the RI that originated the error and take the proper decision based the contract or the agreement between the SEPP and the RI).\nBased on the error information received from the RI, the p-SEPP terminates the N32-f connection and/or the N32-f context (the latter is depicted in the figure).\nThe p-SEPP returns \"200 OK response\" to the RI-B, encapsulating a 204 No Content response message (i.e. the N32-f Error Reporting Response).\n3.\tThe p-SEPP initiates the N32-f Context Termination Procedure by sending N32-f context termination request message towards the c-SEPP based on the received error information from the RI-B. If the RI requests to re-establish the N32-f context and/or the N32-f connection and provides an alternative RI entity in the error information, the SEPP should re-establish the N32-f connection and/or N32-f context via the alternative RI entity (not depicted in the figure).",
      "chunk_type": "general",
      "cross_references": [
        "figure_5.5.4.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_5.5.4.3",
      "section_id": "5.5.4.3",
      "section_title": "Using N32-f error response",
      "content": "The RI may send error information in response to an incoming N32-f request message, in which case it rejects the N32-f request message with an 4xx or 5xx response message including the error information.\nFigure 5.5.4.3.-1: The RI-B sends 4XX/5XX response to tear down the N32-f context\n1.\tThe RI-B receives an N32-f request message. The RI-B determines to terminate the N32-f context.\n2.\tThe RI-B sends a 4XX/5XX response to the p-SEPP including error information signalling to the SEPP that the N32-f context is requested to be terminated.\nThe p-SEPP initiates the N32-f Context Termination Procedure by sending a N32-f context termination request message towards the c-SEPP based on the error information received from the RI-B.",
      "chunk_type": "general",
      "cross_references": [
        "figure_5.5.4.3"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.1",
      "section_id": "6.1.1",
      "section_title": "API URI",
      "content": "The N32 Handshake Procedures shall use the N32 Handshake API.\nThe API URI of the N32 Handshake API shall be:\n{apiRoot}/<apiName>/<apiVersion>\nThe request URIs used in HTTP requests from the initiating SEPP towards the responding SEPP shall have the Resource URI structure defined in clause 4.4.1 of 3GPP TS 29.501 [5], i.e.:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\nwith the following components:\n-\tThe {apiRoot} shall be set as described in 3GPP TS 29.501 [5].\n-\tThe <apiName> shall be \"n32c-handshake\".\n-\tThe <apiVersion> shall be \"v1\".\n-\tThe <apiSpecificResourceUriPart> shall be set as described in clause 6.1.4.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.501_clause_4.4.1",
        "clause_6.1.4",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.2.1",
      "section_id": "6.1.2.1",
      "section_title": "General",
      "content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used as specified in clause 4.3.2.1.\nHTTP/2 shall be transported as specified in clause 4.3.3.\nHTTP messages and bodies for the N32 handshake API shall comply with the OpenAPI [27] specification contained in Annex A.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.1",
        "clause_4.3.3"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.2.2.1",
      "section_id": "6.1.2.2.1",
      "section_title": "General",
      "content": "The HTTP standard headers as specified in clause 4.3.2.2 shall be supported for this API.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.2.2.2",
      "section_id": "6.1.2.2.2",
      "section_title": "Content type",
      "content": "The following content types shall be supported:\n-\tthe JSON format (see IETF RFC 8259 [8]). The use of the JSON format shall be signalled by the content type \"application/json\". See also clause 5.3.4.\n-\tthe Problem Details JSON Object (see IETF RFC 9457 [22]). The use of the Problem Details JSON object in a HTTP response body shall be signalled by the content type \"application/problem+json\".",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.3.4"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.2.3.1",
      "section_id": "6.1.2.3.1",
      "section_title": "General",
      "content": "In this release of the specification, no specific custom headers are defined for the N32 handshake API.\nFor 3GPP specific HTTP custom headers used across all service based interfaces, see clause 4.3.2.3.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.3"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.3.1",
      "section_id": "6.1.3.1",
      "section_title": "Overview",
      "content": "There are no resources in this version of the N32 handshake API. All the operations are realized as custom operations without resources.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.1.4.1",
      "section_id": "6.1.4.1",
      "section_title": "Overview",
      "content": "Table 6.1.4.1-1: Custom operations without associated resources\nOperation Name\nCustom operation URI\nMapped HTTP method\nDescription\nSecurity Capability Negotiation\n/exchange-capability\nPOST\nThis is the N32 capability exchange API used to negotiate the security capabilities between SEPPs or tear down the N32-f TLS connection.\nParameter Exchange\n/exchange-params\nPOST\nThis is the N32 parameter exchange API used to exchange the cipher suites and protection policies.\nN32-f Context Terminate\n/n32f-terminate\nPOST\nThis is the N32-f context termination procedure API.\nN32-f Error Reporting\n/n32f-error\nPOST\nThis is the N32-f error reporting procedure API.",
      "chunk_type": "definition",
      "cross_references": [
        "table_6.1.4.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.2.1",
      "section_id": "6.1.4.2.1",
      "section_title": "Description",
      "content": "This custom operation is used between the SEPPs to negotiate their security capabilities or to tear down the N32-f connection when negotiated security scheme is TLS. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/exchange-capability\nThis operation shall support the resource URI variables defined in table 6.1.4.2.1-1.\nTable 6.1.4.2.1-1: Resource URI variables for this Operation\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.1.1.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.1.1",
        "table_6.1.4.2.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.2.2",
      "section_id": "6.1.4.2.2",
      "section_title": "Operation Definition",
      "content": "This operation shall support the request data structures and response codes specified in tables 6.2.4.2.2-1 and 6.2.4.2.2-2.\nTable 6.1.4.2.2-1: Data structures supported by the POST Request Body\nData type\nP\nCardinality\nDescription\nSecNegotiateReqData\nM\n1\nThe IE shall contain the security capabilities of the initiating SEPP.\nTable 6.1.4.2.2-2: Data structures supported by the POST Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\nSecNegotiateRspData\nM\n1\n200 OK\nThis represents the successful processing of the requested security capabilities. The responding SEPP shall provide the security capabilities that it has selected, in the response.\nExtRedirectResponse\nO\n0..1\n307 Temporary Redirect\nTemporary redirection. See clause 6.1.8.\nProblemDetails\nO\n0..1\n403 Forbidden\nThe \"cause\" attribute may be used to indicate one of the following application errors:\n- REQUESTED_PURPOSE_NOT_ALLOWED\nWhen the receiving SEPP fails to negotiate the security capability, the \"cause\" attribute shall be set to \"NEGOTIATION_NOT_ALLOWED\".\nProblemDetails\nO\n0..1\n409 Conflict\nThe \"cause\" attribute may be used to indicate one of the following application errors:\n- N32C_EXCHANGE_CAPABILITY_ONGOING, when the receiving SEPP receives an N32-c exchange capability request from a peer SEPP while it is waiting for an N32-c exchange capability response message from the same peer SEPP as specified in clause 5.2.2.\nNOTE:\tThe mandatory HTTP error status codes for the POST method listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [4] other than those specified in the table above also apply, with a ProblemDetails data type (see clause 5.2.7 of 3GPP TS 29.500 [4]).\nTable 6.1.4.2.2-3: Headers supported by the 307 response code on this resource\nName\nData type\nP\nCardinality\nDescription\nLocation\nstring\nM\n1\nThe URI of the SEPP towards which the request is redirected. See clause 6.1.8.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_6.1.8",
        "clause_5.2.2",
        "ts_29.500_clause_5.2.7",
        "table_6.1.4.2.2-1",
        "table_6.1.4.2.2-2",
        "ts_29.500_table_5.2.7.1-1",
        "ts_29.500_table_6.1.4.2.2-3",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.3.1",
      "section_id": "6.1.4.3.1",
      "section_title": "Description",
      "content": "This custom operation is used between the SEPPs to exchange the parameters for the N32-f connection. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/exchange-params\nThis operation shall support the resource URI variables defined in table 6.1.4.3.1-1.\nTable 6.1.4.3.1-1: Resource URI variables for this Operation\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.1.1.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.1.1",
        "table_6.1.4.3.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.3.2",
      "section_id": "6.1.4.3.2",
      "section_title": "Operation Definition",
      "content": "This operation shall support the request data structures and response codes specified in tables 6.1.4.3.2-1 and 6.1.4.3.2-2.\nTable 6.1.4.3.2-1: Data structures supported by the POST Request Body\nData type\nP\nCardinality\nDescription\nSecParamExchReqData\nM\n1\nThe IE shall contain the parameters requested by the requesting SEPP.\nTable 6.1.4.3.2-2: Data structures supported by the POST Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\nSecParamExchRspData\nM\n1\n200 OK\nThis represents the successful processing of the requested parameters. The SEPP shall provide the selected parameters (i.e selected cipher suite and/or selected data type encryption policy) depending on what was requested by the requesting SEPP and what is supported by the responding SEPP, or the SEPP shall provide the modification policy and/or security information lists of the connected RIs.\nProblemDetails\nO\n0..1\n409 Conflict\nThe \"cause\" attribute may be used to indicate one of the following application errors:\n- REQUESTED_PARAM_MISMATCH\n- SECURITY_PARAM_EXCHANGE_COLLISION, when the receiving SEPP receives a security parameter exchange request from a peer SEPP while it is waiting for a security parameter exchange response message from the same peer SEPP as specified in clause 5.2.3.2.\nNOTE:\tThe mandatory HTTP error status codes for the POST method listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [4] other than those specified in the table above also apply, with a ProblemDetails data type (see clause 5.2.7 of 3GPP TS 29.500 [4]).",
      "chunk_type": "definition",
      "cross_references": [
        "clause_5.2.3.2",
        "ts_29.500_clause_5.2.7",
        "table_6.1.4.3.2-1",
        "table_6.1.4.3.2-2",
        "ts_29.500_table_5.2.7.1-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.4.1",
      "section_id": "6.1.4.4.1",
      "section_title": "Description",
      "content": "This custom operation is used between the SEPPs to terminate an N32-f context. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-terminate\nThis operation shall support the resource URI variables defined in table 6.1.4.3.1-1.\nTable 6.1.4.4.1-1: Resource URI variables for this Operation\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.1.1.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.1.1",
        "table_6.1.4.3.1-1",
        "table_6.1.4.4.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.4.2",
      "section_id": "6.1.4.4.2",
      "section_title": "Operation Definition",
      "content": "This operation shall support the request data structures and response codes specified in tables 6.1.4.4.2-1 and 6.1.4.4.2-2.\nTable 6.1.4.4.2-1: Data structures supported by the POST Request Body\nData type\nP\nCardinality\nDescription\nN32fContextInfo\nM\n1\nThe IE shall contain the information about the N32-f context requested to be terminated by the requesting SEPP.\nTable 6.1.4.4.2-2: Data structures supported by the POST Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\nN32fContextInfo\nM\n1\n200 OK\nThis represents the successful deletion of the request N32-f context. The responding SEPP shall return the \"n32fContextId\" it had towards the initiating SEPP, in this IE.\nNOTE:\tThe mandatory HTTP error status codes for the POST method listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [4] other than those specified in the table above also apply, with a ProblemDetails data type (see clause 5.2.7 of 3GPP TS 29.500 [4]).",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.7",
        "table_6.1.4.4.2-1",
        "table_6.1.4.4.2-2",
        "ts_29.500_table_5.2.7.1-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.5.1",
      "section_id": "6.1.4.5.1",
      "section_title": "Description",
      "content": "This custom operation is used between the SEPPs to report errors identified while processing the messages received on N32-f. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-error\nThis operation shall support the resource URI variables defined in table 6.1.4.5.1-1.\nTable 6.1.4.5.1-1: Resource URI variables for this Operation\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.1.1.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.1.1",
        "table_6.1.4.5.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.4.5.2",
      "section_id": "6.1.4.5.2",
      "section_title": "Operation Definition",
      "content": "This operation shall support the request data structures and response codes specified in tables 6.1.4.5.2-1 and 6.1.4.5.2-2.\nTable 6.1.4.5.2-1: Data structures supported by the POST Request Body\nData type\nP\nCardinality\nDescription\nN32fErrorInfo\nM\n1\nThe IE shall contain the information about the N32-f message that failed to process at the SEPP initiating the N32-f error reporting procedure, together with information related to the nature of the error.\nTable 6.1.4.5.2-2: Data structures supported by the POST Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\n204 No Content\nThis represents the successful processing of the N32-f error report at the receiving SEPP.\nNOTE:\tThe mandatory HTTP error status codes for the POST method listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [4] other than those specified in the table above also apply, with a ProblemDetails data type (see clause 5.2.7 of 3GPP TS 29.500 [4]).",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.7",
        "table_6.1.4.5.2-1",
        "table_6.1.4.5.2-2",
        "ts_29.500_table_5.2.7.1-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.1",
      "section_id": "6.1.5.1",
      "section_title": "General",
      "content": "This clause specifies the application data model supported by the API.\nTable 6.1.5.1-1 specifies the data types defined for the N32 interface.\nTable 6.1.5.1-1: N32 specific Data Types\nData type\nClause defined\nDescription\nSecNegotiateReqData\n6.1.5.2.2\nDefines the security capabilities of a SEPP sent to a receiving SEPP.\nSecNegotiateRspData\n6.1.5.2.3\nDefines the selected security capabilities by a SEPP.\nSecurityCapability\n6.1.5.3.3\nEnumeration of security capabilities.\nSecParamExchReqData\n6.1.5.2.4\nRequest data structure for parameter exchange\nSecParamExchRspData\n6.1.5.2.5\nResponse data structure for parameter exchange\nProtectionPolicy\n6.1.5.2.6\nThe protection policy to be negotiated between the SEPPs.\nApiIeMapping\n6.1.5.2.7\nAPI URI to IE mapping on which the protection policy needs to be applied.\nIeInfo\n6.1.5.2.8\nProtection and modification policy for the IE\nApiSignature\n6.1.5.2.9\nAPI URI of the service operation\nN32fContextInfo\n6.1.5.2.10\nN32-f context information\nN32fErrorInfo\n6.1.5.2.11\nN32-f error information.\nFailedModificationInfo\n6.1.5.2.12\nInformation on N32-f modifications block that failed to process.\nN32fErrorDetail\n6.1.5.2.13\nDetails about the N32f error.\nCallbackName\n6.1.5.2.14\nCallback Name.\nIpxProviderSecInfo\n6.1.5.2.15\nDefines the security information list of a RI.\nIntendedN32Purpose\n6.1.5.2.16\nDefines the intended N32 establishment purpose.\nRiErrorInformation\n6.1.5.2.17\nRI error information.\nExtRedirectResponse\n6.1.5.2.18\nExtension of the redirection response\nRedirectResponseAddInfo\n6.1.5.2.19\nAdditional information in the redirection response\nHttpMethod\n6.1.5.3.4\nEnumeration of HTTP methods.\nIeType\n6.1.5.3.5\nEnumeration of types of IEs (i.e kind of IE) to specify the protection policy.\nIeLocation\n6.1.5.3.6\nLocation of the IE in a HTTP message.\nN32fErrorType\n6.1.5.3.7\nType of error while processing N32-f message.\nFailureReason\n6.1.5.3.8\nReason for failure to reconstruct a HTTP/2 message from N32-f message.\nN32Purpose\n6.1.5.3.9\nUsage purpose of establishing N32 connectivity\nN32ReleaseIndication\n6.1.5.3.10\nN32-f connection or N32-f context release instructions.\nTable 6.1.5.1-2 specifies data types re-used by the N32 interface protocol from other specifications, including a reference to their respective specifications and when needed, a short description of their use within the N32 Handshake service based interface.\nTable 6.1.5.1-2: N32 re-used Data Types\nData type\nReference\nComments\nFqdn\n3GPP TS 29.571 [12]\nSupportedFeatures\n3GPP TS 29.571 [12]\nUsed to negotiate the applicability of the features defined in table 6.1.7-1.\nDurationSec\n3GPP TS 29.571 [12]",
      "chunk_type": "definition",
      "cross_references": [
        "table_6.1.5.1-1",
        "table_6.1.5.1-2",
        "ts_29.571_table_6.1.7-1",
        "ts_29.571"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.1",
      "section_id": "6.1.5.2.1",
      "section_title": "Introduction",
      "content": "This clause defines the structures to be used in the N32 Handshake API.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.2",
      "section_id": "6.1.5.2.2",
      "section_title": "Type: SecNegotiateReqData",
      "content": "Table 6.1.5.2.2-1: Definition of type SecNegotiateReqData\nAttribute name\nData type\nP\nCardinality\nDescription\nApplicability\nsender\nFqdn\nM\n1\nThis IE shall uniquely identify the SEPP that is sending the request. This IE is used to identify and store the negotiated security capability against the right SEPP.\nn32HandshakeId\nstring\nC\n0..1\nThis IE shall be present if the initiating SEPP support N32 handshake identifier and the N32 handshake identifier may be used to correlate the N32-f connection to the parent N32-c context for TLS security (see clause 5.3.3.2).\nWhen present, this IE shall contain the N32 handshake identifier to be used by the responding SEPP, if TLS security is negotiated, for:\n- TLS protected message forwarding procedure over N32-f towards the initiating SEPP\n- subsequent N32-c signalling request related to this N32-c connection (e.g. to request to tear down the N32-f TLS connection)\nThe n32HandshakeId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32 handshake Id shall appear first in the string, and the character representing the 4 least significant bit of the N32 handshake Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".\nsupportedSecCapabilityList\narray(SecurityCapability)\nM\n1..N\nThis IE shall contain the list of security capabilities that the requesting SEPP supports.\nTo tear down the N32-f TLS connection and to reset N32-c context (as identified by the n32HandshakeId IE, if present), this IE shall set SecurityCapability as \"NONE\".\n3GppSbiTargetApiRootSupported\nboolean\nC\n0..1\nThis IE should be present and indicate that the 3gpp-Sbi-Target-apiRoot HTTP header is supported, if TLS security is supported for N32f message forwarding.\nWhen present, it shall indicate if TLS security using the 3gpp-Sbi-Target-apiRoot HTTP header is supported:\n- true: supported\n- false (default): not supported\n(NOTE 1)\nplmnIdList\narray(PlmnId)\nO\n1..N\nA list of PLMN IDs associated with the SEPP, which is sending the request. The list to be stored by the receiving SEPP in a N32-f Context (see clause 5.9.3 in 3GPP TS 33.501 [6])\nsnpnIdList\narray(PlmnIdNid)\nO\n1..N\nA list of SNPN IDs associated with the SEPP, which is sending the request. The list to be stored by the receiving SEPP in a N32-f Context (see clause 5.9.3 in 3GPP TS 33.501 [6])\ntargetPlmnId\nPlmnId\nO\n1\nWhen present, this IE shall contain a PLMN ID of the target SEPP.\nSee clause 5.2.2 step 1.\ntargetSnpnId\nPlmnIdNid\nO\n0..1\nWhen present, this IE shall contain a SNPN ID of the target SEPP. See clause 5.2.2 step 1.\nintendedUsagePurpose\narray(IntendedN32Purpose)\nO\n1..N\nThis attribute notifies the list of requested usage purpose the N32 is established for.\nsupportedFeatures\nSupportedFeatures\nC\n0..1\nThis IE shall be present if at least one feature defined in clause 6.1.7 is supported\nsenderN32fFqdn\nFqdn\nO\n0..1\nThis IE may be present if the sending SEPP wishes the receiving SEPP to establish the N32-f connection towards a specific FQDN.\n(NOTE 2)\nSNDN32F\nsenderN32fPortList\narray(Uinteger)\nO\n1..N\nThis IE may be present if the sending SEPP wishes the receiving SEPP to establish the N32-f connection using a specific port number.\nThe N32-f ports list shall contain one port number per security capability encoded in the supportedSecCapabilityList IE and it shall be ordered in the same order as the security capabilities list. For example, if TLS is the first security capability in the supportedSecCapabilityList, then the first N32-f port in the senderN32fPortList shall be for TLS.\n(NOTE 3)\nSNDN32F\nn32KeepaliveTimer\nDurationSec\nO\n0..1\nThis IE may be present if the initiating SEPP wishes to indicate for how long it maintains the N32-f connection in the absence of incoming traffic (see clause 5.3.3.5).\nNOTE 1:\tThe attribute name does not follow the naming conventions specified in 3GPP TS 29.501 [5]. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nNOTE 2: \tIf the senderN32fFqdn IE is absent, the receiving SEPP establishes the N32-f connection towards the sending SEPP using the N32-c FQDN and/or local configuration.\nNOTE 3:\tIf the senderN32fPortList IE is absent, the receiving SEPP shall use a locally configured port if any, otherwise the default HTTPs port number, i.e., TCP port 443 for \"https\" URIs as specified in IETF RFC 9113 [7].",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.3.3.2",
        "ts_33.501_clause_5.9.3",
        "clause_5.2.2",
        "clause_6.1.7",
        "clause_5.3.3.5",
        "table_6.1.5.2.2-1",
        "ts_33.501",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.3",
      "section_id": "6.1.5.2.3",
      "section_title": "Type: SecNegotiateRspData",
      "content": "Table 6.1.5.2.3-1: Definition of type SecNegotiateRspData\nAttribute name\nData type\nP\nCardinality\nDescription\nApplicability\nsender\nFqdn\nM\n1\nThis IE shall uniquely identify the SEPP that is sending the response. This IE is used to identify and store the negotiated security capability against the right SEPP.\nselectedSecCapability\nSecurityCapability\nM\n1\nThis IE shall contain the security capability selected by the responding SEPP.\nWhen the request is for tearing down the N32-f TLS connection, the responding SEPP shall add SecurityCapability as \"NONE\".\nn32HandshakeId\nstring\nC\n0..1\nThis IE shall be present, if the N32 handshake identifier to was received in the request and the responding SEPP supports the N32 handshake identifier.\nWhen present, this IE shall contain the N32 handshake identifier to be used by the initiating SEPP for:\n- TLS protected message forwarding procedure over N32-f towards the responding SEPP\n- subsequent N32-c signalling request related to this N32-c connection (e.g. to request to tear down the N32-f TLS connection)\nThe n32HandshakeId in the response may have a different value than the n32HandshakeId received in the request.\nThe n32HandshakeId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32 handshake Id shall appear first in the string, and the character representing the 4 least significant bit of the N32 handshake Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".\n3GppSbiTargetApiRootSupported\nboolean\nC\n0..1\nThis IE should be present and indicate that the 3gpp-Sbi-Target-apiRoot HTTP header is supported, if TLS security is negotiated for N32f message forwarding and the initiating SEPP indicated support of this header.\nWhen present, it shall indicate if TLS security using the 3gpp-Sbi-Target-apiRoot HTTP header is supported:\n- true: supported\n- false (default): not supported\n(NOTE 1)\nplmnIdList\narray(PlmnId)\nO\n1..N\nA list of PLMN IDs of a single PLMN associated with the SEPP, which is sending the response. The list to be stored by the receiving SEPP in a N32-f Context (see clause 5.9.3 in 3GPP TS 33.501 [6]).\nIf different PLMNs are represented by different PLMN IDs supported by a SEPP, then the SEPP shall select the PLMN as specified in clause 5.2.2 step 2a.\nsnpnIdList\narray(PlmnIdNid)\nO\n1..N\nA list of SNPN IDs of a single SNPN associated with the SEPP, which is sending the response. The list to be stored by the receiving SEPP in a N32-f Context (see clause 5.9.3 in 3GPP TS 33.501 [6]).\nIf different SNPNs are represented by different SNPN IDs supported by a SEPP, then the SEPP shall select the SNPN as specified in clause 5.2.2 step 2a.\nallowedUsagePurpose\narray(IntendedN32Purpose)\nO\n1..N\nThis attribute notifies the list of allowed usage purpose the N32 is established for.\nIntendedN32Purpose shall not include attribute \"cause\".\nrejectedUsagePurpose\narray(IntendedN32Purpose)\nO\n1..N\nThis attribute notifies the list of rejected usage purpose the N32 is established for.\nShall only be present if any of the requested usage purpose is rejected.\nsupportedFeatures\nSupportedFeatures\nC\n0..1\nThis IE shall be present if at least one feature defined in clause 6.1.7 is supported\nsenderN32fFqdn\nFqdn\nO\n0..1\nThis IE may be present if the sending SEPP wishes the receiving SEPP to establish the N32-f connection towards a specific FQDN.\n(NOTE 2)\nSNDN32F\nsenderN32fPort\nUinteger\nO\n0..1\nThis IE may be present if the sending SEPP wishes the receiving SEPP to establish the N32-f connection using a specific port number.\n(NOTE 3)\nSNDN32F\nn32KeepaliveTimer\nDurationSec\nO\n0..1\nThis IE may be present if the responding SEPP wishes to indicate for how long it maintains the N32-f connection in the absence of incoming traffic (see clause 5.3.3.5).\nNOTE 1:\tThe attribute name does not follow the naming conventions specified in 3GPP TS 29.501 [5]. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nNOTE 2:\tIf the senderN32fFqdn IE is absent, the receiving SEPP establishes the N32-f connection towards the sending SEPP using the N32-c FQDN and/or local configuration.\nNOTE 3:\tIf the senderN32fPort number is absent, the receiving SEPP shall use a locally configured port, if any, otherwise the default HTTPs port number, i.e., TCP port 443 for \"https\" URIs as specified in IETF RFC 9113 [7].",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_33.501_clause_5.9.3",
        "clause_5.2.2",
        "clause_6.1.7",
        "clause_5.3.3.5",
        "table_6.1.5.2.3-1",
        "ts_33.501",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.4",
      "section_id": "6.1.5.2.4",
      "section_title": "Type: SecParamExchReqData",
      "content": "Table 6.1.5.2.4-1: Definition of type SecParamExchReqData\nAttribute name\nData type\nP\nCardinality\nDescription\nApplicability\nn32fContextId\nstring\nM\n1\nThis IE shall contain the context identifier to be used by the responding SEPP for subsequent JOSE protected message forwarding procedure over N32-f towards the initiating SEPP. The initiating SEPP shall use this context identifier to locate the cipher suite and protection policy exchanged and agreed to be used with the responding SEPP, for the message forwarding procedure over N32-f.\nThe n32fContextId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32-f context Id shall appear first in the string, and the character representing the 4 least significant bit of the N32-f context Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".\njweCipherSuiteList\narray(string)\nC\n1..N\nThis IE shall be present during the parameter exchange procedure for cipher suite negotiation (see clause 5.2.3.2). When present, this IE shall contain the ordered list of JWE cipher suites supported by the requesting SEPP. Valid values for the string are as specified in clause 5.1 of IETF RFC 7518 [13].\njwsCipherSuiteList\narray(string)\nC\n1..N\nThis IE shall be present during the parameter exchange procedure for cipher suite negotiation (see clause 5.2.3.2). When present, this IE shall contain the ordered list of JWS cipher suites supported by the requesting SEPP. Valid values for the string are as specified in clause 3.1 of IETF RFC 7518 [13].\nprotectionPolicyInfo\nProtectionPolicy\nC\n0..1\nEither this IE or the secProfiles IE shall be present during the parameter exchange procedure for protection policy exchange(see clause 5.2.3.3). When present, this IE shall contain the data type encryption policy requested by the requesting SEPP and/or the modification policy supported by the RI(s) on the side of the requesting SEPP.\nsecProfiles\narray(string)\nC\n1..N\nEither this IE or the protectionPolicyInfo IE shall be present during the parameter exchange procedure for protection policy exchange(see clause 5.2.3.3).\nWhen present, this IE shall indicate the candidate list of security profiles that the initiating SEPP is supporting for PRINS.\nThe list may contain up to 256 profiles.\nPSEPRO\nipxProviderSecInfoList\narray(IpxProviderSecInfo)\nC\n1..N\nThis IE includes the list of RI security information.\nsender\nFqdn\nC\n0..1\nThis IE shall be present if the Parameter Exchange request is sent on a different N32-c HTTP connection than the one used to perform the Security Capability Negotiation procedure. It may be present otherwise.\nWhen present, it shall uniquely identify the SEPP that is sending the request. This IE is used to store the exchanged parameters against the right SEPP.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.2.3.2",
        "clause_5.1",
        "clause_3.1",
        "clause_5.2.3.3",
        "table_6.1.5.2.4-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.5",
      "section_id": "6.1.5.2.5",
      "section_title": "Type: SecParamExchRspData",
      "content": "Table 6.1.5.2.5-1: Definition of type SecParamExchRspData\nAttribute name\nData type\nP\nCardinality\nDescription\nApplicability\nn32fContextId\nstring\nM\n1\nThis IE shall contain the context identifier to be used by the initiating SEPP for subsequent JOSE protected message forwarding procedure over N32-f towards the responding SEPP. The responding SEPP shall use this context identifier to locate the cipher suite and protection policy exchanged and agreed to be used with the initiating SEPP, for the message forwarding procedure over N32-f.\nThe n32fContextId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32-f context Id shall appear first in the string, and the character representing the 4 least significant bit of the N32-f context Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".\nselectedJweCipherSuite\nstring\nC\n1\nThis IE shall be present during the parameter exchange procedure for cipher suite negotiation (see clause 5.2.3.2). When present, this IE shall contain the JWE cipher suite selected by the responding SEPP.\nselectedJwsCipherSuite\nstring\nC\n1\nThis IE shall be present during the parameter exchange procedure for cipher suite negotiation (see clause 5.2.3.2). When present, this IE shall contain the JWS cipher suite selected by the responding SEPP.\nselProtectionPolicyInfo\nProtectionPolicy\nC\n0..1\nThis IE shall be present during the parameter exchange procedure for protection policy exchange (see clause 5.2.3.3) if the initiating SEPP included the protectionPolicyInfo IE in the exchange parameter request message to the responding SEPP. When present, this IE shall contain the data type encryption policy selected by the responding SEPP and/or the modification policy supported by the RI(s) on the side of the responding SEPP.\nselSecProfiles\narray(string)\nC\n1..N\nThis IE shall indicate the list of selected security profiles applicable for messages forwarding over N32-f if the initiating SEPP sent a candidate list of security profiles in the exchange parameter request message to the responding SEPP.\nThe list may contain up to 256 profiles.\nPSEPRO\nipxProviderSecInfoList\narray(IpxProviderSecInfo)\nC\n1..N\nThis IE includes the list of RI security information.\nsender\nFqdn\nC\n0..1\nThis IE shall be present if the Parameter Exchange response is sent on a different N32-c HTTP connection than the one used to perform the Security Capability Negotiation procedure. It may be present otherwise.\nWhen present, it shall uniquely identify the SEPP that is sending the response. This IE is used to store the exchanged parameters against the right SEPP.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.2.3.2",
        "clause_5.2.3.3",
        "table_6.1.5.2.5-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.6",
      "section_id": "6.1.5.2.6",
      "section_title": "Type: ProtectionPolicy",
      "content": "Table 6.1.5.2.6-1: Definition of type ProtectionPolicy\nAttribute name\nData type\nP\nCardinality\nDescription\napiIeMappingList\narray(ApiIeMapping)\nM\n1..N\nContains an array of API URI to IE type - IE name mapping. The mapping includes an indication against each IE whether that IE is allowed to be modified by the RI on the side of the SEPP or not.\ndataTypeEncPolicy\narray(IeType)\nC\n1..N\nThis IE shall be present when the SEPPs need to exchange the IE protection policies. When present, this IE shall contain the list of IE types that the SEPP intends to protect by ciphering.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.2.6-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.7",
      "section_id": "6.1.5.2.7",
      "section_title": "Type: ApiIeMapping",
      "content": "Table 6.1.5.2.7-1: Definition of type ApiIeMapping\nAttribute name\nData type\nP\nCardinality\nDescription\napiSignature\nApiSignature\nM\n1\nThis IE shall contain:\n- The API URI of the NF service operations following request/response semantic; or\n- The API URI of the subscribe / unsubscribe service operation\napiMethod\nHttpMethod\nM\n1\nThis IE shall contain the HTTP method used by the API.\nIeList\narray(IeInfo)\nM\n1..N\nThis IE shall contain the array of Ies in the API.\n(NOTE 1, NOTE 2)\nNOTE 1:\tThe attribute name does not follow the naming conventions specified in 3GPP TS 29.501 [5]. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nNOTE 2:\tThe protection policy to apply for a recursive non-leaf IE shall be the same as the protection policy defined for the ancestor attribute with the same data type. Accordingly, the IeList signaled over N32-c shall not repeat/include the protection policies of the child attributes of the recursive non-leaf IE (see examples in Annex F).",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.2.7-1",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.8",
      "section_id": "6.1.5.2.8",
      "section_title": "Type: IeInfo",
      "content": "Table 6.1.5.2.8-1: Definition of type IeInfo\nAttribute name\nData type\nP\nCardinality\nDescription\nieLoc\nIeLocation\nM\n1\nThis IE shall contain the location of the IE mentioned in \"reqIe\" or \"rspIe\" (i.e Variable in URI path or URI query parameter or HTTP header or JSON body or multipart message)\nieType\nIeType\nM\n1\nThis IE shall contain the type of the IE, representing the nature of the information the IE is carrying.\nreqIe\nstring\nC\n0..1\nThis IE shall be included when the Ies in HTTP/2 request messages of an API need to be protected when forwarded over N32-f. When present, this IE shall contain:\n- The JSON pointer representation of the IE to be protected, if the \"ieLoc\" indicates \"BODY\". Only the JSON pointer of the leaf IEs and recursive non-leaf IEs are included;\n- The name of the Variable in URI path to be protected, if the \"ieLoc\" indicates \"URI_PATH\";\ne.g. the name \"{ueId}\" can be used to protect the UE ID in the following API URI:\"/nNf-service/v1/(ueId)/service-operation-1\"\n- The name of the URI query parameter to be protected, if the \"ieLoc\" indicates \"URI_PARAM\";\n- The name of the HTTP header, if the \"ieLoc\" indicates \"HEADER\";\n- The JSON pointer representation of the attribute defined with the RefToBinaryData type if the \"ieLoc\" indicates \"MULTIPART_BINARY\". It shall be encoded as: <JSON Pointer of the attribute defined with the RefToBinaryData type>/data.\nrspIe\nstring\nC\n0..1\nThis IE shall be included when the IEs in HTTP/2 response messages of an API need to be protected when forwarded over N32-f. When present, this IE shall contain:\n- The JSON pointer representation of the IE to be protected, if the \"ieLoc\" indicates \"BODY\". Only the JSON pointer of the leaf IEs and recursive non-leaf IEs are included;\n- The name of the HTTP header, if the \"ieLoc\" indicates \"HEADER\";\n- The JSON pointer representation of the attribute defined with the RefToBinaryData type if the \"ieLoc\" indicates \"MULTIPART_BINARY\". It shall be encoded as: <JSON Pointer of the attribute defined with the RefToBinaryData type>/data.\nisModifiable\nboolean\nC\n0..1\nThis IE shall be included if the IE is allowed to be modified by all RI(s) on the side of the SEPP sending the API IE mapping. When present,\n- true, indicates that the IE is allowed to be modified by all RI(s) on the side of the SEPP;\n- false, indicates that the IE is not allowed to be modified by any RI on the side of the SEPP;\n- default is false.\nWhen the IE is not included, the default value shall be applied.\n(NOTE 1, NOTE 2)\nisModifiableByIpx\nmap(boolean)\nC\n0..1\nThis IE shall be included if the IE is allowed to be modified by some of (but not all) the RI(s) on the side of the SEPP sending the API IE mapping. The key of the map is the ipxProviderId for which the boolean applies.\nWhen present, each element carries the isModifiable indication for the RI indicated by the key.\n(NOTE 1, NOTE 2)\nancestorIe\nstring\nC\n0..1\nThis IE shall be included when the IE type is RECURSIVE_NON_LEAF. When present, this IE shall contain a JSON pointer of the ancestor IE. See Annex F.3.\nNOTE 1:\tEither isModifiable or isModifiableByIpx may be present, but not both.\nNOTE 2:\tWhen the IE type is RECURSIVE_NON_LEAF, if any of its child attributes is modifiable, the recursive non-leaf IE shall be set to be modifiable (see examples in Annex F).",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.2.8-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.9",
      "section_id": "6.1.5.2.9",
      "section_title": "Type: ApiSignature",
      "content": "Table 6.1.5.2.9-1: Definition of type ApiSignature as a list of \"mutually exclusive alternatives\"\nData type\nCardinality\nDescription\nApplicability\nUri\n1\nAPI URI of a request/response or subscribe/unsubscribe NF service operation as specified in the respective API specification with the variable parts other than {apiVersion} unresolved.\nExamples:\n\"{apiRoot}/nsmf-pdusession/v1/sm-contexts\", for the SMF PDUSession Create SM Context service operation.\n\"{apiRoot}/nsmf-pdusession/v1/sm-contexts/{smContextRef}/modify\", for the SMF PDUSession Update SM Context service operation.\n.\nCallbackName\n1\nA value identifying the type of callback.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.2.9-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.10",
      "section_id": "6.1.5.2.10",
      "section_title": "Type: N32fContextInfo",
      "content": "Table 6.1.5.2.10-1: Definition of type N32fContextInfo\nAttribute name\nData type\nP\nCardinality\nDescription\nn32fContextId\nstring\nM\n1\nThis IE shall contain the N32-f context identifier of the receiving SEPP.\nThe n32fContextId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32-f context Id shall appear first in the string, and the character representing the 4 least significant bit of the N32-f context Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.2.10-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.11",
      "section_id": "6.1.5.2.11",
      "section_title": "Type: N32fErrorInfo",
      "content": "Table 6.1.5.2.11-1: Definition of type N32fErrorInfo\nAttribute name\nData type\nP\nCardinality\nDescription\nn32fMessageId\nstring\nM\n1\nThis IE shall contain the N32-f message identifier received over N32-f (see clause 6.2.5.2.9).\nn32fErrorType\nN32fErrorType\nM\n1\nThis IE shall contain the type of processing error encountered by the SEPP or the RI initiating the N32-f error reporting procedure.\nn32fContextId\nstring\nC\n0..1\nThis IE shall be present if available.\nWhen present, this IE shall contain the n32fContextId of the SEPP receiving N32-f error reporting message, which is exchanged between the SEPPs during the parameter exchange procedure (see clause 5.2.3).\nThe n32fContextId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32-f context Id shall appear first in the string, and the character representing the 4 least significant bit of the N32-f context Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".\nfailedModificationList\narray(FailedModificationInfo)\nC\n1..N\nThis IE shall be present if the n32ErrorType is \"INTEGRITY_CHECK_ON_MODIFICATIONS_FAILED\" or \"MODIFICATIONS_INSTRUCTIONS_FAILED\". When present this IE shall contain a list of FQDNs of the RIs whose inserted modifications failed to process at the SEPP initiating the N32-f error reporting procedure, together with the reason for the failure to process.\nerrorDetailsList\narray(N32fErrorDetail)\nO\n1..N\nThis IE may be included when the n32ErrorType IE indicates \"MESSAGE_RECONSTRUCTION_FAILED \". When present, this IE shall contain a list of JSON pointers to the IEs that failed to process together with the reason for the failure to process that IE.\npolicyMismatchList\narray(InvalidParam)\nO\n1..N\nThis IE may be included when n32ErrorType is \"POLICY_MISMATCH\". When present, this IE shall indicate a list of JSON pointers to the IEs and the type of mismatch.\n-\tIf the parameter was sent in plain while it should have been encrypted, the value \"Parameter shall be encrypted\" shall be set as the reason.\n-\tIf the parameter was sent confidentiality protected when required without confidentially protected, value \"Parameter shall not be encrypted\" shall be set as the reason.\nriErrorInformation\nRiErrorInformation\nO\n0..1\nThis IE may be included by a RI when it indicates an error to the SEPP. When present, it shall instruct the SEPP to terminate or re-establish the N32-f connection and/or N32-f context (see clause 5.5.4).",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.2.5.2.9",
        "clause_5.2.3",
        "clause_5.5.4",
        "table_6.1.5.2.11-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.12",
      "section_id": "6.1.5.2.12",
      "section_title": "Type: FailedModificationInfo",
      "content": "Table 6.1.5.2.12-1: Definition of type FailedModificationInfo\nAttribute name\nData type\nP\nCardinality\nDescription\nipxId\nFqdn\nM\n1\nThis IE shall identify the RI.\nn32fErrorType\nN32fErrorType\nM\n1\nThis IE shall contain the type of processing error on the modifications block, encountered by the SEPP initiating the N32-f error reporting procedure. The value shall be one of the following:\nINTEGRITY_CHECK_ON_MODIFICATIONS_FAILED;\nMODIFICATIONS_INSTRUCTIONS_FAILED",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.2.12-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.13",
      "section_id": "6.1.5.2.13",
      "section_title": "Type: N32fErrorDetail",
      "content": "Table 6.1.5.2.13-1: Definition of type N32fErrorDetail\nAttribute name\nData type\nP\nCardinality\nDescription\nattribute\nstring\nM\n1\nContains either a HTTP header name or the JSON pointer of an attribute within the N32-f message that failed to reconstruct. The value shall be one of the values of the iePath attribtue (see clause 6.2.5.2.8) in the received N32-f message.\nmsgReconstructFailReason\nFailureReason\nM\n1\nIndicates the reason for the failure to reconstruct the attribute.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.5.2.8",
        "table_6.1.5.2.13-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.14",
      "section_id": "6.1.5.2.14",
      "section_title": "Type: CallbackName",
      "content": "Table 6.1.5.2.14-1: Definition of type CallbackName\nAttribute name\nData type\nP\nCardinality\nDescription\ncallbackType\nstring\nM\n1\nThis IE shall contain a string identifying the type of callback. The value shall be one of the values specified in 3GPP 29.500 [4], Annex B.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.2.14-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.15",
      "section_id": "6.1.5.2.15",
      "section_title": "Type: IpxProviderSecInfo",
      "content": "Table 6.1.5.2.15-1: Definition of type IpxProviderSecInfo\nAttribute name\nData type\nP\nCardinality\nDescription\nipxProviderId\nFqdn\nM\n1\nThis IE shall uniquely identify the RI.\nrawPublicKeyList\narray(string)\nC\n1..N\nThis IE includes the list of raw public keys for the RI.\nWhen present, each array item shall contain a raw public key for the RI, with textual encoding as specified in clause 13 of IETF RFC 7468 [21].\ncertificateList\narray(string)\nC\n1..N\nThis IE includes the list of certificates for the RI.\nWhen present, each array item shall contain a certificate for the RI, with textual encoding as specified in IETF RFC 7468 [21].\nNOTE:\tEither the rawPublicKeyList attribute, or the certificateList attribute, shall be present.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_13",
        "table_6.1.5.2.15-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.16",
      "section_id": "6.1.5.2.16",
      "section_title": "Type: IntendedN32Purpose",
      "content": "Table 6.1.5.2.16-1: Definition of type IntendedN32Purpose\nAttribute name\nData type\nP\nCardinality\nDescription\nusagePurpose\nN32Purpose\nM\n1\nThis attribute provides the one purpose of the intended N32 establishment.\nadditionalInfo\nString\nO\n0..1\nThis attribute provides any additional information necessary to characterize the intention for N32 establishment.\ncause\nString\nO\n0..1\nThis attribute, if present, provided the reason for the reject for the purpose described in other attributes are rejected (e.g. \"NO_CONTRACT\").\nThis attribute shall be absent if the intended purpose is allowed.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.2.16-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.17",
      "section_id": "6.1.5.2.17",
      "section_title": "Type: RiErrorInformation",
      "content": "Table 6.2.5.2.17-1: Definition of type RiErrorInformation\nAttribute name\nData type\nP\nCardinality\nDescription\nn32fConnectionRelInd\nN32ReleaseIndication\nC\n0..1\nWhen present, this IE shall instruct the SEPP to only terminate or re-establish the N32-f connection (see clause 5.5.4). (NOTE)\nn32fContextRelInd\nN32ReleaseIndication\nC\n0..1\nWhen present, this IE shall instruct the SEPP to terminate or re-establish the N32-f context and N32-f connection (see clause 5.5.4). (NOTE)\nalternativeRi\nFqdn\nO\n0..1\nThis IE may be present if the n32fConnectionRelInd or n32fContextRelInd is present and instructs the SEPP to re-establish the N32-f connection or N32-f context.\nWhen present, this IE shall indicate the FQDN of the alternative RI entity that the SEPP should use to re-establish the N32-f context or the N32-f connection towards the peer SEPP.\nNOTE:\tEither the n32fConnectionRelInd IE or the n32fContextRelInd IE may be present.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.5.4",
        "table_6.2.5.2.17-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.18",
      "section_id": "6.1.5.2.18",
      "section_title": "Type: ExtRedirectResponse",
      "content": "Table 6.1.5.2.18-1: Definition of type ExtRedirectResponse as a list of to be combined data types\nData type\nCardinality\nDescription\nApplicability\nRedirectResponse\n1\nRedirection response\nRedirectResponseAddInfo\n1\nAdditional information in the redirection response",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.2.18-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.2.19",
      "section_id": "6.1.5.2.19",
      "section_title": "Type: RedirectResponseAddInfo",
      "content": "Table 6.1.5.2.19-1: Definition of type RedirectResponseAddInfo\nAttribute name\nData type\nP\nCardinality\nDescription\nseppFqdnForDiscovery\nFqdn\nC\n0..1\nFQDN of the SEPP towards which an N32 interface HTTP request is redirected with target SEPP discovery.\nThis IE shall be present when the cause is set to \"SEPP_REDIRECTION_WITH_DISCOVERY\".",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.2.19-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.1",
      "section_id": "6.1.5.3.1",
      "section_title": "Introduction",
      "content": "This clause defines simple data types and enumerations that can be referenced from data structures defined in the previous clauses.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.2",
      "section_id": "6.1.5.3.2",
      "section_title": "Simple data types",
      "content": "The simple data types defined in table 6.1.5.3.2-1 shall be supported.\nTable 6.1.5.3.2-1: Simple data types\nType Name\nType Definition\nDescription",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.3.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.3",
      "section_id": "6.1.5.3.3",
      "section_title": "Enumeration: SecurityCapability",
      "content": "Table 6.1.5.3.3-1: Enumeration SecurityCapability\nEnumeration value\nDescription\nApplicability\n\"TLS\"\nTLS security.\n\"PRINS\"\nPRotocol for N32 INterconnect Security.\n\"NONE\"\nN32-f TLS connection termination\nNFTLST",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.3.3-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.4",
      "section_id": "6.1.5.3.4",
      "section_title": "Enumeration: HttpMethod",
      "content": "Table 6.1.5.3.4-1: Enumeration HttpMethod\nEnumeration value\nDescription\n\"GET\"\nHTTP GET Method.\n\"PUT\"\nHTTP PUT Method.\n\"POST\"\nHTTP POST Method.\n\"DELETE\"\nHTTP DELETE Method.\n\"PATCH\"\nHTTP PATCH Method.\n\"HEAD\"\nHTTP HEAD Method.\n\"OPTIONS\"\nHTTP OPTIONS Method.\n\"CONNECT\"\nHTTP CONNECT Method.\n\"TRACE\"\nHTTP TRACE Method.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.3.4-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.5",
      "section_id": "6.1.5.3.5",
      "section_title": "Enumeration: IeType",
      "content": "Table 6.1.5.3.5-1: Enumeration IeType\nEnumeration value\nDescription\n\"UEID\"\nThese are IEs which carry the  UE identity (i.e. SUPI and GPSI). This also includes the long-lasting identity Charging ID.\nAn example of a UEID IE is gpsi IE defined in 3GPP TS 29.518 [25].\n\"LOCATION\"\nThese are IEs which carry location information (i.e. cell-id and TAI).\nAn example of a LOCATION IE is ncgi IE defined in 3GPP TS 29.571 [12].\n\"KEY_MATERIAL\"\nThese are IEs which carry keying material as KSEAF and UPU related information.\nAn example of a KEY_MATERIAL IE is upuInfo IE defined in 3GPP TS 29.503 [26].\n\"AUTHENTICATION_MATERIAL\"\nThese are IEs which carry authentication material like authentication vectors and EAP payload.\nAn example of an AUTHENTICATION_MATERIAL IE is authenticationVector IE defined in 3GPP TS 29.503 [26].\n\"AUTHORIZATION_TOKEN\"\nThese are IEs which carry authorization Token. The oauth2 access_token would be of this type.\nAn example of an AUTHORIZATION_TOKEN IE is access_token IE defined in 3GPP TS 29.510 [18].\n\"RECURSIVE_NON_LEAF\"\nThese are recursive non-leaf IEs (see definition in clause 3.1).\n\"OTHER\"\nThese are IEs which do not fall into one of the above types, but they would be considered sensitive, and which protection policies may wish to apply confidentiality protection.\n\"NONSENSITIVE\"\nThese are IEs which carry information that are not sensitive. A protection policy would not normally encrypt (confidentiality protect) these.",
      "chunk_type": "general",
      "cross_references": [
        "clause_3.1",
        "table_6.1.5.3.5-1",
        "ts_29.518",
        "ts_29.571",
        "ts_29.503",
        "ts_29.510"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.6",
      "section_id": "6.1.5.3.6",
      "section_title": "Enumeration: IeLocation",
      "content": "Table 6.1.5.3.6-1: Enumeration IeLocation\nEnumeration value\nDescription\n\"URI_PARAM\"\nIE is located in the URI query parameters.\n\"HEADER\"\nIE is located in the HTTP header.\n\"BODY\"\nIE is located in the body.\n\"MULTIPART_BINARY\"\nIE is located in the message body but encoded as a multipart message information in binary format.\n\"URI_PATH\"\nIE is located in the URI path excluding query parameters.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.3.6-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.7",
      "section_id": "6.1.5.3.7",
      "section_title": "Enumeration: N32fErrorType",
      "content": "Table 6.1.5.3.7-1: Enumeration N32fErrorType\nEnumeration value\nDescription\n\"INTEGRITY_CHECK_FAILED\"\nThe integrity check verification on the received N32-f message failed.\n\"INTEGRITY_CHECK_ON_MODIFICATIONS_FAILED\"\nThe integrity check verification on the modifications block of the received N32-f message failed.\n\"MODIFICATIONS_INSTRUCTIONS_FAILED\"\nFailed to apply the JSON patch instructions in the modifications block of the received N32-f message, e.g. the references to encBlockIndex are inserted or relocated by RI (see clause 5.9.3.2 of 3GPP TS 33.501 [6]).\n\"DECIPHERING_FAILED\"\nThe deciphering of the encrypted block of the received N32-f message failed.\n\"MESSAGE_RECONSTRUCTION_FAILED\"\nThe reconstruction of the original HTTP/2 message from the received N32-f message failed.\n\"CONTEXT_NOT_FOUND\"\nThe n32fContextId is unknown in the receiving SEPP. (NOTE 1)\n\"INTEGRITY_KEY_EXPIRED\"\nThe integrity keys in the receiving SEPP have expired.\n\"ENCRYPTION_KEY_EXPIRED\"\nThe encryption keys in the receiving SEPP have expired.\n\"POLICY_MISMATCH\"\nThe encryption policy verification on the received N32-f message has failed, e.g. protected IEs are not ciphered, or unprotected IEs are ciphered.\n\"NETWORK_MAINTENANCE\"\nNetwork maintenance is going on at the RI.\n(NOTE 2)\n\"INSUFFICIENT_RESOURCES\"\nThere is an on-going resources exhaustion at the RI (e.g., memory, CPU, or network bandwidth).\n(NOTE 2)\n\"NO_CONNECTION_DUE_TO_CONTRACT\"\nThe RI decides to no longer facilitate communication with a specific PLMN due to business reasons (e.g., contract termination or fraudulent behaviour).\n(NOTE 2)\n\"IDLE_N32F_CONNECTION\"\nThe N32-f connection has been found inactive by the RI.\n(NOTE 2)\n\"SWITCHING_TO_ANOTHER_RI\"\nThe service is being taken over by another RI, e.g. due to the RI shutting down.\n(NOTE 2)\n\"NO_CONNECTION_DUE_TO_CONNECTIVITY\"\nThe RI observes connectivity issues with one of the SEPPs.\n(NOTE 2)\nNOTE 1:\tThis enumeration value is deprecated and shall not be used by N32-f error reporting procedure over the N32-c interface.\nNOTE 2:\tThis cause may be sent by a RI together with an indication to release or re-establish the N32-f context and/or the N32-f connection (see clause 5.5.4).",
      "chunk_type": "general",
      "cross_references": [
        "ts_33.501_clause_5.9.3.2",
        "clause_5.5.4",
        "table_6.1.5.3.7-1",
        "ts_33.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.8",
      "section_id": "6.1.5.3.8",
      "section_title": "Enumeration: FailureReason",
      "content": "Table 6.1.5.3.8-1: Enumeration FailureReason\nEnumeration value\nDescription\n\"INVALID_JSON_POINTER\"\nThe JSON pointer value in iePath attribute (see clause 6.2.5.2.8) is invalid.\n\"INVALID_INDEX_TO_ENCRYPTED_BLOCK\"\nThe value part of the HttpPayload attribute (see clause 6.2.5.2.8) or HttpHeader attribute (see clause 6.2.5.2.7) is pointing to an invalid index to the encrypted block.\n\"INVALID_HTTP_HEADER\"\nThe name of the header in the received HttpHeader attribute is invalid.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.5.2.8",
        "clause_6.2.5.2.7",
        "table_6.1.5.3.8-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.9",
      "section_id": "6.1.5.3.9",
      "section_title": "Enumeration: N32Purpose",
      "content": "Table 6.1.5.3.9-1: Enumeration N32Purpose\nEnumeration value\nDescription\n\"ROAMING\"\nUsage dedicated to roaming\n\"INTER_PLMN_MOBILITY\"\nUsage corresponding to any inter-mobility transactions\n\"SMS_INTERCONNECT\"\nUsage dedicated to SMS interconnect, e.g. SMS sent between subscribers of two different networks\n\"ROAMING_TEST\"\nUsage dedicated to roaming, and allowed only for tests, e.g. to allow traffic for test subscribers/SUPI or sessions\n\"INTER_PLMN_MOBILITY_TEST\"\nUsage corresponding to any inter-mobility transactions and allowed only for tests, e.g. to allow traffic for test subscribers/SUPI or sessions\n\"SMS_INTERCONNECT_TEST\"\nUsage dedicated to SMS interconnect, e.g. SMS sent between subscribers of two different networks, and allowed only for tests, e.g. to allow traffic for test subscribers/SUPI or sessions\n\"SNPN_INTERCONNECT\"\nUsage dedicated to an interconnection with an SNPN\n\"SNPN_INTERCONNECT_TEST\"\nUsage corresponding to any interconnection with an SNPN and allowed only for tests, e.g. to allow traffic for test subscribers/SUPI or sessions\n\"DISASTER_ROAMING\"\nUsage dedicated to Disaster Roaming (see clause 5.40 of 3GPP TS 23.501 [2]).\n\"DISASTER_ROAMING_TEST\"\nUsage dedicated to Disaster Roaming (see clause 5.40 of 3GPP TS 23.501 [2]) and allowed only for tests, e.g. to allow traffic for test subscribers/SUPI or sessions.\n\"DATA_ANALYTICS_EXCHANGE\"\nUsage dedicated to exchanging data or analytics (see clause 4.3 of 3GPP TS 23.288 [29]).\n\"DATA_ANALYTICS_EXCHANGE_TEST\"\nUsage dedicated to exchanging data or analytics (see clause 4.3 of 3GPP TS 23.288 [29]) and allowed only for tests, e.g. to allow traffic for test subscribers/SUPI or sessions.",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.501_clause_5.40",
        "ts_23.288_clause_4.3",
        "table_6.1.5.3.9-1",
        "ts_23.501",
        "ts_23.288"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.3.10",
      "section_id": "6.1.5.3.10",
      "section_title": "Enumeration: N32ReleaseIndication",
      "content": "Table 6.1.5.3.10-1: Enumeration N32ReleaseIndication\nEnumeration value\nDescription\n\"RELEASE_REESTABLISHMENT_ALLOWED\"\nIndicates a request to the SEPP to terminate the N32-f context or N32-f connection. The SEPP may re-establish the N32-f context or N32-f connection later, if needed.\n\"RELEASE_REESTABLISHMENT_NOT_ALLOWED\"\nIndicates a request to the SEPP to terminate the N32-f context or N32-f connection. The SEPP should not attempt to re-establish the N32-f context or N32-f connection later.\n\"REESTABLISH\"\nIndicates a request to the SEPP to release and re-establish the N32-f context or N32-f connection.",
      "chunk_type": "general",
      "cross_references": [
        "table_6.1.5.3.10-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.5.4",
      "section_id": "6.1.5.4",
      "section_title": "Binary data",
      "content": "There are no multipart/binary part used on the N32-c API(s) in this release of this specification.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.1.6.1",
      "section_id": "6.1.6.1",
      "section_title": "General",
      "content": "HTTP error handling shall be supported as specified in clause 5.2.4 of 3GPP TS 29.500 [4].",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.6.2",
      "section_id": "6.1.6.2",
      "section_title": "Protocol Errors",
      "content": "Protocol Error Handling shall be supported as specified in clause 5.2.7.2 of 3GPP TS 29.500 [4].",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_5.2.7.2",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.6.3",
      "section_id": "6.1.6.3",
      "section_title": "Application Errors",
      "content": "The common application errors defined in the Table 5.2.7.2-1 in 3GPP TS 29.500 [4] may also be used for the N32-c Handshake service. The following application errors listed in Table 6.1.6.3-1 are specific for the N32-c Handshake service.\nTable 6.1.6.3-1: Application errors\nApplication Error\nHTTP status code\nDescription\nREQUESTED_PARAM_MISMATCH\n409 Conflict\nThis represents a parameter mismatch has been detected by the receiving SEPP, i.e. received data-type encryption or modification policy conflict with the one manually configured for the specific roaming partner, interconnect partner and RI\nREQUESTED_PURPOSE_NOT_ALLOWED\n403 Forbidden\nThis represents that all the requested purposes included in the request was rejected by the receiving SEPP.\nNEGOTIATION_NOT_ALLOWED\n403 Forbidden\nThis represents a security capability negotiation failure at the receiving SEPP, i.e., the received security capability from the peer SEPP is not configured to be supported at the receiving SEPP.\nN32C_EXCHANGE_CAPABILITY_ONGOING\n409 Conflict\nThis represents a security capability negotiation failure at the receiving SEPP, i.e., the SEPP receives an N32-c exchange capability request from a peer SEPP while it is expecting an exchange capability response from the same peer SEPP as specified in clause 5.2.2.\nSECURITY_PARAM_EXCHANGE_COLLISION\n409 Conflict\nThis represents a Parameter Exchange Procedure for Cipher Suite Negotiation failure at the receiving SEPP, i.e., the SEPP receives a security parameter exchange request from a peer SEPP while it is expecting a security parameter exchange response from the same peer SEPP as specified in clause 5.2.3.2.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2.2",
        "clause_5.2.3.2",
        "ts_29.500_table_5.2.7.2-1",
        "table_6.1.6.3-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.7",
      "section_id": "6.1.7",
      "section_title": "Feature Negotiation",
      "content": "The feature negotiation mechanism specified in clause 6.6 of 3GPP TS 29.500 [4] shall be used to negotiate the features applicable between the c-SEPP and the p-SEPP, for the N32 Handshake service, if any.\nThe c-SEPP shall indicate the features it supports for the N32 Handshake service, if any, by including the supportedFeatures attribute in the HTTP POST request message for following service operations:\n-\tSecurity Capability Negotiation procedure, as specified in clause 5.2.2 to negotiate the security capability;\nThe p-SEPP shall determine the supported features for the requested network as specified in clause 6.6 of 3GPP TS 29.500 [4] and shall indicate the supported features by including the supportedFeatures attribute in content of the HTTP response for the service operation.\nThe syntax of the supportedFeatures attribute is defined in clause 5.2.2 of 3GPP TS 29.571 [12].\nThe following features are defined for the N32 Handshake service.\nTable 6.1.7-1: Features of supportedFeatures attribute used by N32 Handshake service\nFeature Number\nFeature\nM/O\nDescription\n1\nNFTLST\nO\nN32-f TLS Connection Termination Support\nA SEPP that supports this feature shall support handling of Security Capability Negotiation procedure to tear down the N32-f TLS connection as specified in clause 5.2.2).\n2\nPSEPRO\nO\nPRINS Security Profiles Support\nA SEPP that supports this feature shall support the negotiation of security profiles as specified in clause 5.2.3.3.\n3\nPSIU\nM\nProtection of Sensitive Information in URI (Path and Query Parameters)\nA SEPP that complies with this release of the specification shall support this feature, i.e. the protection of sensitive information in URI path and query parameters in HTTP messages to be forwarded.\n4\nSNDN32F\nO\nSupport of N32-f FQDN and N32-f Port.\nA SEPP that supports this feature:\n- may signal an N32-f FQDN and Port within the Security Capability Negotiation towards the remote SEPP;\n- shall support receiving a N32-f FQDN and Port(s) within the Security Capability Negotiation from the remote SEPP\n- shall support forwarding the N32-f traffic towards the N32-f FQDN and Port received from the peer SEPP.\n5\nTLSCOR\nO\nCorrelation of TLS for N32-c and N32-f\nA SEPP that supports this feature:\n- shall correlate the context of N32-c and N32-f at time of N32 connection establishment, using procedures as specified in clause 5.3.3.2.2 if the initiating SEPP does not send any pending HTTP service request message to the responding SEPP immediately after establishing the TLS session for the N32-f connection. This enables N32-c and N32-f correlation in case there is not any N32-f messages sent by the initiating SEPP.\nFeature number: The order number of the feature within the supportedFeatures attribute (starting with 1).\nFeature: A short name that can be used to refer to the bit and to the feature.\nM/O: Defines if the implementation of the feature is mandatory (\"M\") or optional (\"O\").\nDescription: A clear textual description of the feature.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_6.6",
        "clause_5.2.2",
        "ts_29.571_clause_5.2.2",
        "clause_5.2.3.3",
        "clause_5.3.3.2.2",
        "table_6.1.7-1",
        "ts_29.500",
        "ts_29.571"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.8.1",
      "section_id": "6.1.8.1",
      "section_title": "HTTP redirection to a dedicated SEPP",
      "content": "An N32 HTTP request may be redirected to a different SEPP service instance located within the same PLMN.\nIf e.g. a SEPP-A1 in PLMN-A receives a N32 HTTP request from another, e.g. SEPP-B that is in PLMN-B and redirects the request to another SEPP-A2 in PLMN-A, the SEPP-A1 shall send 307 Temporary Redirect response to the SEPP-B and may include a RedirectResponse data structure (see 3GPP TS 29.571 [12]) in the response, where the \"cause\" attribute shall not be set to \"SEPP_REDIRECTION\" and the \"targetSepp\" attribute shall be absent. The Location header shall contain the URI of the SEPP-A2.\nNOTE 1:\tA sender that receives a redirectResponse with the cause \"SEPP_REDIRECTION\" ignores the Location header as specified in clause 6.10.9.1 in 3GPP TS 29.500 [4], accordingly this cause is not used for redirecting N32 request for which the location header is used to convey the URI of the SEPP to which the request is redirected.\nNOTE 2:\tFor non N32 interfaces, if a SEPP receives a service request from a HTTP client e.g. an NF or an SCP, from the same PLMN and redirects the service request to a different SEPP in the same PLMN, the SEPP sends 307 Temporary Redirect or 308 Permanent Redirect response to the HTTP client including a RedirectResponse data structure (see 3GPP TS 29.571 [12]), where the \"cause\" attribute sets to \"SEPP_REDIRECTION\" and the \"targetSepp\" attribute contains the apiRoot of the SEPP towards which the request is redirected. The content of the Location header field is ignored by the receiver. See clause 6.10.9.1 in 3GPP TS 29.500 [4].",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.500_clause_6.10.9.1",
        "ts_29.571",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.1.8.2",
      "section_id": "6.1.8.2",
      "section_title": "HTTP redirection to target SEPPs with a new discovery",
      "content": "An N32 HTTP request may be redirected to a list of possible new target SEPPs service instance located within the same PLMN.\nIf e.g. a SEPP-A1 in PLMN-A receives a N32 HTTP request from another, e.g. SEPP-B that is in PLMN-B, and redirects the request to another SEPP in PLMN-A that is to be discovered by SEPP-B, the SEPP-A1 shall send a 307 Temporary Redirect response to the SEPP-B and shall also include the ExtRedirectResponse data structure in the response, where the \"cause\" attribute shall be set to \"SEPP_REDIRECTION_WITH_DISCOVERY\" and the \"seppFqdnForDiscovery\" attribute shall contain a FQDN that can be resolved by DNS based SEPP discovery. The Location header shall be ignored.\nNOTE 1:\tThe response as described in clause 6.1.8.1 provides the receiving SEPP \"SEPP-B\" with a host FQDN that can be resolved to a target SEPP IP address. The response as described in clause 6.1.8.2 provides an FQDN that can be used by SEPP-B to send a DNS NAPTR query to discover the target SEPP.\nNOTE 2:\tThe FQDN in the \"seppFqdnForDiscovery\" attribute will be used by the SEPP that receives the HTTP redirection response to issue a DNS NAPTR query. This enables automated target SEPP discovery as defined in GSMA PRD IR.67 [30].",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1.8.1",
        "clause_6.1.8.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.1",
      "section_id": "6.2.1",
      "section_title": "API URI",
      "content": "The JOSE Protected Message Forwarding Procedure on N32 shall use the JOSE Protected Message Forwarding API on N32-f API.\nThe API URI of the JOSE Protected Message Forwarding API on N32-f API shall be:\n{apiRoot}/<apiName>/<apiVersion>\nThe request URIs used in HTTP requests from the initiating SEPP towards the responding SEPP shall have the Resource URI structure defined in clause 4.4.1 of 3GPP TS 29.501 [5], i.e.:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\nwith the following components:\n-\tThe {apiRoot} shall be set as described in 3GPP TS 29.501 [5].\n-\tThe <apiName> shall be \"n32f-forward\".\n-\tThe <apiVersion> shall be \"v1\".\n-\tThe <apiSpecificResourceUriPart> shall be set as described in clause 6.2.4.\nThe apiRoot to use towards a SEPP of the target PLMN shall be configured at the SEPP. The URI scheme of the API shall be \"http\". The apiName part of the URI shall be as specified here for homogeneity of the API across PLMNs.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.501_clause_4.4.1",
        "clause_6.2.4",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.2.1",
      "section_id": "6.2.2.1",
      "section_title": "General",
      "content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used as specified in clause 4.3.2.1.\nHTTP/2 shall be transported as specified in clause 4.3.3.\nHTTP messages and bodies for the JOSE protected message forwarding API on N32-f shall comply with the OpenAPI [27] specification contained in Annex A.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.1",
        "clause_4.3.3"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.2.2.1",
      "section_id": "6.2.2.2.1",
      "section_title": "General",
      "content": "The HTTP standard headers as specified in clause 4.3.2.2 shall be supported for this API.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.2.2.2",
      "section_id": "6.2.2.2.2",
      "section_title": "Content type",
      "content": "The following content types shall be supported:\n-\tthe JSON format (see IETF RFC 8259 [8]). The use of the JSON format shall be signalled by the content type \"application/json\". See also clause 5.3.4.\n-\tthe Problem Details JSON Object (see IETF RFC 9457 [22]). The use of the Problem Details JSON object in a HTTP response body shall be signalled by the content type \"application/problem+json\".",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.3.4"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.2.2.3",
      "section_id": "6.2.2.2.3",
      "section_title": "Accept-Encoding",
      "content": "SEPPs and RI should support gzip coding (see IETF RFC 1952 [23]) in HTTP requests and responses and indicate so in the Accept-Encoding header, as described in clause 5.3.2.1.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.3.2.1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.2.3.1",
      "section_id": "6.2.2.3.1",
      "section_title": "General",
      "content": "In this release of the specification, no specific custom headers are defined for the JOSE protected message forwarding API on N32.\nFor 3GPP specific HTTP custom headers used across all service based interfaces, see clause 4.3.2.3.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.3"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.3.1",
      "section_id": "6.2.3.1",
      "section_title": "Overview",
      "content": "There are no resources in this version of this API. All the operations are realized as custom operations without resources.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.2.4.1",
      "section_id": "6.2.4.1",
      "section_title": "Overview",
      "content": "Table 6.2.4.1-1: Custom operations without associated resources\nOperation Name\nCustom operation URI\nMapped HTTP method\nDescription\nJOSE Protected Forwarding\n/n32f-process\nPOST\nThis is the N32f forwarding API used to forward a reformatted and JOSE protected message to a receiving SEPP.\nJOSE Protected Forwarding Options\n/n32f-process\nOPTIONS\nDiscover the communication options supported by the next hop (RI or SEPP) for N32-f message processing.",
      "chunk_type": "definition",
      "cross_references": [
        "table_6.2.4.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.4.2.1",
      "section_id": "6.2.4.2.1",
      "section_title": "Description",
      "content": "This custom operation is used between the SEPPs to forward the reformatted and JOSE protected HTTP/2 message on N32-f. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32f-forward/<apiVersion>/n32f-process\nThis operation shall support the resource URI variables defined in table 6.1.4.2.1-1.\nTable 6.2.4.2.1-1: Resource URI variables for this Operation\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.2.1.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.2.1",
        "table_6.1.4.2.1-1",
        "table_6.2.4.2.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.4.2.2",
      "section_id": "6.2.4.2.2",
      "section_title": "Operation Definition",
      "content": "This operation shall support the request data structures and response codes specified in tables 6.2.4.2.2-1 and 6.2.4.2.2-2.\nTable 6.2.4.2.2-1: Data structures supported by the POST Request Body on this resource\nData type\nP\nCardinality\nDescription\nN32fReformattedReqMsg\nM\n1\nThis IE shall contain the reformatted HTTP/2 message comprising the plain text part, encrypted information, meta data and modification chain information. See clause 6.2.5.2.2.\nTable 6.2.4.2.2-2: Data structures supported by the POST Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\nN32fReformattedRspMsg\nM\n1\n200 OK\nThis represents the successful processing of the reformatted JOSE protected message at the responding SEPP. The responding SEPP shall provide the reformatted and JOSE protected content of the corresponding HTTP/2 response message received from the NF service producer, or the HTTP/2 notification response message received from the NF service consumer.\nProblemDetailsMsgForwarding\nO\n0..1\n403 Forbidden\nWhen the receiving SEPP fails to process the reconstructed message due to PLMN ID or SNPN ID verification failure, the \"cause\" attribute shall be set to \"PLMNID_MISMATCH\" or \"SNPNID_MISMATCH\".\nWhen the receiving SEPP receives HTTP requests over N32-f with purpose, marked using 3gpp-Sbi-Interplmn-Purpose header as specified in 3GPP TS 29.500 [4], that does not match with any of the purposes exchanged via the Security Capability Negotiation procedure, then the \"cause\" attribute shall be set to \"REQUESTED_PURPOSE_NOT_ALLOWED\".\nWhen the receiving SEPP fails to process the reconstructed message due to the n32fContextId is unknown, the \"cause\" attribute shall be set to \"CONTEXT_NOT_FOUND\".\nWhen the receiving SEPP fails to process the reconstructed message, and the error is reported by N32f error reporting procedure as specified in clause 5.2.5, the \"cause\" attribute shall be set to \"UNSPECIFIED\".\nWhen the RI or receiving SEPP receives HTTP requests over N32-f and detects an encryption policy mismatch, e.g. protected IEs are not ciphered, or unprotected IEs are ciphered, the \"cause\" attribute shall be set to \"POLICY_MISMATCH\". In this case, the ProblemDetails may include the invalidParams attribute indicating which IEs were received ciphered when they were expected to be received in clear, and vice-versa, with the reason attribute for each invalid parameter set to \"Parameter shall be encrypted\" if the IE was sent without confidentiality protection\" or “Parameter shall not be encrypted\" if the IE was sent with confidential protection.\nWhen the RI or receiving SEPP receives HTTP requests, but the N32 connection cannot be setup due to contractual reasons, the \"cause\" attribute shall be set to \"NO_CONNECTION_DUE_TO_CONTRACT\".\nWhen the RI receives HTTP requests but the N32 connection cannot be setup due to a connectivity issue, the \"cause\" attribute shall be set to \"NO_CONNECTION_DUE_TO_CONNECTIVITY\".\nWhen the RI receives HTTP requests over N32-f but the message was not delivered due to contractual reasons, the \"cause\" attribute shall be set to \"MSG_NOT_DELIVERED_DUE_TO_CONTRACT\".\nWhen the receiving SEPP receives a RI generated error reporting request (see clause 5.2.3.3), but the JWS signature of the RI is invalid, the \"cause\" attribute shall be set to \"INVALID_RI_JWS_SIGNATURE\".\nProblemDetailsMsgForwarding\nO\n0..1\n503 Service Unavailable\nWhen the RI receives HTTP requests over N32-f but the message cannot be delivered due to one of the following application errors:\n- SWITCHING_TO_ANOTHER_RI\n- INSUFFICIENT_RESOURCES\n- NETWORK_MAINTENANCE\nNOTE:\tThe mandatory HTTP error status codes for the POST method listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [4] other than those specified in the table above also apply, with a ProblemDetails data type (see clause 5.2.7 of 3GPP TS 29.500 [4]).\nTable 6.2.4.2.2-3: Headers supported by the POST method on this resource\nName\nData type\nP\nCardinality\nDescription\n3gpp-Sbi-Message-Priority\nstring\nO\n0..1\n3gpp-Sbi-Message-Priority header, defined in 3GPP TS 29.500 [4].\nTable 6.2.4.2.2-4: Headers supported by 200 Response Code on this endpoint\nName\nData type\nP\nCardinality\nDescription\n3gpp-Sbi-Message-Priority\nstring\nO\n0..1\n3gpp-Sbi-Message-Priority header, defined in 3GPP TS 29.500 [4].",
      "chunk_type": "definition",
      "cross_references": [
        "clause_6.2.5.2.2",
        "clause_5.2.5",
        "clause_5.2.3.3",
        "ts_29.500_clause_5.2.7",
        "table_6.2.4.2.2-1",
        "table_6.2.4.2.2-2",
        "ts_29.500_table_5.2.7.1-1",
        "ts_29.500_table_6.2.4.2.2-3",
        "ts_29.500_table_6.2.4.2.2-4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.4.3.1",
      "section_id": "6.2.4.3.1",
      "section_title": "Description",
      "content": "This service operation queries the communication options supported by the next hop (RI or SEPP) for N32-f message processing (see clauses 5.3.2.4 and 5.3.4).\nThe HTTP method OPTIONS shall be used on the following URI:\nURI: {apiRoot}/n32f-forward/<apiVersion>/n32f-process\nThis operation shall support the resource URI variables defined in table 6.2.4.3.1-1.\nTable 6.2.4.3.1-1: Resource URI variables for this Operation\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.1.1.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.1.1",
        "table_6.2.4.3.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.4.3.2",
      "section_id": "6.2.4.3.2",
      "section_title": "Operation Definition",
      "content": "6.2.4.3.2.1\tOPTIONS\nThis method shall support the URI query parameters specified in table 6.2.4.3.2.1-1.\nTable 6.2.4.3.2.1-1: URI query parameters supported by the OPTIONS method\nName\nData type\nP\nCardinality\nDescription\nn/a\nThis method shall support the request data structures specified in table 6.2.4.3.2.1-2 and the response data structures and response codes specified in table 6.2.4.3.2.1-3.\nTable 6.2.4.3.2.1-2: Data structures supported by the OPTIONS Request Body on this resource\nData type\nP\nCardinality\nDescription\nn/a\nTable 6.2.4.3.2.1-3: Data structures supported by the OPTIONS Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\nn/a\n204 No Content\nProblemDetails\nO\n0..1\n405 Method Not Allowed\nProblemDetails\nO\n0..1\n501 Not Implemented\nNOTE:\tThe mandatory HTTP error status codes for the OPTIONS method listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [4] other than those specified in the table above also apply, with a ProblemDetails data type (see clause 5.2.7 of 3GPP TS 29.500 [4]).\nTable 6.2.4.3.2.1-4: Headers supported by the 204 Response Code on this resource\nName\nData type\nP\nCardinality\nDescription\nAccept-Encoding\nstring\nO\n0..1\nAccept-Encoding, described in IETF RFC 9110 [9]",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.7",
        "table_6.2.4.3.2.1-1",
        "table_6.2.4.3.2.1-2",
        "table_6.2.4.3.2.1-3",
        "ts_29.500_table_5.2.7.1-1",
        "ts_29.500_table_6.2.4.3.2.1-4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.1",
      "section_id": "6.2.5.1",
      "section_title": "General",
      "content": "This clause specifies the application data model supported by the API.\nTable 6.2.5.1-1 specifies the data types defined for the N32 interface.\nTable 6.2.5.1-1: N32 specific Data Types\nData type\nClause defined\nDescription\nN32fReformattedReqMsg\n6.2.5.2.2\nContains the reformatted HTTP/2 request message\nN32fReformattedRspMsg\n6.2.5.2.3\nContains the reformatted HTTP/2 response message\nDataToIntegrityProtectAndCipherBlock\n6.2.5.2.4\nHTTP header to be encrypted or the value of a JSON attribute to be encrypted\nDataToIntegrityProtectBlock\n6.2.5.2.5\nData to be integrity protected\nRequestLine\n6.2.5.2.6\nContains the request line of the HTTP API request being reformatted and forwarded over N32-f\nHttpHeader\n6.2.5.2.7\nContains the encoding of HTTP headers in the API request / response\nHttpPayload\n6.2.5.2.8\nContains the encoding of JSON content in the API request / response\nMetaData\n6.2.5.2.9\nContains the meta data information needed for replay protection\nModifications\n6.2.5.2.10\nInformation on inserting of the modifications entry\nFlatJweJson\n6.2.5.2.11\nContains the integrity protected reformatted block\nFlatJwsJson\n6.2.5.2.12\nContains the modification from IPXes on path\nIndexToEncryptedValue\n6.2.5.2.13\nIndex to the encrypted value\nEncodedHttpHeaderValue\n6.2.5.2.14\nHTTP header value or index to the HTTP header value\nProblemDetailsMsgForwarding\n6.2.5.2.15\nN32-f message forwarding Error Detail\nAdditionInfoMsgForwarding\n6.2.5.2.16\nProblem Details extensions for N32-f message forwarding\nTable 6.2.5.1-2 specifies data types re-used by the N32 interface protocol from other specifications, including a reference to their respective specifications and when needed, a short description of their use within the JOSE Protected Message Forwarding API on N32 service based interface.\nTable 6.2.5.1-2: N32 re-used Data Types\nData type\nReference\nComments\nHttpMethod\n6.1.5.3.5\nIeLocation\n6.1.5.3.6\nRiErrorInformation\n6.1.5.2.17\nRI error information\nPatchItem\n3GPP TS 29.571 [12]\nUriScheme\n3GPP TS 29.571 [12]\nFqdn\n3GPP TS 29.571 [12]",
      "chunk_type": "definition",
      "cross_references": [
        "table_6.2.5.1-1",
        "table_6.2.5.1-2",
        "ts_29.571"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.1",
      "section_id": "6.2.5.2.1",
      "section_title": "Introduction",
      "content": "This clause defines the structures to be used in the JOSE Protected Message Forwarding API on N32.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.2",
      "section_id": "6.2.5.2.2",
      "section_title": "Type: N32fReformattedReqMsg",
      "content": "Table 6.2.5.2.2-1: Definition of type N32fReformattedReqMsg\nAttribute name\nData type\nP\nCardinality\nDescription\nreformattedData\nFlatJweJson\nM\n1\nThis IE shall contain the integrity protected reformatted block as well as the ciphered part of the reformatted block of the HTTP/2 request message sent between NF service producer and consumer.\nThe SEPP shall reformat the HTTP/2 request message as:\n- The part of original HTTP/2 request message headers and the content that needs to be only integrity protected is first reformatted into \"DataToIntegrityProtectBlock\" and then fed as input for the \"aad\" parameter of the FlatJweJson after subjecting to BASE64URL encoding.\nThe part of the original HTTP/2 request message headers and content that require integrity protection and ciphering is first reformatted into \"DataToIntegrityProtectAndCipherBlock\" and then fed as input for JWE ciphering and the JWE ciphered block is then BASE64URL encoded and set into the \"ciphertext\" parameter of the FlatJweJson.\nmodificationsBlock\narray(FlatJwsJson)\nC\n1..N\nThis IE shall be included if the RIs on path are allowed to apply modification policies and if they have any specific modification to be applied on the message contained in the DataToIntegrityProtectBlock.\nThis IE shall also be included if a RI on the path originates a N32-f Request (see clause 5.5.3).",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.5.3",
        "table_6.2.5.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.3",
      "section_id": "6.2.5.2.3",
      "section_title": "Type: N32fReformattedRspMsg",
      "content": "Table 6.2.5.2.3-1: Definition of type N32fReformattedRspMsg\nAttribute name\nData type\nP\nCardinality\nDescription\nreformattedData\nFlatJweJson\nM\n1\nThis IE shall contain the integrity protected reformatted block as well as the ciphered part of the reformatted block of the HTTP/2 response message sent between NF service producer and consumer.\nThe SEPP shall reformat the HTTP/2 response message as:\n- The part of original HTTP/2 response message headers and the content that needs to be only integrity protected is first reformatted into \"DataToIntegrityProtectBlock\" and then fed as input for the \"aad\" parameter of the FlatJweJson after subjecting to BASE64URL encoding.\n- The part of the original HTTP/2 response message headers and content that require integrity protection and ciphering is first reformatted into \"DataToIntegrityProtectAndCipherBlock\" and then fed as input for JWE ciphering and the JWE ciphered block is then BASE64URL encoded and set into the \"ciphertext\" parameter of the FlatJweJson.\nmodificationsBlock\narray(FlatJwsJson)\nC\n1..N\nThis IE shall be included if the RIs on path are allowed to apply modification policies and if they have any specific modification to be applied on the message contained in the DataToIntegrityProtectBlock.\nThis IE shall also be included if a RI on the path originates an N32-f Response (see clause 5.5.3).",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.5.3",
        "table_6.2.5.2.3-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.4",
      "section_id": "6.2.5.2.4",
      "section_title": "Type: DataToIntegrityProtectAndCipherBlock",
      "content": "Table 6.2.5.2.4-1: Definition of type DataToIntegrityProtectAndCipherBlock\nAttribute name\nData type\nP\nCardinality\nDescription\ndataToEncrypt\narray(Any Type)\nM\n1..N\nThis IE shall contain the input for ciphering as a JSON object block containing an array of values with arbitrary types. Each entry of the array shall contain the value of a HTTP header to be encrypted or the value of a JSON attribute to be encrypted.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.2.5.2.4-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.5",
      "section_id": "6.2.5.2.5",
      "section_title": "Type: DataToIntegrityProtectBlock",
      "content": "Table 6.2.5.2.5-1: Definition of type DataToIntegrityProtectBlock\nAttribute name\nData type\nP\nCardinality\nDescription\nmetaData\nMetaData\nC\n0..1\nThis IE shall be included if the SEPP encodes additional information for replay protection. When present this IE shall contain the meta data information needed for replay protection.\nThis IE shall also be included if the RI originates a N32-f Request or an N32-f Response (see clause 5.5.3)\nrequestLine\nRequestLine\nC\n1\nThis IE shall be included when a JOSE protected API \"request\" is forwarded over N32-f. When present, this IE shall contain the request line of the HTTP API request being reformatted and forwarded over N32-f.\nstatusLine\nstring\nC\n0..1\nThis IE shall be included when a JOSE protected API \"response\" is forwarded over N32-f. When present, this IE shall contain the status line of the HTTP API response being reformatted and forwarded over N32-f.\nheaders\narray(HttpHeader)\nC\n1..N\nThis IE shall be included when a JOSE protected API request / response contains HTTP headers. When present this IE shall contain the encoding of HTTP headers in the API request / response.\npayload\narray(HttpPayload)\nC\n1..N\nThis IE shall be included when a JOSE protected API request / response contains JSON content that needs to be sent in clear text. When present this IE shall contain the encoding of JSON content in the API request / response.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.5.3",
        "table_6.2.5.2.5-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.6",
      "section_id": "6.2.5.2.6",
      "section_title": "Type: RequestLine",
      "content": "Table 6.2.5.2.6-1: Definition of type RequestLine\nAttribute name\nData type\nP\nCardinality\nDescription\nmethod\nHttpMethod\nM\n1\nThis IE shall contain the HTTP method of the HTTP request encapsulated in the N32-f Request.\nscheme\nUriScheme\nM\n1\nThis IE shall contain the HTTP scheme of the API.\nauthority\nstring\nM\n1\nThis IE shall contain the authority part of the URI of the API being invoked.\npath\nstring\nM\n1\nThis IE shall contain the path part of the URI of the API being invoked, excluding the query and fragment components.\nThe string value of this IE may contain one or more IndexToEncryptedValue structures (encoded with JSON format) specified in clause 6.2.5.2.13 if there are Variables in URI path to be encrypted.\nprotocolVersion\nstring\nM\n1\nThis IE shall contain the HTTP protocol version. The version shall be 2 in this release of this specification.\nqueryFragment\nstring\nC\n0..1\nThis IE shall contain the query component of the URI of the API if available.\nThe string value of this IE may contain one or more IndexToEncryptedValue structures (encoded with JSON format) specified in clause 6.2.5.2.13 if the values of certain URI query parameters are to be encrypted.\npathQueryProtectInd\narray(IeLocation)\nC\n1..2\nThis IE shall be present when IE(s) with sensitive information in the URI path and/or query parameters were protected with encryption.\nWhen present, this IE shall indicate the location(s) of the protected IE(s), i.e. \"URI_PATH\" and/or \"URI_PARAM\".",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.2.5.2.13",
        "table_6.2.5.2.6-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.7",
      "section_id": "6.2.5.2.7",
      "section_title": "Type: HttpHeader",
      "content": "Table 6.2.5.2.7-1: Definition of type HttpHeader\nAttribute name\nData type\nP\nCardinality\nDescription\nheader\nstring\nM\n1\nThis IE shall contain the name of the HTTP header to encoded.\nvalue\nEncodedHttpHeaderValue\nM\n1\nThis IE shall contain the value of the HTTP header. The value of the HTTP header shall be encoded as:\n- value field of the EncodedHttpHeaderValue structure specified in clause 6.2.5.2.14 if the HTTP header is not to be encrypted.\n- IndexToEncryptedValue structure specified in clause 6.2.5.2.13 if the value of the HTTP header is to be encrypted.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.2.5.2.14",
        "clause_6.2.5.2.13",
        "table_6.2.5.2.7-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.8",
      "section_id": "6.2.5.2.8",
      "section_title": "Type: HttpPayload",
      "content": "Table 6.2.5.2.8-1: Definition of type HttpPayload\nAttribute name\nData type\nP\nCardinality\nDescription\niePath\nstring\nM\n1\nThis IE identifies the JSON pointer representation (see IETF RFC 6901 [17]) of full JSON path of the IE to be encoded. IEs that are of type object shall be flattened into each individual attribute's full JSON path and the HttpPayload IE shall only contain the final leaf attribute IE path and its corresponding value.\nieValueLocation\nIeLocation\nM\n1\nThis IE shall identify where the IE value is located - i,e in the JSON body or in the multipart message part.\nvalue\nobject\nM\n1\nThis IE shall contain the value of the IE corresponding to \"iePath\", encoded as a free form object.\nIf the value of this IE is encrypted, then the value part shall be encoded as\n{\n\"encBlockIndex\": <array index in DataToIntegrityProtectAndCipherBlock>\n}\n(see clause 6.2.5.2.4).\nIf the value of this IE is a RefToBinary data type (see 3GPP TS 29.571 [12], then value shall contain the value of the Content-ID header field of the referenced binary body part.\nThe referenced binary body part of the multipart/related message shall be either encrypted or not encrypted depending on the protection policy exchanged between the SEPPs.\nIf the referenced binary body part is required to be encrypted, then the binary part is first base64 encoded into a byte array and then inserted into the \"DataToIntegrityProtectAndCipherBlock\". Then two HttpPayload instances with the following values shall be added immediately after this HttpPayload instance in the \"DataToIntegrityProtectBlock\"\n{\n\"iePath\": <JSON Pointer of the attribute defined with theRefToBinaryData type >/contenttype\n\"ieValueLocation\": \"MULTIPART_BINARY\"\n\"value\": <value of the content type of multipart binary>\n},\n{\n\"iePath\": <JSON Pointer of the attribute defined with the RefToBinaryData type>/data,\n\"ieValueLocation\": \"MULTIPART_BINARY\"\n\"value\": {\"encBlockIndex\": <array index in DataToIntegrityProtectAndCipherBlock that contains the byte array>}\n}\nIf the referenced binary body part is not required to be encrypted, then the binary part is first base64 encoded into a byte array and then inserted as new instance of HttpPayload IE in \" DataToIntegrityProtectBlock\" as\n{\n\"iePath\": <JSON Pointer of the attribute defined with the RefToBinaryData type>/contenttype\n\"ieValueLocation\": \"MULTIPART_BINARY\"\n\"value\": <value of the content type of multipart binary>\n},\n{\n\"iePath\": <JSON path of the attribute defined with the RefToBinaryData type>/data,\n\"ieValueLocation\": \"MULTIPART_BINARY\"\n\"value\": <base64 encoded byte array>\n}\nSee NOTE 1.\nNOTE 1:\tIn this release of this specification only N16 interface has binary content and there is no sensitive information carried over N16 interface. Consequently ciphering of binary part is not required in this release of this specification. The encoding specified here is to provide a N32-f framework in a future proof manner so that if a binary part need to be encrypted in future this structure can be used.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.2.5.2.4",
        "table_6.2.5.2.8-1",
        "ts_29.571"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.9",
      "section_id": "6.2.5.2.9",
      "section_title": "Type: MetaData",
      "content": "Table 6.2.5.2.9-1: Definition of type MetaData\nAttribute name\nData type\nP\nCardinality\nDescription\nn32fContextId\nstring\nM\n1\nThis IE shall contain the n32fContextId of the SEPP receiving the message, which is exchanged between the SEPPs during the parameter exchange procedure (see clause 5.2.3).\nThe n32fContextId shall encode a 64-bit integer in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the N32-f context Id shall appear first in the string, and the character representing the 4 least significant bit of the N32-f context Id shall appear last in the string.\nPattern: '^[A-Fa-f0-9]{16}$'\nExample: \"0600AD1855BD6007\".\nmessageId\nstring\nM\n1\nThis IE identifies a particular request that is transformed by the SEPP. The value of this IE shall be encoded in hexadecimal representation of a 64 bit integer. This identifier is used in the N32-f error reporting procedure as specified in clause 6.1.4.5.\nPattern: ^[a-fA-F0-9]{1, 16}$\nauthorizedIpxId\nstring\nM\n1\nThis IE identifies the first hop RI that is authorized to insert modifications block. The identifier of the RI shall be an FQDN. When there is no RI that's authorized to update, the value of this IE is set to the string \"NULL\".\nThis IE shall be set to the empty string \"\", if the RI originates a message as defined in clause 5.5.3.\nriFqdn\nFqdn\nC\n0..1\nThis IE shall be present, If the originator of the N32-f request message is the Roaming Intermediary.\nWhen present, the IE shall contain the FQDN of the Roaming Intermediary originating the N32-f request.\nWhen present, the riFqdn together with the messageId shall uniquely identify a N32-f message received over the N32-f connection.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.2.3",
        "clause_6.1.4.5",
        "clause_5.5.3",
        "table_6.2.5.2.9-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.10",
      "section_id": "6.2.5.2.10",
      "section_title": "Type: Modifications",
      "content": "Table 6.2.5.2.10-1: Definition of type Modifications\nAttribute name\nData type\nP\nCardinality\nDescription\noperations\narray(PatchItem)\nC\n1..N\nThis IE shall be included if an RI inserts modification instructions on the JSON data carried in the \"DataToIntegrityProtectBlock\" part of the N32-f forwarded message. For the first modifications entry, this IE shall not be included, since the first entry is inserted by the SEPP.\nThis IE shall also be included if a RI originates a message as defined in clause 5.5.3.\nidentity\nFqdn\nM\n1\nThis IE shall contain the identity of the entity inserting the modifications entry. The identity shall be encoded in the form of an URI.\ntag\nstring\nC\n0..1\nThis IE shall be present when the JWE Authentication Tag value is non-empty as specified in IETF RFC 7515 [16]. When present, this IE shall contain the BASE64URL(JWE Authentication Tag).",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_5.5.3",
        "table_6.2.5.2.10-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.11",
      "section_id": "6.2.5.2.11",
      "section_title": "Type: FlatJweJson",
      "content": "Table 6.2.5.2.11-1: Definition of type FlatJweJson\nAttribute name\nData type\nP\nCardinality\nDescription\nprotected\nstring\nC\n0..1\nThis IE shall be present if there is a JWE Protected Header part of the JOSE header to encode as specified in IETF RFC 7516 [14]. When present, this IE shall contain the BASE64URL(UTF8(JWE Protected Header)) encoding of the JWE protected header.\nunprotected\nobject\nC\n0..1\nThis IE shall be present if there is a JWE unprotected header part of the JOSE header that is shared across recipients, to encode as specified in IETF RFC 7515 [16]. This value is represented as\nan unencoded free form JSON object, rather than as a string. These Header Parameter values are not integrity protected.\nheader\nobject\nC\n0..1\nThis IE shall be present if there is a JWE unprotected header part of the JOSE header that is specific for the recipient, to encode as specified in IETF RFC 7515 [16]. This value is represented as\nan unencoded free form JSON object, rather than as a string. These Header Parameter values are not integrity protected.\nencrypted_key\nstring\nC\n0..1\nThis IE shall be present when the JWE Encrypted Key for the recipient is non empty. When present this IE shall contain BASE64URL(JWE Encrypted Key).\n(NOTE)\naad\nstring\nC\n0..1\nThis IE shall be present when the JWE AAD value is non-empty as specified in IETF RFC 7515 [16]. When present, this IE shall contain BASE64URL encoding of the DataToIntegrityProtectBlock JSON object (see clause 6.2.5.2.5).\niv\nstring\nC\n0..1\nThis IE shall be present when the JWE Initialization Vector is non-empty as specified in IETF RFC 7515 [16]. When present, this IE shall contain the BASE64URL(JWE Initialization Vector).\nciphertext\nstring\nM\n1\nThis IE shall contain BASE64URL(JWE Ciphertext). The input for JWE ciphering is the DataToIntegrityProtecAndCiphertBlock (see clause 6.2.5.2.5).\ntag\nstring\nC\n0..1\nThis IE shall be present when the JWE Authentication Tag value is non-empty as specified in IETF RFC 7515 [16]. When present, this IE shall contain the BASE64URL(JWE Authentication Tag).\nNOTE:\tThe attribute name does not follow the naming conventions specified in 3GPP TS 29.501 [5]. The attribute name is kept though as defined in the current specification for backward compatibility reason.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.2.5.2.5",
        "table_6.2.5.2.11-1",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.12",
      "section_id": "6.2.5.2.12",
      "section_title": "Type: FlatJwsJson",
      "content": "Table 6.2.5.2.12-1: Definition of type FlatJwsJson\nAttribute name\nData type\nP\nCardinality\nDescription\npayload\nstring\nM\n1\nThis IE shall contain the BASE64URL encoding of the Modifications JSON object (see clause 6.2.5.2.10).\nprotected\nstring\nC\n0..1\nThis IE shall be present if there is a JWS Protected Header part of the JOSE header to encode as specified in IETF RFC 7515 [16]. When present, this IE shall contain the BASE64URL(UTF8(JWS Protected Header)) encoding of the JWS protected header.\nheader\nobject\nC\n0..1\nThis IE shall be present if there is a JWS unprotected header part of the JOSE header to encode as specified in IETF RFC 7515 [16]. This value is represented as\nan unencoded free form JSON object, rather than as a string. These Header Parameter values are not integrity protected.\nsignature\nstring\nM\n1\nThis IE shall contain the BASE64URL encoded value of the calculated JWS signature.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.2.5.2.10",
        "table_6.2.5.2.12-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.13",
      "section_id": "6.2.5.2.13",
      "section_title": "Type: IndexToEncryptedValue",
      "content": "Table 6.2.5.2.13-1: Definition of type IndexToEncryptedValue\nAttribute name\nData type\nP\nCardinality\nDescription\nencBlockIndex\nUinteger\nM\n1\nIndex to the value in DataToIntegrityProtectAndCipherBlock",
      "chunk_type": "general",
      "cross_references": [
        "table_6.2.5.2.13-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.14",
      "section_id": "6.2.5.2.14",
      "section_title": "Type: EncodedHttpHeaderValue",
      "content": "Table 6.2.5.2.14-1: Definition of type EncodedHttpHeaderValue as a list of \"mutually exclusive alternatives\"\nData type\nCardinality\nDescription\nApplicability\nstring\n1\nHTTP header value.\nIndexToEncryptedValue\n1\nIndex to encrypted HTTP header in the DataToIntegrityProtectAndCipherBlock",
      "chunk_type": "general",
      "cross_references": [
        "table_6.2.5.2.14-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.15",
      "section_id": "6.2.5.2.15",
      "section_title": "Type: ProblemDetailsMsgForwarding",
      "content": "Table 6.2.5.2.15-1: Definition of type ProblemDetailsMsgForwarding as a list of to be combined data types\nData type\nCardinality\nDescription\nApplicability\nProblemDetails\n1\nAdditionInfoMsgForwarding\n1",
      "chunk_type": "general",
      "cross_references": [
        "table_6.2.5.2.15-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.2.16",
      "section_id": "6.2.5.2.16",
      "section_title": "Type: AdditionInfoMsgForwarding",
      "content": "Table 6.2.5.2.16-1: Definition of type AdditionInfoMsgForwarding\nAttribute name\nData type\nP\nCardinality\nDescription\nsuggestedStatusCode\ninteger\nO\n0..1\nWhen present, this IE shall indicate a status code that is suggested to be sent to cNF if the cSEPP cannot or does not resend the N32-f request taking into account the N32-f error information.\nsuggestedProblemDetails\nProblemDetails\nO\n0..1\nWhen present, this IE shall indicate suggested ProblemDetails to be sent to cNF if the cSEPP cannot or does not resend the N32-f request taking into account the N32-f error information.\nriErrorInformation\nRiErrorInformation\nO\n0..1\nThis IE may be included by a RI.\nWhen present, this IE shall provide instructions to the SEPP to terminate or re-establish the N32-f connection and/or the N32-f context.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.2.5.2.16-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.5.3.1",
      "section_id": "6.2.5.3.1",
      "section_title": "Introduction",
      "content": "This clause defines simple data types and enumerations that can be referenced from data structures defined in the previous clauses.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.2.5.3.2",
      "section_id": "6.2.5.3.2",
      "section_title": "Simple data types",
      "content": "The simple data types defined in table 6.1.5.3.2-1 shall be supported.\nTable 6.2.5.3.2-1: Simple data types\nType Name\nType Definition\nDescription",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.1.5.3.2-1",
        "table_6.2.5.3.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.6.1",
      "section_id": "6.2.6.1",
      "section_title": "General",
      "content": "HTTP error handling shall be supported as specified in clause 5.2.4 of 3GPP TS 29.500 [4].",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.6.2",
      "section_id": "6.2.6.2",
      "section_title": "Protocol Errors",
      "content": "Protocol Error Handling shall be supported as specified in clause 5.2.7.2 of 3GPP TS 29.500 [4].",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_5.2.7.2",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.2.6.3",
      "section_id": "6.2.6.3",
      "section_title": "Application Errors",
      "content": "The application errors defined for the JOSE protected message forwarding API on N32-f are listed in Table 6.2.6.3-1.\nTable 6.2.6.3-1: Application errors\nApplication Error\nHTTP status code\nDescription\nPLMNID_MISMATCH\n403 Forbidden\nThe PLMN ID in the Bearer token carried in the \"Authorization\" header of the reconstructed message does not match the PLMN ID of the N32-f context.\nSNPNID_MISMATCH\n403 Forbidden\nThe SNPN ID in the Bearer token carried in the \"Authorization\" header of the reconstructed message does not match the SNPN ID of the N32-f context.\nREQUESTED_PURPOSE_NOT_ALLOWED\n403 Forbidden\nThe purpose indicated in 3gpp-Sbi-Interplmn-Purpose header as specified in 3GPP TS 29.500 [4] of the reconstructed message does not match with any of the purposes exchanged via the Security Capability Negotiation procedure.\nCONTEXT_NOT_FOUND\n403 Forbidden\nThe n32fContextId is unknown in the receiving SEPP.\nUNSPECIFIED\n403 Forbidden\nThe receiving SEPP fails to process the reconstructed message, and the error is reported by N32f error reporting procedure as specified in clause 5.2.5.\nPOLICY_MISMATCH\n403 Forbidden\nThe encryption policy verification on the received N32-f message has failed, e.g. protected IEs are not ciphered, or unprotected IEs are ciphered.\nNO_CONNECTION_DUE_TO_CONTRACT\n403 Forbidden\nThe message failed to be delivered as N32 connection cannot be setup due to contractual reasons.\nNO_CONNECTION_DUE_TO_CONNECTIVITY\n403 Forbidden\nThe message failed to be delivered as N32 connection cannot be setup due to a connectivity issue.\nMSG_NOT_DELIVERED_DUE_TO_CONTRACT\n403 Forbidden\nThe message was not delivered due to contractual reasons.\nINVALID_RI_JWS_SIGNATURE\n403 Forbidden\nThe error reporting request generated by the RI was not delivered because the JWS signature of the RI is invalid.\nSWITCHING_TO_ANOTHER_RI\n503 Service Unavailable\nThe message was not delivered due to the service being taken over by another RI, e.g. when the RI is shutting down.\nINSUFFICIENT_RESOURCES\n503 Service Unavailable\nThe message was not delivered due to resource exhaustion at the RI (e.g., memory, CPU, or network bandwidth).\nNETWORK_MAINTENANCE\n503 Service Unavailable\nThe message was not delivered due to network maintenance at the RI.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2.5",
        "table_6.2.6.3-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.1",
      "section_id": "6.3.1",
      "section_title": "API URI",
      "content": "The Nsepp_Telescopic_FQDN_Mapping Service shall use the SEPP Telescopic FQDN Mapping API.\nThe API URI of the SEPP Telescopic FQDN Mapping API shall be:\n{apiRoot}/<apiName>/<apiVersion>\nThe request URIs used in HTTP requests from the NF service consumer towards the SEPP shall have the Resource URI structure defined in clause 4.4.1 of 3GPP TS 29.501 [5], i.e.:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\nwith the following components:\n-\tThe {apiRoot} shall be set as described in 3GPP TS 29.501 [5].\n-\tThe <apiName> shall be \"nsepp-telescopic\".\n-\tThe <apiVersion> shall be \"v1\".\n-\tThe <apiSpecificResourceUriPart> shall be set as described in clause 6.3.3.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.501_clause_4.4.1",
        "clause_6.3.3",
        "ts_29.501"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.2.1",
      "section_id": "6.3.2.1",
      "section_title": "General",
      "content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used as specified in clause 5 of 3GPP TS 29.500 [4].\nHTTP/2 shall be transported as specified in clause 5.3 of 3GPP TS 29.500 [4].\nHTTP messages and bodies for the Nsepp_Telescopic_FQDN_Mapping service shall comply with the OpenAPI [27] specification contained in Annex A.",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5",
        "ts_29.500_clause_5.3",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.2.2.1",
      "section_id": "6.3.2.2.1",
      "section_title": "General",
      "content": "The HTTP standard headers as specified in clause 4.3.2.2 shall be supported for this API.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_4.3.2.2"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.2.2.2",
      "section_id": "6.3.2.2.2",
      "section_title": "Content type",
      "content": "The following content types shall be supported:\n-\tJSON, as defined in IETF RFC 8259 [9]. The use of the JSON format shall be signalled by the content type \"application/json\". See also clause 5.4 of 3GPP TS 29.500 [4].\n-\tThe Problem Details JSON Object (IETF RFC 9457 [22]. The use of the Problem Details JSON object in a HTTP response body shall be signalled by the content type \"application/problem+json\".",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_5.4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.2.3.1",
      "section_id": "6.3.2.3.1",
      "section_title": "General",
      "content": "In this release of this specification, no custom headers specific to the Nsepp_Telescopic_FQDN_Mapping service are defined. For 3GPP specific HTTP custom headers used across all service-based interfaces, see clause 5.2.3 of 3GPP TS 29.500 [4].",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.3",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.3.1",
      "section_id": "6.3.3.1",
      "section_title": "Overview",
      "content": "Figure 6.3.3.1-1: Resource URI structure of the nsepp-telescopic API\nTable 6.3.3.1-1 provides an overview of the resources and applicable HTTP methods.\nTable 6.3.3.1-1: Resources and methods overview\nResource name\nResource URI\nHTTP method or custom operation\nDescription\nMapping\n/mapping\nGET\nRetrieve the mapping between the FQDN in a foreign PLMN and a telescopic FQDN, or viceversa.",
      "chunk_type": "definition",
      "cross_references": [
        "table_6.3.3.1-1",
        "figure_6.3.3.1-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.3.2.1",
      "section_id": "6.3.3.2.1",
      "section_title": "Description",
      "content": "This resource represents the mapping between the FQDN of an NF in a foreign PLMN and a telescopic FQDN.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.3.3.2.2",
      "section_id": "6.3.3.2.2",
      "section_title": "Resource Definition",
      "content": "Resource URI: {apiRoot}/nsepp-telescopic/<apiVersion>/mapping\nThis resource shall support the resource URI variables defined in table 6.3.3.2.2-1.\nTable 6.3.3.2.2-1: Resource URI variables for this resource\nName\nData type\nDefinition\napiRoot\nstring\nSee clause 6.3.1",
      "chunk_type": "definition",
      "cross_references": [
        "clause_6.3.1",
        "table_6.3.3.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.3.2.3",
      "section_id": "6.3.3.2.3",
      "section_title": "Resource Standard Methods",
      "content": "6.3.3.2.3.1\tGET\nThis method shall support the URI query parameters specified in table 6.3.3.2.3.1-1.\nTable 6.3.3.2.3.1-1: URI query parameters supported by the GET method on this resource\nName\nData type\nP\nCardinality\nDescription\nforeign-fqdn\nFqdn\nO\n0..1\nThis parameter shall contain the FQDN of the NF in the foreign network, that needs to be flattened to a telescopic FQDN in the local network (i.e. an FQDN that points to the local SEPP).\ntelescopic-label\nstring\nO\n0..1\nThis parameter shall contain the first label used in a telescopic FQDN (i.e. an FQDN that points to the local SEPP) that needs to be mapped to an NF in the foreign network.\nNOTE:\tThe parameters \"foreign-fqdn\" and \"telescopic-label\" shall not be present simultaneously.\nThis method shall support the request data structures specified in table 6.3.3.2.3.1-2 and the response data structures and response codes specified in table 6.3.3.2.3.1-3.\nTable 6.3.3.2.3.1-2: Data structures supported by the GET Request Body on this resource\nData type\nP\nCardinality\nDescription\nn/a\nTable 6.3.3.2.3.1-3: Data structures supported by the GET Response Body on this resource\nData type\nP\nCardinality\nResponse\ncodes\nDescription\nTelescopicMapping\nM\n1\n200 OK\nUpon success, a response body containing a TelescopicMapping object shall be returned\nProblemDetails\nO\n0..1\n404 Not Found\nThe mapping between a foreign FQDN and a telescopic FQDN could not be found.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.3.3.2.3.1-1",
        "table_6.3.3.2.3.1-2",
        "table_6.3.3.2.3.1-3"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.4.1",
      "section_id": "6.3.4.1",
      "section_title": "General",
      "content": "This clause specifies the application data model supported by the API.\nTable 6.3.4.1-1 specifies the data types defined for the Nsepp_Telescopic_FQDN_Mapping service-based interface protocol.\nTable 6.3.4.1-1: Nsepp_Telescopic_FQDN_Mapping specific Data Types\nData type\nClause defined\nDescription\nTelescopicMapping\n6.3.4.2.2\nContains the Telescopic mapping data\nTable 6.3.4.1-2 specifies data types re-used by the Nsepp_Telescopic_Mapping service-based interface protocol from other specifications.\nTable 6.3.4.1-2: Nsepp_Telescopic_FQDN_Mapping re-used Data Types\nData type\nReference\nComments\nFqdn\n3GPP TS 29.571 [12]\nProblemDetails\n3GPP TS 29.571 [12]\nCommon data type for error responses",
      "chunk_type": "definition",
      "cross_references": [
        "table_6.3.4.1-1",
        "table_6.3.4.1-2",
        "ts_29.571"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.4.2.1",
      "section_id": "6.3.4.2.1",
      "section_title": "Introduction",
      "content": "This clause defines the structures to be used in resource representations.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.3.4.2.2",
      "section_id": "6.3.4.2.2",
      "section_title": "Type: TelescopicMapping",
      "content": "Table 6.3.4.2.2-1: Definition of type TelescopicMapping\nAttribute name\nData type\nP\nCardinality\nDescription\ntelescopicLabel\nstring\nC\n0..1\nThis parameter shall contain the first label to be used in a telescopic FQDN (i.e. an FQDN that points to the local SEPP) that corresponds to a given NF in the foreign network.\nIn a successful response, this parameter shall be included when the query parameter \"foreign-fqdn\" is present in the request.\nseppDomain\nFqdn\nC\n0..1\nThis parameter shall contain the FQDN of the domain of the local SEPP that needs to be appended after the \"telescopicLabel\" to compose the complete flattened telescopic FQDN.\nIn a successful response, this parameter shall be included when the query parameter \"foreign-fqdn\" is present in the request.\nforeignFqdn\nFqdn\nC\n0..1\nThis parameter shall contain the FQDN of the NF in the foreign network.\nIn a successful response, this parameter shall be included when the query parameter \"telescopic-label\" is present in the request.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.3.4.2.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.4.3.1",
      "section_id": "6.3.4.3.1",
      "section_title": "Introduction",
      "content": "This clause defines simple data types and enumerations that can be referenced from data structures defined in the previous clauses.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.3.4.3.2",
      "section_id": "6.3.4.3.2",
      "section_title": "Simple data types",
      "content": "The simple data types defined in table 6.3.4.3.2-1 shall be supported.\nTable 6.3.4.3.2-1: Simple data types\nType Name\nType Definition\nDescription",
      "chunk_type": "requirement",
      "cross_references": [
        "table_6.3.4.3.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.5.1",
      "section_id": "6.3.5.1",
      "section_title": "General",
      "content": "HTTP error handling shall be supported as specified in clause 5.2.4 of 3GPP TS 29.500 [4].",
      "chunk_type": "definition",
      "cross_references": [
        "ts_29.500_clause_5.2.4",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.5.2",
      "section_id": "6.3.5.2",
      "section_title": "Protocol Errors",
      "content": "Protocol Error Handling shall be supported as specified in clause 5.2.7 of 3GPP TS 29.500 [4].",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_5.2.7",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.5.3",
      "section_id": "6.3.5.3",
      "section_title": "Application Errors",
      "content": "The common application errors defined in the Table 5.2.7.2-1 in 3GPP TS 29.500 [4] may also be used for the Nsepp_Telescopic_Mapping service, and the following application errors listed in Table 6.3.5.3-1 are specific for the Nsepp_Telescopic_Mapping service.\nTable 6.3.5.3-1: Application errors\nApplication Error\nHTTP status code\nDescription",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.500_table_5.2.7.2-1",
        "table_6.3.5.3-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_6.3.6",
      "section_id": "6.3.6",
      "section_title": "Feature Negotiation",
      "content": "This API does not currently specify any features.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_6.3.7.1",
      "section_id": "6.3.7.1",
      "section_title": "General",
      "content": "This API shall be accessed only from NFs in the same PLMN as the SEPP; it shall not be exposed externally to NFs from another PLMN.",
      "chunk_type": "definition",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_7.1",
      "section_id": "7.1",
      "section_title": "General",
      "content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used.\nThe Transmission Control Protocol as described in IETF RFC 793 [11] shall be used as transport protocol as required by HTTP/2 (see IETF RFC 9113 [7]).\nThe HTTP CONNECT method shall be used as defined in clause 9.3.6 of IETF RFC 9110 [9] and clause 8.5 of IETF RFC 9113 [7].\nThe \":authority\" pseudo-header field in the HTTP/2 CONNECT request message shall be set to:\n\":authority\" = uri-host [\":\" port] as specified in clause 8.3.1 of IETF RFC 9113 [7].\nThe Uri-host shall indicate the FQDN of the p-SEPP.\nThe HTTP CONNECT request and the 200 OK status response shall not contain any content.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_9.3.6",
        "clause_8.5",
        "clause_8.3.1"
      ]
    },
    {
      "chunk_id": "ts_29.573_7.2",
      "section_id": "7.2",
      "section_title": "HTTP standards headers",
      "content": "The HTTP standard headers defined in Table 7.2-1 shall be supported on the interface between the SEPP and RI.\nMandatory to support HTTP standard headers does not mean that all the HTTP requests and responses carry the identified request and response headers respectively. It only means it is mandatory to support the processing of the identified headers in request and response message.\nTable 7.2-1: Mandatory to support HTTP response standard headers\nName\nReference\nDescription\nVia\nIETF RFC 9110 [9]\nThis header should be inserted by a RI when relaying an HTTP error response (see clause 6.10.8 of 3GPP TS 29.500 [4]). It may be inserted when relaying other HTTP responses.\nWhen inserted by a RI, the received-protocol portion of the header field value should be set to \"HTTP/2.0\" or \"2.0\" and the received-by portion of the header field value should be formatted as follows:\n- \"RI-<RI FQDN>\" for a RI\nServer\nIETF RFC 9110 [9]\nThis header should be inserted by the originator of an HTTP error response (see clause 6.10.8 of 3GPP TS 29.500 [4]). It may be inserted otherwise.\nWhen inserted by a RI, the pattern of the header should be formatted as follows:\n- \"RI-<RI FQDN>\" for a RI\nNOTE:\tThe inclusion of the Via and Server header in an HTTP CONNECT error response message enables the receiving SEPP to determine which RI has rejected the request in scenarios with two RIs between the SEPPs.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_29.500_clause_6.10.8",
        "table_7.2-1",
        "ts_29.500"
      ]
    },
    {
      "chunk_id": "ts_29.573_7.3.1",
      "section_id": "7.3.1",
      "section_title": "3gpp-Connect-Req-Info",
      "content": "The header enables to convey information in the HTTP CONNECT request to the RI, that may be used by the RI to determine whether to allow the establishment of the N32-c connection and/or for troiuble-shooting.\nThe encoding of the header follows the ABNF as defined in IETF RFC 9110 [9].\nSbí-Connect-Req-Info-Header = \"3gpp-Connect-Req-Info:\" OWS connect-purpose\";\" OWS orig-network-id \";\" OWS sender-fqdn [\";\" OWS intended-n32-purposes] *( \";\" OWS req-param ) OWS\nconnect-purpose = \"connect-purpose=\" OWS connect-purpose-value\nconnect-purpose-value = \"n32c\" / token\norig-network-id = \"originating-network-id=\" OWS 3DIGIT \"-\" 2*3DIGIT [ \"-\" 11HEXDIG ]\nsender-fqdn = \"sender-fqdn=\" OWS 4*( ALPHA / DIGIT / \"-\" / \".\" )\nintended-n32-purposes = intended-n32-purpose *(\";\" OWS intended-n32-purpose)\nintended-n32-purpose = \"intended-n32-purpose=\" OWS n32-purpose-value\nn32-purpose-value = \"ROAMING\"\n/ \"INTER_PLMN_MOBILITY\"\n/ \"SMS_INTERCONNECT\"\n/ \"ROAMING_TEST\"\n/ \"INTER_PLMN_MOBILITY_TEST\"\n/ \"SMS_INTERCONNECT_TEST\"\n/ \"SNPN_INTERCONNECT\"\n/ \"SNPN_INTERCONNECT_TEST\"\n/ \"DISASTER_ROAMING\"\n/ \"DISASTER_ROAMING_TEST\"\n/ \"DATA_ANALYTICS_EXCHANGE\"\n/ \"DATA_ANALYTICS_EXCHANGE_TEST\"\n/ token\nreq-param = req-param-name \"=\" OWS req-param-value\nreq-param-name = token\nreq-param-value = token\nEXAMPLE 1:\tFor an HTTP CONNECT request message from the c-SEPP to the RI-A to request establishing the TCP connection towards the p-SEPP:3gpp-Connect-Req-Info: connect-purpose=n32c; originating-network-id=123-45;sender-fqdn=sepp12.5gc.mnc155.mcc400.3gppnetwork;intended-n32-purpose=ROAMING;intended-32-purpose=SMS_INTERCONNECT\nEXAMPLE 2:\tFor an HTTP CONNECT request message from the RI-A to the RI-B to request establishing the TCP connection towards p-SEPP:3gpp-Connect-Req-Info: connect-purpose=n32c;originating-network-id=123-45;sender-fqdn=ri234.rioperator.com;intended-n32-purpose=ROAMING;intended-n32-purpose=SMS_INTERCONNECT",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_7.3.2",
      "section_id": "7.3.2",
      "section_title": "3gpp-Connect-Resp-Info",
      "content": "The header enables to convey information in the HTTP CONNECT response towards the c-SEPP.\nThe encoding of the header follows the ABNF as defined in IETF RFC 9110 [9].\nSbi-Connect-Resp-Info-Header = \"3gpp-Connect-Resp-Info:\" OWS resp-param *( \";\" OWS resp-param ) OWS\nresp-param = allowed-n32-purposes / p-sepp-fqdn / other-resp-param\nallowed-n32-purposes = allowed-n32-purpose *(\";\" OWS allowed-n32-purpose)\nallowed-n32-purpose = \"allowed-n32-purpose=\" OWS n32-purpose-value\np-sepp-fqdn = \"p-sepp-fqdn=\" OWS 4*( ALPHA / DIGIT / \"-\" / \".\" )\nother-resp-param = other-resp-param-name \"=\" OWS other-resp-param-value\nother-resp-param-name = token\nother-resp-param-value = token\nEXAMPLE: \t3gpp-Connect-Resp-Info: allowed-n32-purpose=ROAMING;allowed-n32-purpose=SMS_INTERCONNECT;p-sepp-fqdn=sepp2.5gc.mnc203.mcc422.3gppnetwork.org",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_29.573_7.4.1",
      "section_id": "7.4.1",
      "section_title": "General",
      "content": "HTTP/2 connection error and stream error shall be supported as specified in clause 5.4 of IETF RFC 9113 [7].\nUpon detecting an error, the RI shall send an 4XX or 5XX error response. The error response should include a ProblemDetails object providing details on the error and including one of the application errors defined in Table 7.4.2-1.",
      "chunk_type": "definition",
      "cross_references": [
        "clause_5.4",
        "table_7.4.2-1"
      ]
    },
    {
      "chunk_id": "ts_29.573_7.4.2",
      "section_id": "7.4.2",
      "section_title": "Application Errors",
      "content": "The application errors defined for the HTTP CONNECT service are listed in Table 7.4.2-1.\nTable 7.4.2-1: Application errors\nApplication Error\nHTTP status code\nDescription\nINVALID_MSG_FORMAT\n400 Bad Request\nIt is used when the c-SEPP sends an HTTP request with an invalid format.\nCONTRACTUAL_REASON\n403 Forbidden\nIt is used when the SEPP request does not match with the contract between the SEPP and RI.\nINSUFFICIENT_RESOURCES\n500 Internal Server Error\nIt is used when the RI does not have enough resources to establish the TCP connection toward the destination.\nSYSTEM_FAILURE\n500 Internal Server Error\nThe request is rejected due to generic error condition at the RI.\nCONNECTIVITY_ISSUE\n502 Bad Gateway\nIt is used when the RI cannot establish the connection towards the destination SEPP due to connectivity issue.\nAnnex A (normative):OpenAPI Specification\nA.1\tGeneral\nThis Annex specifies the formal definition of the N32 Handshake API(s) on the N32-c interface. It consists of OpenAPI 3.0.0 specifications, in YAML format.\nThis Annex takes precedence when being discrepant to other parts of the specification with respect to the encoding of information elements and methods within the API(s).\nNOTE:\tThe semantics and procedures, as well as conditions, e.g. for the applicability and allowed combinations of attributes or values, not expressed in the OpenAPI definitions but defined in other parts of the specification also apply.\nInformative copies of the OpenAPI specification files contained in this 3GPP Technical Specification are available on a Git-based repository that uses the GitLab software version control system (see 3GPP TS 29.501 [5] clause 5.3.1 and 3GPP TR 21.900 [7] clause 5B).\nA.2\tN32 Handshake API\nopenapi: 3.0.0\ninfo:\nversion: '1.3.2'\ntitle: 'N32 Handshake API'\ndescription: |\nN32-c Handshake Service.\n© 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\nservers:\n- url: '{apiRoot}/n32c-handshake/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription:  apiRoot as defined in clause 4.4 of 3GPP TS 29.501.\nexternalDocs:\ndescription: 3GPP TS 29.573 V18.9.0; 5G System; Public Land Mobile Network (PLMN) Interconnection; Stage 3\nurl: https://www.3gpp.org/ftp/Specs/archive/29_series/29.573/\npaths:\n/exchange-capability:\npost:\nsummary:  Security Capability Negotiation\ntags:\n- Security Capability Negotiation\noperationId: PostExchangeCapability\nrequestBody:\ndescription: Custom operation for security capability negotiation\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecNegotiateReqData'\nresponses:\n'200':\ndescription: OK (Successful negitiation of security capabilities)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecNegotiateRspData'\n'307':\ndescription: redirection\ncontent:\napplication/problem+json:\nschema:\n$ref: '#/components/schemas/ExtRedirectResponse'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'409':\n$ref: 'TS29571_CommonData.yaml#/components/responses/409'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n/exchange-params:\npost:\nsummary: Parameter Exchange\ntags:\n- Parameter Exchange\noperationId: PostExchangeParams\nrequestBody:\ndescription: Custom operation for parameter exchange\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecParamExchReqData'\nresponses:\n'200':\ndescription: OK (Successful exchange of parameters)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecParamExchRspData'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'409':\n$ref: 'TS29571_CommonData.yaml#/components/responses/409'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n/n32f-terminate:\npost:\nsummary: N32-f Context Terminate\ntags:\n- N32-f Context Terminate\noperationId: PostN32fTerminate\nrequestBody:\ndescription: Custom operation for n32-f context termination\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fContextInfo'\nresponses:\n'200':\ndescription: OK (Successful exchange of parameters)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fContextInfo'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n/n32f-error:\npost:\nsummary: N32-f Error Reporting Procedure\ntags:\n- N32-f Error Report\noperationId: PostN32fError\nrequestBody:\ndescription: Custom operation for n32-f error reporting procedure\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fErrorInfo'\nresponses:\n'204':\ndescription: successful error reporting\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\ncomponents:\nschemas:\nSecurityCapability:\ndescription: Enumeration of security capabilities\nanyOf:\n- type: string\nenum:\n- TLS\n- PRINS\n- NONE\n- type: string\nApiSignature:\ndescription: API URI of the service operation\noneOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/Uri'\n- $ref: '#/components/schemas/CallbackName'\nHttpMethod:\ndescription: Enumeration of HTTP methods\nanyOf:\n- type: string\nenum:\n- GET\n- PUT\n- POST\n- DELETE\n- PATCH\n- HEAD\n- OPTIONS\n- CONNECT\n- TRACE\n- type: string\nIeType:\ndescription: Enumeration of types of IEs (i.e kind of IE) to specify the protection policy\nanyOf:\n- type: string\nenum:\n- UEID\n- LOCATION\n- KEY_MATERIAL\n- AUTHENTICATION_MATERIAL\n- AUTHORIZATION_TOKEN\n- RECURSIVE_NON_LEAF\n- OTHER\n- NONSENSITIVE\n- type: string\nIeLocation:\ndescription: Location of the IE in a HTTP message\nanyOf:\n- type: string\nenum:\n- URI_PARAM\n- HEADER\n- BODY\n- MULTIPART_BINARY\n- URI_PATH\n- type: string\nIeInfo:\ndescription: Protection and modification policy for the IE\ntype: object\nrequired:\n- ieLoc\n- ieType\nproperties:\nieLoc:\n$ref: '#/components/schemas/IeLocation'\nieType:\n$ref: '#/components/schemas/IeType'\nreqIe:\ntype: string\nrspIe:\ntype: string\nisModifiable:\ntype: boolean\nisModifiableByIpx:\ntype: object\nadditionalProperties:\ntype: boolean\nminProperties: 1\nancestorIe:\ntype: string\nApiIeMapping:\ndescription: API URI to IE mapping on which the protection policy needs to be applied\ntype: object\nrequired:\n- apiSignature\n- apiMethod\n- IeList\nproperties:\napiSignature:\n$ref: '#/components/schemas/ApiSignature'\napiMethod:\n$ref: '#/components/schemas/HttpMethod'\nIeList:\ntype: array\nitems:\n$ref: '#/components/schemas/IeInfo'\nminItems: 1\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nProtectionPolicy:\ndescription: The protection policy to be negotiated between the SEPPs\ntype: object\nrequired:\n- apiIeMappingList\nproperties:\napiIeMappingList:\ntype: array\nitems:\n$ref: '#/components/schemas/ApiIeMapping'\nminItems: 1\ndataTypeEncPolicy:\ntype: array\nitems:\n$ref: '#/components/schemas/IeType'\nminItems: 1\nSecNegotiateReqData:\ndescription: Defines the security capabilities of a SEPP sent to a receiving SEPP\ntype: object\nrequired:\n- sender\n- supportedSecCapabilityList\nproperties:\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nn32HandshakeId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nsupportedSecCapabilityList:\ntype: array\nitems:\n$ref: '#/components/schemas/SecurityCapability'\nminItems: 1\n3GppSbiTargetApiRootSupported:\ntype: boolean\ndefault: false\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nplmnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnId'\nminItems: 1\nsnpnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnIdNid'\nminItems: 1\ntargetPlmnId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnId'\ntargetSnpnId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnIdNid'\nintendedUsagePurpose:\ntype: array\nitems:\n$ref: '#/components/schemas/IntendedN32Purpose'\nminItems: 1\nsupportedFeatures:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/SupportedFeatures'\nsenderN32fFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nsenderN32fPort:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Uinteger'\nn32KeepaliveTimer:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/DurationSec'\nSecNegotiateRspData:\ndescription: Defines the selected security capabilities by a SEPP\ntype: object\nrequired:\n- sender\n- selectedSecCapability\nproperties:\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nselectedSecCapability:\n$ref: '#/components/schemas/SecurityCapability'\nn32HandshakeId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\n3GppSbiTargetApiRootSupported:\ntype: boolean\ndefault: false\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nplmnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnId'\nminItems: 1\nsnpnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnIdNid'\nminItems: 1\nallowedUsagePurpose:\ntype: array\nitems:\n$ref: '#/components/schemas/IntendedN32Purpose'\nminItems: 1\nrejectedUsagePurpose:\ntype: array\nitems:\n$ref: '#/components/schemas/IntendedN32Purpose'\nminItems: 1\nsupportedFeatures:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/SupportedFeatures'\nsenderN32fFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nsenderN32fPortList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Uinteger'\nminItems: 1\nn32KeepaliveTimer:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/DurationSec'\nSecParamExchReqData:\ndescription: Request data structure for parameter exchange\ntype: object\nrequired:\n- n32fContextId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\njweCipherSuiteList:\ntype: array\nitems:\ntype: string\nminItems: 1\njwsCipherSuiteList:\ntype: array\nitems:\ntype: string\nminItems: 1\nprotectionPolicyInfo:\n$ref: '#/components/schemas/ProtectionPolicy'\nsecProfiles:\ntype: array\nitems:\ntype: string\nminItems: 1\nmaxItems: 256\nipxProviderSecInfoList:\ntype: array\nitems:\n$ref: '#/components/schemas/IpxProviderSecInfo'\nminItems: 1\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nSecParamExchRspData:\ndescription: Response data structure for parameter exchange\ntype: object\nrequired:\n- n32fContextId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nselectedJweCipherSuite:\ntype: string\nselectedJwsCipherSuite:\ntype: string\nselProtectionPolicyInfo:\n$ref: '#/components/schemas/ProtectionPolicy'\nselSecProfiles:\ntype: array\nitems:\ntype: string\nminItems: 1\nmaxItems: 256\nipxProviderSecInfoList:\ntype: array\nitems:\n$ref: '#/components/schemas/IpxProviderSecInfo'\nminItems: 1\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nN32fContextInfo:\ndescription: N32-f context information\ntype: object\nrequired:\n- n32fContextId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nCallbackName:\ndescription: Callback Name\ntype: object\nrequired:\n- callbackType\nproperties:\ncallbackType:\ntype: string\nN32fErrorInfo:\ndescription: N32-f error information\ntype: object\nrequired:\n- n32fMessageId\n- n32fErrorType\nproperties:\nn32fMessageId:\ntype: string\nn32fErrorType:\n$ref: '#/components/schemas/N32fErrorType'\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nfailedModificationList:\ntype: array\nitems:\n$ref: '#/components/schemas/FailedModificationInfo'\nminItems: 1\nerrorDetailsList:\ntype: array\nitems:\n$ref: '#/components/schemas/N32fErrorDetail'\nminItems: 1\npolicyMismatchList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/InvalidParam'\nminItems: 1\nriErrorInformation:\n$ref: '#/components/schemas/RiErrorInformation'\nFailedModificationInfo:\ndescription: Information on N32-f modifications block that failed to process\ntype: object\nrequired:\n- ipxId\n- n32fErrorType\nproperties:\nipxId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nn32fErrorType:\n$ref: '#/components/schemas/N32fErrorType'\nN32fErrorDetail:\ndescription: Details about the N32f error\ntype: object\nrequired:\n- attribute\n- msgReconstructFailReason\nproperties:\nattribute:\ntype: string\nmsgReconstructFailReason:\n$ref: '#/components/schemas/FailureReason'\nIpxProviderSecInfo:\ndescription: Defines the security information list of an RI\ntype: object\nrequired:\n- ipxProviderId\nproperties:\nipxProviderId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nrawPublicKeyList:\ntype: array\nitems:\ntype: string\nminItems: 1\ncertificateList:\ntype: array\nitems:\ntype: string\nminItems: 1\nIntendedN32Purpose:\ndescription: Indicates the intended N32 establishment purpose\ntype: object\nrequired:\n- usagePurpose\nproperties:\nusagePurpose:\n$ref: '#/components/schemas/N32Purpose'\nadditionalInfo:\ntype: string\ncause:\ntype: string\nRiErrorInformation:\ndescription: RI error information\ntype: object\nproperties:\nn32fConnectionRelInd:\n$ref: '#/components/schemas/N32ReleaseIndication'\nn32fContextRelInd:\n$ref: '#/components/schemas/N32ReleaseIndication'\nalternativeRi:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nN32fErrorType:\ndescription: Type of error while processing N32-f message\nanyOf:\n- type: string\nenum:\n- INTEGRITY_CHECK_FAILED\n- INTEGRITY_CHECK_ON_MODIFICATIONS_FAILED\n- MODIFICATIONS_INSTRUCTIONS_FAILED\n- DECIPHERING_FAILED\n- MESSAGE_RECONSTRUCTION_FAILED\n- CONTEXT_NOT_FOUND\n- INTEGRITY_KEY_EXPIRED\n- ENCRYPTION_KEY_EXPIRED\n- POLICY_MISMATCH\n- NETWORK_MAINTENANCE\n- INSUFFICIENT_RESOURCES\n- NO_CONNECTION_DUE_TO_CONTRACT\n- IDLE_N32F_CONNECTION\n- SWITCHING_TO_ANOTHER_RI\n- NO_CONNECTION_DUE_TO_CONNECTIVITY\n- type: string\nFailureReason:\ndescription: Reason for failure to reconstruct a HTTP/2 message from N32-f message\nanyOf:\n- type: string\nenum:\n- INVALID_JSON_POINTER\n- INVALID_INDEX_TO_ENCRYPTED_BLOCK\n- INVALID_HTTP_HEADER\n- type: string\nN32Purpose:\ndescription: Usage purpose of establishing N32 connectivity\nanyOf:\n- type: string\nenum:\n- ROAMING\n- INTER_PLMN_MOBILITY\n- SMS_INTERCONNECT\n- ROAMING_TEST\n- INTER_PLMN_MOBILITY_TEST\n- SMS_INTERCONNECT_TEST\n- SNPN_INTERCONNECT\n- SNPN_INTERCONNECT_TEST\n- DISASTER_ROAMING\n- DISASTER_ROAMING_TEST\n- DATA_ANALYTICS_EXCHANGE\n- DATA_ANALYTICS_EXCHANGE_TEST\n- type: string\nN32ReleaseIndication:\ndescription: N32-f connection/context release indication\nanyOf:\n- type: string\nenum:\n- RELEASE_REESTABLISHMENT_ALLOWED\n- RELEASE_REESTABLISHMENT_NOT_ALLOWED\n- REESTABLISH\n- type: string\nExtRedirectResponse:\ndescription: Extension of the redirection response\nallOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/RedirectResponse'\n- $ref: '#/components/schemas/RedirectResponseAddInfo'\nRedirectResponseAddInfo:\ndescription: Additional information in the redirection response\ntype: object\nproperties:\nseppFqdnForDiscovery:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nA.3\tJOSE Protected Message Forwarding API on N32-f\nopenapi: 3.0.0\ninfo:\nversion: '1.3.0'\ntitle: 'JOSE Protected Message Forwarding API'\ndescription: |\nN32-f Message Forwarding Service.\n© 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\nservers:\n- url: '{apiRoot}/n32f-forward/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription:  apiRoot as defined in clause 4.4 of 3GPP TS 29.501.\nexternalDocs:\ndescription: 3GPP TS 29.573 V18.7.0; 5G System; Public Land Mobile Network (PLMN) Interconnection; Stage 3\nurl: https://www.3gpp.org/ftp/Specs/archive/29_series/29.573/\npaths:\n/n32f-process:\npost:\nsummary:  N32-f Message Forwarding\ntags:\n- N32-f Forward\noperationId: PostN32fProcess\nparameters:\n- name: Content-Encoding\nin: header\ndescription: Content-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n- name: Accept-Encoding\nin: header\ndescription: Accept-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n- name: 3gpp-Sbi-Message-Priority\nin: header\ndescription: 3gpp-Sbi-Message-Priority, defined in 3GPP TS 29.500\nschema:\ntype: string\nrequestBody:\ndescription: Custom operation N32-f Message Forwarding\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fReformattedReqMsg'\nresponses:\n'200':\ndescription: OK (Successful forwarding of reformatted message over N32-f)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fReformattedRspMsg'\nheaders:\nAccept-Encoding:\ndescription: Accept-Encoding, described in IETF RFC 9110\nschema:\ntype: string\nContent-Encoding:\ndescription: Content-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n3gpp-Sbi-Message-Priority:\ndescription: 3gpp-Sbi-Message-Priority, defined in 3GPP TS 29.500\nschema:\ntype: string\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\ndescription: Forbidden\ncontent:\napplication/problem+json:\nschema:\n$ref: '#/components/schemas/ProblemDetailsMsgForwarding'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\noptions:\nsummary: Discover communication options supported by next hop (RI or SEPP)\noperationId: N32fProcessOptions\ntags:\n- N32-f Forward\nresponses:\n'204':\ndescription: No Content\nheaders:\nAccept-Encoding:\ndescription: Accept-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'405':\n$ref: 'TS29571_CommonData.yaml#/components/responses/405'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'501':\n$ref: 'TS29571_CommonData.yaml#/components/responses/501'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\n$ref: 'TS29571_CommonData.yaml#/components/responses/default'\ncomponents:\nschemas:\n#\n# STRUCTURED TYPES\n#\nFlatJweJson:\ndescription: Contains the integrity protected reformatted block\ntype: object\nrequired:\n- ciphertext\nproperties:\nprotected:\ntype: string\nunprotected:\ntype: object\nheader:\ntype: object\nencrypted_key:\ntype: string\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\naad:\ntype: string\niv:\ntype: string\nciphertext:\ntype: string\ntag:\ntype: string\nFlatJwsJson:\ndescription: Contains the modification from RIs on path\ntype: object\nrequired:\n- payload\n- signature\nproperties:\npayload:\ntype: string\nprotected:\ntype: string\nheader:\ntype: object\nsignature:\ntype: string\nN32fReformattedReqMsg:\ndescription: Contains the reformatted HTTP/2 request message\ntype: object\nrequired:\n- reformattedData\nproperties:\nreformattedData:\n$ref: '#/components/schemas/FlatJweJson'\nmodificationsBlock:\ntype: array\nitems:\n$ref: '#/components/schemas/FlatJwsJson'\nminItems: 1\nN32fReformattedRspMsg:\ndescription: Contains the reformatted HTTP/2 response message\ntype: object\nrequired:\n- reformattedData\nproperties:\nreformattedData:\n$ref: '#/components/schemas/FlatJweJson'\nmodificationsBlock:\ntype: array\nitems:\n$ref: '#/components/schemas/FlatJwsJson'\nminItems: 1\nDataToIntegrityProtectAndCipherBlock:\ndescription: HTTP header to be encrypted or the value of a JSON attribute to be encrypted\ntype: object\nrequired:\n- dataToEncrypt\nproperties:\ndataToEncrypt:\ntype: array\nitems: {}\nminItems: 1\nDataToIntegrityProtectBlock:\ndescription: Data to be integrity protected\ntype: object\nproperties:\nmetaData:\n$ref: '#/components/schemas/MetaData'\nrequestLine:\n$ref: '#/components/schemas/RequestLine'\nstatusLine:\ntype: string\nheaders:\ntype: array\nitems:\n$ref: '#/components/schemas/HttpHeader'\nminItems: 1\npayload:\ntype: array\nitems:\n$ref: '#/components/schemas/HttpPayload'\nminItems: 1\nRequestLine:\ndescription: >\nContains the request line of the HTTP API request being reformatted and forwarded over N32-f\ntype: object\nrequired:\n- method\n- scheme\n- authority\n- path\n- protocolVersion\nproperties:\nmethod:\n$ref: 'TS29573_N32_Handshake.yaml#/components/schemas/HttpMethod'\nscheme:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/UriScheme'\nauthority:\ntype: string\npath:\ntype: string\nprotocolVersion:\ntype: string\nqueryFragment:\ntype: string\npathQueryProtectInd:\ntype: array\nitems:\n$ref: 'TS29573_N32_Handshake.yaml#/components/schemas/IeLocation'\nminItems: 1\nmaxItems: 2\nHttpHeader:\ndescription: Contains the encoding of HTTP headers in the API request / response\ntype: object\nrequired:\n- header\n- value\nproperties:\nheader:\ntype: string\nvalue:\n$ref: '#/components/schemas/EncodedHttpHeaderValue'\nHttpPayload:\ndescription: Contains the encoding of JSON content in the API request / response\ntype: object\nrequired:\n- iePath\n- ieValueLocation\n- value\nproperties:\niePath:\ntype: string\nieValueLocation:\n$ref: 'TS29573_N32_Handshake.yaml#/components/schemas/IeLocation'\nvalue:\ntype: object\nMetaData:\ndescription: Contains the meta data information needed for replay protection\ntype: object\nrequired:\n- n32fContextId\n- messageId\n- authorizedIpxId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nmessageId:\ntype: string\nauthorizedIpxId:\ntype: string\nriFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nModifications:\ndescription: Information on inserting of the modifications entry\ntype: object\nrequired:\n- identity\nproperties:\nidentity:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\noperations:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PatchItem'\nminItems: 1\ntag:\ntype: string\nIndexToEncryptedValue:\ndescription: Index to the encrypted value\ntype: object\nrequired:\n- encBlockIndex\nproperties:\nencBlockIndex:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Uinteger'\nEncodedHttpHeaderValue:\ndescription: HTTP header value or index to the HTTP header value\noneOf:\n- type: string\n- $ref: '#/components/schemas/IndexToEncryptedValue'\nProblemDetailsMsgForwarding:\ndescription: N32-f message forwarding Error Detail\nallOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/ProblemDetails'\n- $ref: '#/components/schemas/AdditionInfoMsgForwarding'\nAdditionInfoMsgForwarding:\ndescription: Problem Details extensions for N32-f message forwarding\nproperties:\nsuggestedStatusCode:\ntype: integer\nsuggestedProblemDetails:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/ProblemDetails'\nriErrorInformation:\n$ref: 'TS29573_N32_Handshake.yaml#/components/schemas/RiErrorInformation'\n#\n# SIMPLE TYPES\n#\n#\n# ENUMS\n#\nA.4\tSEPP Telescopic FQDN Mapping API\nopenapi: 3.0.0\ninfo:\nversion: '1.2.0'\ntitle: 'SEPP Telescopic FQDN Mapping API'\ndescription: |\nSEPP Telescopic FQDN Mapping Service.\n© 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\nservers:\n- url: '{apiRoot}/nsepp-telescopic/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription:  apiRoot as defined in clause 4.4 of 3GPP TS 29.501.\nexternalDocs:\ndescription: 3GPP TS 29.573 V18.7.0; 5G System; Public Land Mobile Network (PLMN) Interconnection; Stage 3\nurl: https://www.3gpp.org/ftp/Specs/archive/29_series/29.573/\npaths:\n/mapping:\nget:\nsummary: Maps an FQDN to/from a telescopic FQDN\noperationId: GetTelescopicMapping\ntags:\n- Telescopic Mapping (Document)\nparameters:\n- name: foreign-fqdn\nin: query\ndescription: FQDN of the NF in the foreign PLMN\nschema:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\n- name: telescopic-label\nin: query\ndescription: Telescopic Label\nschema:\ntype: string\nresponses:\n'200':\ndescription: Expected response to a valid request\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/TelescopicMapping'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\n$ref: 'TS29571_CommonData.yaml#/components/responses/default'\ncomponents:\nschemas:\n#\n# STRUCTURED TYPES\n#\nTelescopicMapping:\ndescription: Contains the Telescopic mapping data\ntype: object\nproperties:\ntelescopicLabel:\ntype: string\nseppDomain:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nforeignFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\n#\n# SIMPLE TYPES\n#\n#\n# ENUMS\n#\nAnnex B (informative):Examples of N32-f Encoding\nB.1\tGeneral\nThis Annex provides some example encodings of HTTP/2 request and response messages initiated by NF service consumer / producer when they are reformatted and sent over N32-f\nB.2\tInput Message Containing No Binary Part\nConsider the following example:\n-\tSome headers of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tSome content part of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tThe input HTTP/2 message has no multipart/related binary content.\n-\tThe headers and content that are not required to be integrity protected and ciphered in the input HTTP/2 message need to be only integrity protected.\nThe N32fReformattedReqMessage for this example looks like\n\"reformattedData\": {\n\"protected\": BASE64URL(UTF8(JWE Protected Header),\n\"unprotected\": <non integrity protected shared JOSE headers>,\n\"header\": <non integrity protected recipient specific JOSE headers>,\n\"encrypted_key\": BASE64URL(JWE Encrypted Key),\n\"aad\": BASE64URL(DataToIntegrityProtectBlock),\n\"iv\": BASE64URL(JWE Initialization Vector),\n\"ciphertext\": BASE64URL(JWE CipherText(DataToIntegrityProtectAndCipherBlock),\n\"tag\": BASE64URL(JWE Authentication Tag)\n}\nThe DataToIntegrityProtectBlock for this example looks like\n{\n\"metaData\":\n{\n\"n32fContextId\": <the n32fcontext Id of receiving SEPP>,\n\"messageId\": <Id of the message>,\n\"authorizedIpxId\": <FQDN of the RI>\n},\n\"requestLine\":\n{\n\"method\": <http method of the NF service API>,\n\"scheme\": <http scheme of the NF service API>,\n\"authority\": <authority part of the NF service API URI>,\n\"path\": <path part of the NF service API URI>,\n\"protocolVersion\": <HTTP protocol version>,\n\"queryFragment\": <query fragment of the NF service API, if available>\n},\n\"headers\":\n[\n{\n\"header\": <name of HTTP header 1>,\n\"value\": {\"headerval\": <string carrying value of the header>}\n},\n{\n\"header\": <name of HTTP header 2>,\n\"value\": {\"encBlockIndex\": 1}\n}\n],\n\"payload\":\n[\n{\n\"iePath\": <JSON Pointer of IE 1>,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of IE>\n},\n{\n\"iePath\": <JSON Pointer of IE 2>,\n\"ieValueLocation\": \"BODY\",\n\"value\": {\"encBlockIndex\": 2}\n}\n]\n}\nThe DataToIntegrityProtectAndCipherBlock for this example looks like\n{\n\"dataToEncrypt\":\n[\n<value of HTTP header 2>,\n<value of payload 2>\n]\n}\nB.3\tInput Message Containing Multipart Binary Part\nConsider the following example:\n-\tSome headers of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tSome content part of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tThe input HTTP/2 message has two multipart/related binary content out of which one binary content needs to be integrity protected and ciphered while the other is only required to be integrity protected.\n-\tThe headers and content that are not required to be integrity protected and ciphered in the input HTTP/2 message need to be only integrity protected.\nThe N32fReformattedReqMessage for this example looks like\n\"reformattedData\": {\n\"protected\": BASE64URL(UTF8(JWE Protected Header),\n\"unprotected\": <non integrity protected shared JOSE headers>,\n\"header\": <non integrity protected recipient specific JOSE headers>,\n\"encrypted_key\": BASE64URL(JWE Encrypted Key),\n\"aad\": BASE64URL(DataToIntegrityProtectBlock),\n\"iv\": BASE64URL(JWE Initialization Vector),\n\"ciphertext\": BASE64URL(JWE CipherText(DataToIntegrityProtectAndCipherBlock),\n\"tag\": BASE64URL(JWE Authentication Tag)\n}\nThe DataToIntegrityProtectBlock for this example looks like\n{\n\"metaData\":\n{\n\"n32fContextId\": <the n32fcontext Id of receiving SEPP>,\n\"messageId\": <Id of the message>,\n\"authorizedIpxId\": <FQDN of the RI>\n},\n\"requestLine\":\n{\n\"method\": <http method of the NF service API>,\n\"scheme\": <http scheme of the NF service API>,\n\"authority\": <authority part of the NF service API URI>,\n\"path\": <path part of the NF service API URI>,\n\"protocolVersion\": <HTTP protocol version>,\n\"queryFragment\": <query fragment of the NF service API, if available>\n},\n\"headers\":\n[\n{\n\"header\": <name of HTTP header 1>,\n\"value\": {\"headerval\": <string carrying value of the header>}\n},\n{\n\"header\": <name of HTTP header 2>,\n\"value\": {\"encBlockIndex\": 1}\n}\n],\n\"payload\":\n[\n{\n\"iePath\": <JSON Pointer of IE 1>,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of IE>\n},\n{\n\"iePath\": <JSON Pointer of IE 2 - which is an attribute defined with the RefToBinaryData type>/contentId,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of the Content ID>\n},\n{\n\"iePath\": <JSON Pointer of IE 2 - which is an attribute defined with the RefToBinaryData type>/contenttype,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": <value of the Content Type>\n},\n{\n\"iePath\": <JSON Pointer of IE 2 - which is an attribute defined with the RefToBinaryData type>/data,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": <BASE 64 encoded byte array of the binary part>\n}\n{\n\"iePath\": <JSON Pointer of IE 3 - which is an attribute defined with the RefToBinaryData type>/contentId,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of the Content ID>\n},\n{\n\"iePath\": <JSON Pointer of IE 3 - which is an attribute defined with the RefToBinaryData type>/contenttype,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": <value of the Content Type>\n},\n{\n\"iePath\": <JSON Pointer of IE 3 - which is an attribute defined with the RefToBinaryData type>/data,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": {\"encBlockIndex\": 2}\n}\n]\n}\nNOTE:\tThe \"iePath\" for Content Type or data is a virtual path, which actually refers to the \"Content-Type\" and \"data\" in multipart body.\nEXAMPLE:\tIf the input HTTP message contains multipart binary part, as:POST /example.com/namf-comm/v1/ue-contexts/{ueContextId}/n1-n2-messages HTTP/2Content-Type: multipart/related; boundary=----BoundaryContent-Length: xyz------BoundaryContent-Type: application/json{    \"n2InfoContainer\": {      \"n2InformationClass\": \"SM\",      \"smInfo\": {        \"pduSessionId\": 5,        \"n2InfoContent\": {          \"ngapIeType\": \"PDU_RES_SETUP_REQ\",          \"ngapData\": {            \"contentId\": \"n2msg\"          }        }      }    },    \"pduSessionId\": 5}------BoundaryContent-Type: application/vnd.3gpp.ngapContent-Id: n2msg{ … N2 Information binary data …}------Boundarythe binary content needs to be integrity protected will be formatted, as:\"payload\":  [    {      \"iePath\": \"/n2InfoContainer/smInfo/n2InfoContent/ngapData/contentId\",      \"ieValueLocation\": \"BODY\",      \"value\": \"n2msg\"    },    {      \"iePath\": \"/n2InfoContainer/smInfo/n2InfoContent/ngapData/contenttype\",      \"ieValueLocation\": \"MULTIPART_BINARY\",      \"value\": \"application/vnd.3gpp.ngap\"    },    {      \"iePath\": \"/n2InfoContainer/smInfo/n2InfoContent/ngapData/data\",      \"ieValueLocation\": \"MULTIPART_BINARY\",      \"value\": <BASE 64 encoded byte array of N2 Information binary data >    }  ]\nThe DataToIntegrityProtectAndCipherBlock for this example looks like\n{\n\"dataToEncrypt\":\n[\n<value of HTTP header 2>,\n<byte array containing BASE 64 encoding of the binary part>\n]\n}\nB.4\tInput Message Containing Sensitive Information in URI Path and/or URI Query Parameters\nConsider the following example:\nPOST /nNf-service1/v1/(ueId)/service-operation-1?ue-loc={ueLocation}&query2={value of query parameter 2}\nin the above HTTP request,\n-\tOne Variable in URI path of the input HTTP/2 message needs to be integrity protected and ciphered, i.e. the UE ID.\n-\tOne URI query parameter of the input HTTP/2 message needs to be integrity protected and ciphered, i.e. UE location.\n-\tThe headers and content in the input HTTP/2 message need to be only integrity protected.\nThe N32fReformattedReqMessage for this example looks like\n\"reformattedData\": {\n\"protected\": BASE64URL(UTF8(JWE Protected Header),\n\"unprotected\": <non integrity protected shared JOSE headers>,\n\"header\": <non integrity protected recipient specific JOSE headers>,\n\"encrypted_key\": BASE64URL(JWE Encrypted Key),\n\"aad\": BASE64URL(DataToIntegrityProtectBlock),\n\"iv\": BASE64URL(JWE Initialization Vector),\n\"ciphertext\": BASE64URL(JWE CipherText(DataToIntegrityProtectAndCipherBlock),\n\"tag\": BASE64URL(JWE Authentication Tag)\n}\nThe DataToIntegrityProtectBlock for this example looks like\n{\n\"metaData\":\n{\n\"n32fContextId\": <the n32fcontext Id of receiving SEPP>,\n\"messageId\": <Id of the message>,\n\"authorizedIpxId\": <FQDN of the RI>\n},\n\"requestLine\":\n{\n\"method\": <http method of the NF service API>,\n\"scheme\": <http scheme of the NF service API>,\n\"authority\": <authority part of the NF service API URI>,\n\"path\": \"/nNf-service1/v1/{\"encBlockIndex\":1}/service-operation-1\",\n\"protocolVersion\": <HTTP protocol version>,\n\"queryFragment\": \"ue-loc={\"encBlockIndex\":2}&query2={value of query parameter 2}\",\n\"pathQueryProtectInd\": [ \"URI_PATH\", \"URI_PARAM\" ]\n},\n\"headers\":\n[\n{\n\"header\": <name of HTTP header 1>,\n\"value\": {\"headerval\": <string carrying value of the header>}\n},\n{\n\"header\": <name of HTTP header 2>,\n\"value\": {\"headerval\": <string carrying value of the header>}\n}\n],\n\"payload\":\n[\n{\n\"iePath\": <JSON Pointer of IE 1>,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of IE>\n},\n{\n\"iePath\": <JSON Pointer of IE 2>,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of IE>\n}\n]\n}\nThe DataToIntegrityProtectAndCipherBlock for this example looks like\n{\n\"dataToEncrypt\":\n[\n<value of {ueId}>,\n<value of {ueLocation}>\n]\n}\nAnnex C (informative):End to end call flows when SEPP is on path\nC.1\tGeneral\nThis Annex provides an informative reference for how the end to end call flow works when the NF service consumer and the NF service producer are in different PLMNs and SEPP is involved on path.\nThe following clauses explain how the HTTP messages are forwarded between NF services in two PLMNs via the SEPP. In these clauses, the following aspects are not shown to avoid cluttering of the figures and procedure:\n-\tResolution of FQDN into an IP address using DNS. TCP / TLS connection for sending the HTTP/2 messages is initiated towards the IP address obtained from DNS resolution.\nWhen https URI scheme is used, TLS protection between the Network Function and the SEPP may rely on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header. See clause 6.1.4.3 of 3GPP TS 29.500 [4].\nC.2\tTLS security between SEPPs\nC.2.1\tWhen http URI scheme is used\nC.2.1.1\tGeneral\nThe following figure shows the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is TLS;\n-\t\"http\" scheme URI is used between the NF service consumer and NF service producer; and\n-\t\"http\" scheme URI is used for accessing NRF's NF discovery service.\nNOTE:\tThere may be one or more RI(s), offering only IP routing serving without content modification or observation of the information, in between the SEPPs.\nC.2.1.2\tWithout TLS protection between NF and SEPP and with TLS security without the 3gpp-Sbi-Target-apiRoot header used over N32f\nFigure C.2.1.2-1: End to end call flow when http scheme URI is used and TLS security without the 3gpp-Sbi-Target-apiRoot header used is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use TLS as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"http\" scheme URI to access the Nnrf_NFDiscovery service.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n5.\tThe c-SEPP forwards the NF discovery request within the N32-f TLS tunnel established in step 2.\n6.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n7.\tThe p-NRF sends the NF discovery response. The NF service profile contains service URI with \"http\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n8.\tThe p-SEPP forwards the NF discovery response within TLS tunnel to the c-SEPP.\n9.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n10.\tThe c-NRF sends the NF discovery response to NF service consumer.\n11.\tThe NF service profile received at the NF service consumer contains service URI with \"http\" scheme. The NF service consumer initiates a HTTP message (as supported by the NF service producer API) using \"http\" scheme URI. The NF service consumer is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n12.\tThe c-SEPP forwards the HTTP service request within the N32-f TLS tunnel established in step 2.\n13.\tThe p-SEPP forwards the HTTP service request to the NF service producer.\n14.\tThe NF service producer sends the HTTP service response.\n15.\tThe p-SEPP forwards the HTTP service response within TLS tunnel to the c-SEPP.\n16.\tThe c-SEPP forwards the HTTP service response to the NF service consumer.\nC.2.1.3\tWithout TLS protection between NF and SEPP and with TLS security with the 3gpp-Sbi-Target-apiRoot header used over N32f\nFigure C.2.1.3-1: End to end call flow when http scheme URI is used and TLS security with the 3gpp-Sbi-Target-apiRoot header used is used between SEPPs\n1.\tSame as step 1 of Figure C.2.1.2-1.\n2.\tSame as step 3 of Figure C.2.1.2-1\n3.\tSame as step 4 of Figure C.2.1.2-1\n4.\tThe c-SEPP setups a TLS connection with the authoritative server for the p-SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-SEPP. The c-SEPP is configured with the p-SEPP FQDN.\n5.\tThe c-SEPP sets the apiRoot in the request URI with the apiRoot of the p-SEPP, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF, and sends the request towards p-SEPP.\n6.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"http\", the p-SEPP forwards the NF discovery request to the p-NRF.\n7 to 11.\tSame as steps 7 to 11 of Figure C.2.1.2-1.\n12.\tThe c-SEPP sets the apiRoot of the p-SEPP FQDN in the request URI, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF, and sends the request towards p-SEPP.\n13.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and then seeing that the URI scheme of the NF service producer is \"http\", the p-SEPP forwards the request to the p-NF.\n13 to 16. Same as steps 13 to 16 of Figure C.2.1.2-1.\nC.2.2\tWhen https URI scheme is used\nC.2.2.1\tGeneral\nThe following figures show the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is TLS;\n-\t\"https\" scheme URI is used between the NF service consumer and NF service producer;\n-\t\"https\" scheme URI is used for accessing NRF's NF discovery service; and\n-\tTLS protection between NF and SEPP relies on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header.\nC.2.2.2\tWith TLS protection between NF and SEPP relying on telescopic FQDN, and TLS security without the 3gpp-Sbi-Target-apiRoot header used over N32f\nFigure C.2.2.2-1: End to end call flow when https scheme URI is used, telescopic FQDNs are used between NF and SEPP and TLS security without the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use TLS as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"https\" scheme URI to access the Nnrf_NFDiscovery service. This implies that the NF service consumer sets up a TLS connection to the c-NRF and then sends the HTTP request over the TLS connection to the c-NRF.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. Since \"https\" requires setup of TLS connection with the p-NRF and it requires that c-NRF has to verify that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-NRF, a telescopic FQDN with wildcarded certificate scheme mechanism is specified in 3GPP TS 33.501 [6]. The c-NRF is configured with the telescopic FQDN of the p-NRF with the telescopic FQDN having the FQDN of the c-SEPP as the trailing part. The c-NRF sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. the c-SEPP).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the telescopic FQDN in the request URI with the FQDN of the p-NRF and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF is in the request URI \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n9.\tThe p-NRF sends the NF discovery response within the TLS connection. The NF service profile contains service URI with \"https\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n10.\tThe p-SEPP forwards the NF discovery response within TLS tunnel setup in step 2 to the c-SEPP. The p-SEPP may replace the inter PLMN FQDN of the NF service producer's API endpoint with a label representing that FQDN. The p-SEPP re-maps the label with the NF service producer's API endpoint in step 17.\n11.\tThe c-SEPP upon receiving the HTTP response message for NF discovery response, within the TLS tunnel in step 2, replaces the trailing part of the inter PLMN FQDN of the NF service producer's API endpoint in the NF service profile with the FQDN of the c-SEPP, to form a telescopic FQDN as specified in clause 28.5.2 of 3GPP TS 23.003 [19]. The c-SEPP may replace the label part of the telescopic FQDN with a label of it's own significance. The p-SEPP re-maps the label in step 16.\n12.\tThe c-SEPP then forwards the NF discovery response to c-NRF, with the NF service profile containing the telescopic FQDN.\n13.\tThe c-NRF sends the NF discovery response to NF service consumer.\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. The NF service consumer sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. c-SEPP) received in step 13.\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the telescopic FQDN in the request URI the FQDN of the NF service producer and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF service producer in the request URI is \"https\", the p-SEPP sets up a TLS connection with the NF service producer. The p-SEPP also replaces callback URI and link relations within the extracted HTTP message with a telescopic FQDN containing the FQDN of the p-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n18.\tThe p-SEPP forwards the HTTP request to the NF service producer.\n19.\tThe NF service producer sends the HTTP response within the TLS connection.\n20.\tThe p-SEPP forwards the HTTP response within TLS tunnel setup in step 2 to the c-SEPP.\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer. The c-SEPP replaces callback URI and link relations within the extracted HTTP response message with a telescopic FQDN containing the FQDN of the c-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\nC.2.2.3\tWith TLS protection between NF and SEPP relying on 3gpp-Sbi-Target-apiRoot header, and TLS security without the 3gpp-Sbi-Target-apiRoot header used over N32f\nFigure C.2.2.3-1 End to end call flow when https scheme URI is used, 3gpp-Sbi-Target-apiRoot header is used between NF and SEPP and TLS security without the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tSame as step 1 of Figure C.2.2.2-1.\n2.\tSame as step 2 of Figure C.2.2.2-1.\n3.\tSame as step 3 of Figure C.2.2.2-1\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. The c-NRF setups a TLS connection with the authoritative server for the SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the c-SEPP. The c-NRF is configured with the c-SEPP FQDN, or the c-SEPP registered to the c-NRF (including c-SEPP FQDN in its profile).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection, including an 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tSame as step 8 of Figure C.2.2.2-1\n9.\tSame as step 9 of Figure C.2.2.2-1\n10.\tSame as step 10 of Figure C.2.2.2-1\n11, 12.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n13.\tSame as step 13 of Figure C.2.2.2-1\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. Since the URI of the p-NF contains an authority of a remote PLMN, the NF service consumer sets up a TLS connection with the authoritative server for the SEPP FQDN (i.e. c-SEPP). The c-NF is configured with the c-SEPP FQDN, or the c-NF discovers the c-SEPP FQDN by querying the c-NRF.\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP, including a 3pp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18.\tSame as step 18 of Figure C.2.2.2-1\n19.\tSame as step 19 of Figure C.2.2.2-1\n20.\tSame as step 20 of Figure C.2.2.2-1\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer.\nC.2.2.4\tWith TLS protection between NF and SEPP relying on telescopic FQDN, and TLS security with the 3gpp-Sbi-Target-apiRoot header used over N32f\nFigure C.2.2.4-1: End to end call flow when https scheme URI is used, telescopic FQDNs are used between NF and SEPP and TLS security with the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tSame as step 1 of Figure C.2.2.2-1.\n2.\tSame as step 3 of Figure C.2.2.2-1.\n3.\tSame as step 4 of Figure C.2.2.2-1.\n4. Same as step 5 of Figure C.2.2.2-1\n5.\tThe c-SEPP setups a TLS connection with the authoritative server for the p-SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-SEPP. The c-SEPP is configured with the p-SEPP FQDN.\n6.\tThe c-SEPP sets the apiRoot in the request URI with the apiRoot of the p-SEPP, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF derived from the telescopic FQDN received in step 4, and sends the request towards p-SEPP.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8 to 15.\tSame as steps 8 to 15 of Figure C.2.2.3-1.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, sets the apiRoot of the p-SEPP FQDN in the request URI, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF derived from the telescopic FQDN received in step 15, and sends the request towards p-SEPP.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18 to 21.\tSame as steps 18 to 21 of Figure C.2.2.2-1\nC.2.2.5\tWith TLS protection between NF and SEPP relying on 3gpp-Sbi-Target-apiRoot header, and TLS security with the 3gpp-Sbi-Target-apiRoot header used over N32f\nFigure C.2.2.5-1: End to end call flow when https scheme URI is used, 3gpp-Sbi-Target-apiRoot header is used between NF and SEPP and TLS security with the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tSame as step 1 of Figure C.2.2.3-1.\n2.\tSame as step 3 of Figure C.2.2.3-1\n3.\tSame as step 4 of Figure C.2.2.3-1\n4.\tSame as step 5 of Figure C.2.2.3-1.\n5.\tThe c-SEPP setups a TLS connection with the authoritative server for the p-SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-SEPP. The c-SEPP is configured with the p-SEPP FQDN.\n6.\tThe c-SEPP sets the apiRoot in the request URI with the apiRoot of the p-SEPP and sends the request towards p-SEPP including the 3gpp-Sbi-Target-apiRoot header received in step 4.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8 to 15.\tSame as steps 8 to 15 of Figure C.2.2.3-1.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the apiRoot of the c-SEPP FQDN in the request URI with the apiRoot of the p-SEPP, and sends the request towards p-SEPP including the 3gpp-Sbi-Target-apiRoot header received in step 15.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18 to 21.\tSame as steps 18 to 21 of Figure C.2.2.2-1\nC.3\tApplication Layer Security between SEPPs\nC.3.1\tWhen http URI scheme is used\nThe following figure shows the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is \"PRINS\";\n-\t\"http\" scheme URI is used between the NF service consumer and NF service producer; and\n-\t\"http\" scheme URI is used for accessing NRF's NF discovery service.\nFigure C.3.1-1 End to end call flow when http scheme URI is used and \"PRINS\" security is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use \"PRINS\" as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding. If RIs are deployed between the c-SEPP and p-SEPP, the TLS connection is set up hop by hop with the authoritative server of the next hop.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"http\" scheme URI to access the Nnrf_NFDiscovery service.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n5.\tThe c-SEPP forwards the NF discovery request within the N32-f TLS tunnel established in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header.\n6.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n7.\tThe p-NRF sends the NF discovery response. The NF service profile contains service URI with \"http\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n8.\tThe p-SEPP forwards the NF discovery response within TLS tunnel to the c-SEPP using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively.\n9.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n10.\tThe c-NRF sends the NF discovery response to NF service consumer.\n11.\tThe NF service profile received at the NF service consumer contains service URI with \"http\" scheme. The NF service consumer initiates a HTTP message (as supported by the NF service producer API) using \"http\" scheme URI. The NF service consumer is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n12.\tThe c-SEPP forwards the HTTP service request within the N32-f TLS tunnel established in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header.\n13.\tThe p-SEPP forwards the HTTP service request to the NF service producer.\n14.\tThe NF service producer sends the HTTP service response.\n15.\tThe p-SEPP forwards the HTTP service response within TLS tunnel to the c-SEPP using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively.\n16.\tThe c-SEPP forwards the HTTP service response to the NF service consumer.\nC.3.2\tWhen https URI scheme is used\nC.3.2.1\tGeneral\nThe following figure shows the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is \"PRINS\";\n-\t\"https\" scheme URI is used between the NF service consumer and NF service producer; and\n-\t\"https\" scheme URI is used for accessing NRF's NF discovery service; and\n-\tTLS protection between NF and SEPP relies on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header.\nWhen https URI scheme is used, TLS protection between the Network Function and the SEPP may rely on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header. See clause 6.1.4.3 of 3GPP TS 29.500 [4].\nC.3.2.2\tWith TLS protection between NF and SEPP relying on telescopic FQDN\nFigure C.3.2.2-1 End to end call flow when https scheme URI is used, telescopic FQDNs are used between NF and SEPP and \"PRINS\" security is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use \"PRINS\" as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding. If RIs are deployed between the c-SEPP and p-SEPP, the TLS connection is set up hop by hop with the authoritative server of the next hop.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"https\" scheme URI to access the Nnrf_NFDiscovery service. This implies that the NF service consumer sets up a TLS connection to the c-NRF and then sends the HTTP request over the TLS connection to the c-NRF.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. Since \"https\" requires setup of TLS connection with the p-NRF and it requires that c-NRF has to verify that the certificate presented by the endpoint of the TLS connection belngs to the authoritative server of the p-NRF, a telescopic FQDN with wildcarded certificate scheme mechanism is specified in 3GPP TS 33.501 [6]. The c-NRF is configured with the telescopic FQDN of the p-NRF with the telescopic FQDN having the FQDN of the c-SEPP as the trailing part. The c-NRF sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. the c-SEPP).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the telescopic FQDN in the request URI with the FQDN of the p-NRF and sends the request towards p-SEPP in the TLS tunnel setup in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF in the request URI is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n9.\tThe p-NRF sends the NF discovery response within the TLS connection. The NF service profile contains service URI with \"https\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n10.\tThe p-SEPP forwards the NF discovery response within TLS tunnel setup in step 2 using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively, to the c-SEPP. The p-SEPP may replace the inter PLMN FQDN of the NF service producer's API endpoint with a label representing that FQDN. The p-SEPP re-maps the label with the NF service producer's API endpoint in step 17.\n11.\tThe c-SEPP upon receiving the HTTP response message for NF discovery response, within the TLS tunnel in step 2, replaces the trailing part of the inter PLMN FQDN of the NF service producer's API endpoint in the NF service profile with the FQDN of the c-SEPP, to form a telescopic FQDN as specified in clause 28.5.2 of 3GPP TS 23.003 [19]. The c-SEPP may replace the label part of the telescopic FQDN with a label of it's own significance. The p-SEPP re-maps the label in step 16.\n12.\tThe c-SEPP then forwards the NF discovery response to c-NRF, with the NF service profile containing the telescopic FQDN.\n13.\tThe c-NRF sends the NF discovery response to NF service consumer.\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. The NF service consumer sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. the c-SEPP).\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the the telescopic FQDN in the request URI with the FQDN of the NF service producer and sends the request towards p-SEPP in the TLS tunnel setup in step 2 using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF service producer in the request URI is \"https\", the p-SEPP sets up a TLS connection with the NF service producer. The p-SEPP also replaces callback URI and link relations within the extracted HTTP message with a telescopic FQDN containing the FQDN of the p-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n18.\tThe p-SEPP forwards the HTTP request to the NF service producer.\n19.\tThe NF service producer sends the HTTP response within the TLS connection.\n20.\tThe p-SEPP forwards the HTTP response within TLS tunnel setup in step 2 to the c-SEPP using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively.\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer. The c-SEPP replaces callback URI and link relations within the extracted HTTP response message with a telescopic FQDN containing the FQDN of the c-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\nC.3.2.3\tWith TLS protection between NF and SEPP relying on 3gpp-Sbi-Target-apiRoot header\nFigure C.3.2.3-1 End to end call flow when https scheme URI is used, 3gpp-Sbi-Target-apiRoot header is used between NF and SEPP and \"PRINS\" security is used between SEPPs\n1.\tSame as step 1 of Figure C.3.2.2-1.\n2.\tSame as step 2 of Figure C.3.2.2-1.\n3.\tSame as step 3 of Figure C.3.2.2-1.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. The c-NRF setups a TLS connection with the authoritative server for the SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the c-SEPP. The c-NRF is configured with the c-SEPP FQDN, or the c-SEPP registered to the c-NRF (including c-SEPP FQDN in its profile).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection, including an 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tSame as step 8 of Figure C.3.2.2-1.\n9.\tSame as step 9 of Figure C.3.2.2-1.\n10.\tSame as step 10 of Figure C.3.2.2-1.\n11, 12.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n13.\tSame as step 13 of Figure C.3.2.2-1.\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. Since the URI of the p-NF contains an authority of a remote PLMN, the NF service consumer sets up a TLS connection with the authoritative server for the SEPP FQDN (i.e. c-SEPP). The c-NF is configured with the c-SEPP FQDN, or the c-NF discovers the c-SEPP FQDN by querying the c-NRF.\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP, including a 3pp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2 using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18.\tSame as step 18 of Figure C.3.2.2-1.\n19.\tSame as step 19 of Figure C.3.2.2-1.\n20.\tSame as step 20 of Figure C.3.2.2-1.\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer.\nAnnex D (informative):Withdrawn API versions\nD.1\tGeneral\nThis Annex lists withdrawn API versions of the APIs defined in the present specification. 3GPP TS 29.501 [5] clause 4.3.1.6 describes the withdrawal of API versions.\nD.2\tN32 Handshake API\nThe API versions listed in table D.2-1 are withdrawn for the N32 Handshake API.\nTable D.2-1: Withdrawn API versions of the N32 Handshake API service\nAPI version number\nReason for withdrawal\n1.0.0\nA backward incompatible change has been introduced in v1.0.1 to align with related stage 2 specifications. Indeed, the term \"ALS\" has been replaced by \"PRINS\" during the handshake procedure. As a consequence, the v1.0.0 must not be used in the field in order to avoid interoperability problem between roaming partners.\nAnnex E (Normative):ABNF grammar for HTTP custom headers\nE.1\tGeneral\nThis Annex contains a self-contained set of ABNF rules, comprising the re-used rules from IETF RFCs, and the rules defined by the 3GPP custom headers defined in this specification (see clause 7.3).\nThis grammar may be used as input to existing tools to help implementations to parse 3GPP custom headers.\nE.2\tABNF definitions (Filename:\"TS29573_CustomHeaders.abnf\")\n; ----------------------------------------\n;   RFC 5234\n; ----------------------------------------\nHTAB   = %x09 ; horizontal tab\nSP     = %x20\nDIGIT  = %x30-39 ; 0-9\nALPHA  = %x41-5A / %x61-7A ; A-Z / a-z\nHEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n; ----------------------------------------\n;   RFC 9110\n; ----------------------------------------\nOWS   = *( SP / HTAB )\ntchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\"\n/ \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\ntoken = 1*tchar\n; ----------------------------------------\n;   3GPP TS 29.573\n;\n;   Version: 18.7.0 (June 2024)\n;\n;   (c) 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\n; ----------------------------------------\n;\n; Header: 3gpp-Connect-Req-Info\n;\nSbi-Connect-Req-Info-Header = \"3gpp-Connect-Req-Info:\" OWS connect-purpose \";\" OWS\norig-network-id \";\" OWS sender-fqdn [ \";\" OWS intended-n32-purposes ]\n*( \";\" OWS req-param ) OWS\nconnect-purpose             = \"connect-purpose=\" OWS connect-purpose-value\nconnect-purpose-value       =  \"n32c\" / token\norig-network-id             = \"originating-network-id=\" OWS 3DIGIT \"-\" 2*3DIGIT [ \"-\" 11HEXDIG ]\nsender-fqdn                 = \"sender-fqdn=\" OWS 4*( ALPHA / DIGIT / \"-\" / \".\" )\nintended-n32-purposes       = intended-n32-purpose *( \";\" OWS intended-n32-purpose )\nintended-n32-purpose        = \"intended-n32-purpose=\" OWS n32-purpose-value\nn32-purpose-value           = \"ROAMING\"\n/ \"INTER_PLMN_MOBILITY\"\n/ \"SMS_INTERCONNECT\"\n/ \"ROAMING_TEST\"\n/ \"INTER_PLMN_MOBILITY_TEST\"\n/ \"SMS_INTERCONNECT_TEST\"\n/ \"SNPN_INTERCONNECT\"\n/ \"SNPN_INTERCONNECT_TEST\"\n/ \"DISASTER_ROAMING\"\n/ \"DISASTER_ROAMING_TEST\"\n/ \"DATA_ANALYTICS_EXCHANGE\"\n/ \"DATA_ANALYTICS_EXCHANGE_TEST\"\n/ token\nreq-param                   = req-param-name \"=\" OWS req-param-value\nreq-param-name              = token\nreq-param-value             = token\n;\n; Header: 3gpp-Connect-Resp-Info\n;\nSbi-Connect-Resp-Info-Header = \"3gpp-Connect-Resp-Info:\" OWS resp-param *( \";\" OWS resp-param ) OWS\nresp-param                   = allowed-n32-purposes / p-sepp-fqdn / other-resp-param\nallowed-n32-purposes         = allowed-n32-purpose *( \";\" OWS allowed-n32-purpose)\nallowed-n32-purpose          = \"allowed-n32-purpose=\" OWS n32-purpose-value\np-sepp-fqdn                  = \"p-sepp-fqdn=\" OWS 4*( ALPHA / DIGIT / \"-\" / \".\" )\nother-resp-param             = other-resp-param-name \"=\" OWS other-resp-param-value\nother-resp-param-name        = token\nother-resp-param-value       = token\n;\n; Header: 3gpp-Sbi-N32-Handshake-Id\n;\nSbi-N32-Handshake-Id-Header = \"3gpp-Sbi-N32-Handshake-Id:\" OWS n32HandshakeId OWS\nn32HandshakeId              = 16HEXDIG\nAnnex F (Informative):Examples of encoding of N32-c protection policies\nF.1\tGeneral\nThis clause provides examples of how protection policies are encoded in N32-c signaling.\nF.2\tProtection policies for an API with a schema without recursive non-leaf IEs\nThis clause provides an example of how to encode the IeList attribute in the protection policy for an API schema not using recursive data types.\nFor an API with the following example schema where the payload of a request or response is defined with one attribute x defined as an object X:\nPayload:\n{\nx: X\n}\nX:\n{\nx1: integer\nx2: string\nx3: Z\n}\nZ:\n{\nz1: string\nz2: integer\n}\nThe ApiIeMapping IE in the protection policy contains the following entries in the IeList array:\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"UEID\"\n\"reqIe\": \"x/x1\"\n\"isModifiable\": true\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"OTHER\"\n\"reqIe\": \"x/x2\"\n\"isModifiable\": false\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"OTHER\"\n\"reqIe\": \"x/x3/z1\"\n\"isModifiable\": true\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"OTHER\"\n\"reqIe\": \"x/x3/z2\"\n\"isModifiable\": false\n}\nF.3\tProtection policies for an API with a schema with recursive non-leaf IEs\nThis clause provides an example of how to encode the IeList attribute in the protection policy for an API schema using recursive data types.\nExample 1:\tFor an API with the following example schema where the payload of a request or response is defined with one attribute x defined as an object X and where the attribute x3 of the object X is also defined as an object X, i.e. where x3 is a recursive non-leaf IE:\nPayload:\n{\nx: X\n}\nX:\n{\nx1: integer\nx2: string\nx3: X\n}\nThe ApiIeMapping IE in the protection policy contains the following entries in the IeList array:\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"UEID\"\n\"reqIe\": \"x/x1\"\n\"isModifiable\": true\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"OTHER\"\n\"reqIe\": \"x/x2\"\n\"isModifiable\": false\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"RECURSIVE_NON_LEAF\"\n\"reqIe\": \"x/x3\"\n\"isModifiable\": true\n\"ancestorIe\": \"x\"\n}\nThe attribute x/x3 is defined as modifiable since the x1 attribute of the data type X is defined as modifiable.\nExample 2:\tFor an API with the following example schema where the payload of a request or response is defined with one attribute x defined as an object X and where the attribute y3 of the object Y is also defined as an object X (Recursively occurring at a lower level), i.e. where y3 is a recursive non-leaf IE:\nPayload:\n{\nx: X\n}\nX:\n{\nx1: integer\nx2: string\nx3: Y\n}\nY:\n{\ny1: integer\ny2: string\ny3: X\n}\nThe ApiIeMapping IE in the protection policy contains the following entries in the IeList array:\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"UEID\"\n\"reqIe\": \"x/x1\"\n\"isModifiable\": true\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"OTHER\"\n\"reqIe\": \"x/x2\"\n\"isModifiable\": false\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"LOCATION\"\n\"reqIe\": \"x/x3/y1\"\n\"isModifiable\": false\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"KEY_MATERIAL\n\"reqIe\": \"x/x3/y2\"\n\"isModifiable\": false\n}\n{\n\"ieLoc\":\"BODY\"\n\"ieType\":\"RECURSIVE_NON_LEAF\"\n\"reqIe\": \"x/x3/y3\"\n\"isModifiable\": true\n\"ancestorIe\": \"x\"\n}\nThe attribute x/x3/y3 is defined as modifiable since the x1 attribute of the data type X is defined as modifiable.\nAnnex G (informative):Change history\nChange history\nDate\nMeeting\nTDoc\nCR\nRev\nCat\nSubject/Comment\nNew version\n2018-07\nCT4#85bis\nC4-185523\nTS Skeleton, Scope, General Description and N32 Procedures. Implementation of C4-185531, C4-185353, C4-185352, C4-185469\n0.1.0\n2018-08\nCT4#86\nC4-186630\nImplementations of PCRs agreed in CT4#86 - C4-186157, C4-186421, C4-186422, C4-186423, C4-186425 and C4-186599\n0.2.0\n2018-09\nCT#81\nCP-182082\nPresented for information and approval\n1.0.0\n2018-09\nCT#81\nCP-182233\nApproved in CT#81\n15.0.0\n2018-12\nCT#82\nCP-183026\n0001\n1\nF\nResolve the editor's note on HTTP/2 connection management\n15.1.0\n2018-12\nCT#82\nCP-183026\n0002\n1\nF\nClarification to N32-f Forwarding Procedure\n15.1.0\n2018-12\nCT#82\nCP-183026\n0003\n2\nF\nN32-f Error Reporting\n15.1.0\n2018-12\nCT#82\nCP-183026\n0004\n2\nF\nResolve editor's notes on identification of notifications\n15.1.0\n2018-12\nCT#82\nCP-183026\n0005\n2\nF\nResolve Editor's Notes on RequestId and NextHopId\n15.1.0\n2018-12\nCT#82\nCP-183026\n0006\n2\nF\nGeneral Cleanup\n15.1.0\n2018-12\nCT#82\nCP-183026\n0007\n1\nF\nOpenAPI for N32 Handshake API\n15.1.0\n2018-12\nCT#82\nCP-183196\n0008\n2\nF\nOpenAPI for JOSE Protected Message Forwarding API on N32-f\n15.1.0\n2018-12\nCT#82\nCP-183026\n0009\n1\nF\nCardinality\n15.1.0\n2018-12\nCT#82\nCP-183026\n0010\n-\nF\nError Handling Clauses\n15.1.0\n2019-06\nCT#84\nCP-191043\n0011\n4\nF\nPLMN ID verification at receiving SEPP\n15.2.0\n2019-06\nCT#84\nCP-191043\n0012\n1\nF\nInformative Annex on End to End Call Flow via SEPP\n15.2.0\n2019-06\nCT#84\nCP-191043\n0013\n2\nF\nStorage of OpenAPI specification files\n15.2.0\n2019-06\nCT#84\nCP-191043\n0014\nF\nNew name for Application Layer Security protocol\n15.2.0\n2019-06\nCT#84\nCP-191043\n0015\n1\nF\nCopyright Note in YAML file\n15.2.0\n2019-06\nCT#84\nCP-191043\n0016\nF\n3GPP TS 29.573 API version update\n15.2.0\n2019-09\nCT#85\nCP-192114\n0017\nF\nALS renaming to PRINS\n15.3.0\n2019-09\nCT#85\nCP-192114\n0019\n1\nF\nAdd an Annex to Withdrawn N32 Handshake API v1.0.0\n15.3.0\n2019-09\nCT#85\nCP-192123\n0018\n1\nB\nTelescopic FQDN Mapping Service\n16.0.0\n2019-09\nCT#85\nCP-192080\n0020\n2\nB\nExchange IPX security information lists\n16.0.0\n2019-09\nCT#85\nCP-192123\n0021\nF\nSecurityNegotiateReqData in the Security Capability Negotiation\n16.0.0\n2019-09\nCT#85\nCP-192120\n0023\nF\n3GPP TS 29.573 API Version Update\n16.0.0\n2019-10\nCorrupted references fixed\n16.0.1\n2019-12\nCT#86\nCP-193063\n0024\nF\nCertificate and Public key Encoding\n16.1.0\n2019-12\nCT#86\nCP-193044\n0026\nF\n3GPP TS 29.573 API version update\n16.1.0\n2020-03\nCT#87\nCP-200039\n0027\n2\nF\nAdd Corresponding API descriptions in clause 5.1\n16.2.0\n2020-03\nCT#87\nCP-200016\n0028\n3\nF\nInter-PLMN communication using 3gpp-Sbi-Target-apiRoot\n16.2.0\n2020-03\nCT#87\nCP-200047\n0030\n2\nF\nCorrections to N32 procedures for PRINS (PRotocol for N32 INterconnect Security)\n16.2.0\n2020-03\nCT#87\nCP-200039\n0031\n2\nD\nEditorial corrections\n16.2.0\n2020-03\nCT#87\nCP-200039\n0032\n1\nF\nCorrection - formatting consistency\n16.2.0\n2020-03\nCT#87\nCP-200140\n0033\n3\nB\n29573 CR optionality of ProblemDetails\n16.2.0\n2020-03\nCT#87\nCP-200052\n0035\nF\n3GPP TS 29.573 Rel16 API External doc update\n16.2.0\n2020-07\nCT#88\nCP-201061\n0036\nF\nStorage of YAML files in ETSI Forge\n16.3.0\n2020-07\nCT#88\nCP-201061\n0037\n1\nF\nData type column in Resource URI variables Table\n16.3.0\n2020-07\nCT#88\nCP-201061\n0038\n1\nF\nAdd custom operation Name\n16.3.0\n2020-07\nCT#88\nCP-201327\n0039\n1\nF\n29.573 Rel-16 API version and External doc update\n16.3.0\n2020-09\nCT#89\nCP-202110\n0040\n1\nF\nN32f Error Type\n16.4.0\n2020-09\nCT#89\nCP-202119\n0041\n1\nF\nTLS security with the 3gpp-Sbi-Target-apiRoot header on N32f\n16.4.0\n2020-09\nCT#89\nCP-202119\n0042\nF\nCorrections to PRINS call flows\n16.4.0\n2020-09\nCT#89\nCP-202023\n0044\n3\nF\nError handling of mismatch of polices at SEPP\n16.4.0\n2020-09\nCT#89\nCP-202043\n0046\n2\nF\nCorrection of flow description\n16.4.0\n2020-09\nCT#89\nCP-202096\n0047\nF\n29.573 Rel-16 API version and External doc update\n16.4.0\n2020-12\nCT#90\nCP-203048\n0049\n3\nF\nPLMN ID handling over N32\n16.5.0\n2020-12\nCT#90\nCP-203048\n0050\n2\nF\nN32-f payload compression\n16.5.0\n2020-12\nCT#90\nCP-203037\n0051\nF\nUpdate of the metaData\n16.5.0\n2020-12\nCT#90\nCP-203037\n0052\n2\nF\nExchange of the modification policy\n16.5.0\n2020-12\nCT#90\nCP-203035\n0053\nF\nStorage of YAML files in 3GPP Forge\n16.5.0\n2020-12\nCT#90\nCP-203037\n0054\n2\nF\nUpdate the description of IeType\n16.5.0\n2020-12\nCT#90\nCP-203036\n0055\nF\nRel-16 API version and External doc update\n16.5.0\n2021-03\nCT#91-e\nCP-210062\n0058\nF\ndataToEncrypt encoding in DataToIntegrityProtectAndCipherBlock\n16.6.0\n2021-03\nCT#91-e\nCP-210058\n0059\n1\nF\nError handling for encBlockIndex\n16.6.0\n2021-03\nCT#91-e\nCP-210054\n0062\nF\n29.573 Rel-16 API version and External doc update\n16.6.0\n2021-03\nCT#91-e\nCP-210034\n0060\n1\nF\nOpenAPI Reference\n17.0.0\n2021-06\nCT#92-e\nCP-211081\n0064\n2\nA\nAnnex C.2.2.2 & C.3.2.2 correction of Telescopic FQDN handling in call flow over N32\n17.1.0\n2021-06\nCT#92-e\nCP-211028\n0065\nF\nData Types Descriptions\n17.1.0\n2021-06\nCT#92-e\nCP-211028\n0066\n1\nF\nDiscover the SEPP via NRF\n17.1.0\n2021-06\nCT#92-e\nCP-211051\n0068\n2\nF\nClarification to N32 protocol stack\n17.1.0\n2021-06\nCT#92-e\nCP-211050\n0069\nF\n29.573 Rel-17 API version and External doc update\n17.1.0\n2021-09\nCT#93-e\nCP-212076\n0071\n3\nA\nCorrection on Parameter Exchange procedure\n17.2.0\n2021-09\nCT#93-e\nCP-212076\n0073\n1\nA\nVia and server header\n17.2.0\n2021-09\nCT#93-e\nCP-212082\n0078\n1\nA\nEssential Correction in TLS for N32-f\n17.2.0\n2021-12\nCT#94-e\nCP-213085\n0083\nF\nCorrections to the API URI\n17.3.0\n2022-03\nCT#95-e\nCP-220025\n0089\n2\nB\nUsage indication over N32-c\n17.4.0\n2022-03\nCT#95-e\nCP-220032\n0086\nF\nAdding Missing table\n17.4.0\n2022-03\nCT#95-e\nCP-220032\n0079\n2\nB\nSEPP capability negotation\n17.4.0\n2022-03\nCT#95-e\nCP-220080\n0088\n1\nA\nSEPP for interconnect scenarios\n17.4.0\n2022-03\nCT#95-e\nCP-220080\n0075\n2\nA\nPLMN Specific N32-C connection\n17.4.0\n2022-03\nCT#95-e\nCP-220066\n0090\nF\n29.573 Rel-17 API version and External doc update\n17.4.0\n2022-06\nCT#96\nCP-221027\n0092\nF\nDescription of n32fContextId\n17.5.0\n2022-06\nCT#96\nCP-221028\n0093\n1\nF\nError response of JOSE Protected Forwarding\n17.5.0\n2022-06\nCT#96\nCP-221028\n0094\n1\nF\nN32f Error Report\n17.5.0\n2022-06\nCT#96\nCP-221027\n0095\nF\nInformative note for attributes not complying with 29.501 naming conventions\n17.5.0\n2022-06\nCT#96\nCP-221028\n0096\n1\nF\nCONTEXT_NOT_FOUND error report in N32c\n17.5.0\n2022-06\nCT#96\nCP-221028\n0097\n1\nF\nReuse of type Fqdn from 29.571\n17.5.0\n2022-06\nCT#96\nCP-221036\n0098\nB\nN32 usage with SNPN\n17.5.0\n2022-06\nCT#96\nCP-221029\n0099\nF\nCorrect the name of AuthenticatedBlock\n17.5.0\n2022-06\nCT#96\nCP-221029\n0101\nF\nInformative note for attributes not complying with 29.501 naming conventions\n17.5.0\n2022-06\nCT#96\nCP-221069\n0103\n2\nA\nMessage Containing Multipart Binary\n17.5.0\n2022-06\nCT#96\nCP-221069\n0107\nA\nJWE Authentication tag\n17.5.0\n2022-06\nCT#96\nCP-221029\n0108\nB\nSMS over N32\n17.5.0\n2022-06\nCT#96\nCP-221051\n0109\nF\nRel-17 API version and External doc update\n17.5.0\n2022-09\nCT#97-e\nCP-222051\n0116\n1\nF\nCorrection on applying modification policies\n17.6.0\n2022-09\nCT#97-e\nCP-222071\n0115\n1\nF\nModification policy in IPX\n17.6.0\n2022-09\nCT#97-e\nCP-222039\n0111\nF\nDisaster Roaming\n17.6.0\n2022-09\nCT#97-e\nCP-222052\n0112\n3\nF\nAdding the SBI Message Priority to N32f Message header\n17.6.0\n2022-09\nCT#97-e\nCP-222058\n0119\nF\n29.573 Rel-17 API version and External doc update\n17.6.0\n2022-09\nCT#97-e\nCP-222021\n0113\n5\nF\nFQDN and port number for N32-f connection\n18.0.0\n2022-09\nCT#97-e\nCP-222025\n0120\nF\n29.573 Rel-18 API version and External doc update\n18.0.0\n2022-12\nCT#98-e\nCP-223028\n0121\n1\nF\nMissing mandatory status codes in OpenAPI\n18.1.0\n2022-12\nCT#98-e\nCP-223033\n0123\nF\n29.573 Rel-18 API version and External doc update\n18.1.0\n2023-03\nCT#99\nCP-230083\n0125\n1\nA\nSource SNPN ID verification at the receiving SEPP\n18.2.0\n2023-03\nCT#99\nCP-230029\n0126\n2\nB\nRedirection support for N32-c\n18.2.0\n2023-03\nCT#99\nCP-230029\n0127\n1\nB\nEnable senderN32fFqdn and senderN32fPort when PRINS is selected\n18.2.0\n2023-03\nCT#99\nCP-230071\n0139\nF\n29.573 Rel-18 API version and External doc update\n18.2.0\n2023-06\nCT#100\nCP-231025\n0142\nF\nRemove the Editor Note for N32f FQDN\n18.3.0\n2023-06\nCT#100\nCP-231028\n0141\n1\nB\nN32-f port list for N32-f connection\n18.3.0\n2023-06\nCT#100\nCP-231029\n0140\n5\nF\nLocation header and missing Redirection clause\n18.3.0\n2023-06\nCT#100\nCP-231070\n0143\nF\n29.573 Rel-18 API version and External doc update\n18.3.0\n2023-09\nCT#101\nCP-232058\n0144\n3\nF\nMajor API version\n18.4.0\n2023-09\nCT#101\nCP-232058\n0145\nF\nRemove the Editor's Note on RedirectResponse\n18.4.0\n2023-12\nCT#102\nCP-233027\n0147\nF\nHTTP RFCs obsoleted by IETF RFC 9110 and 9113\n18.5.0\n2023-12\nCT#102\nCP-233056\n0149\n2\nB\nGeneral description on Support of Roaming Intermediaries\n18.5.0\n2023-12\nCT#102\nCP-233029\n0150\n2\nF\nSecurity capability negotiation procedures collision\n18.5.0\n2023-12\nCT#102\nCP-233028\n0151\nF\nN32-f interface with TLS security\n18.5.0\n2023-12\nCT#102\nCP-233029/ CP-233031\n0152\n5\nF\nN32-c context recovery\n18.5.0\n2023-12\nCT#102\nCP-233057\n0153\n3\nB\nN32-f related error determined upon receipt of an N32-f request\n18.5.0\n2023-12\nCT#102\nCP-233057\n0154\n2\nB\nN32-f related error determined upon receipt of an N32-f response\n18.5.0\n2023-12\nCT#102\nCP-233057\n0155\n2\nB\nApplicative (i.e. SBI related) error upon receipt of an N32-f request\n18.5.0\n2023-12\nCT#102\nCP-233057\n0156\n2\nB\nProcedures for Roaming Intermediary to reject N32 connection establishment\n18.5.0\n2023-12\nCT#102\nCP-233031\n0157\n1\nF\nProblemDetails RFC 7807 obsoleted by 9457\n18.5.0\n2023-12\nCT#102\nCP-233027\n0158\n1\nF\nN32-f context not found for TLS connection\n18.5.0\n2023-12\nCT#102\nCP-233028\n0159\n1\nF\nN32-f Context Termination Procedure collision\n18.5.0\n2023-12\nCT#102\nCP-233029\n0160\n1\nF\nParameter exchange procedure collision\n18.5.0\n2023-12\nCT#102\nCP-233030\n0161\n2\nF\nUpdate N32-f for TLS related sub-clauses\n18.5.0\n2023-12\nCT#102\nCP-233060\n0162\nF\n29.573 Rel-18 API version and External doc update\n18.5.0\n2024-03\nCT#103\nCP-240053\n0167\nF\nCorrect the reference number of IETF RFC 9110\n18.6.0\n2024-03\nCT#103\nCP-240053\n0178\nF\nEditorial and Style Corrections\n18.6.0\n2024-03\nCT#103\nCP-240053\n0174\n2\nB\nSupport the negotiation of security profiles\n18.6.0\n2024-03\nCT#103\nCP-240053\n0175\n2\nF\nClarification to the description of the queryfragment attribute\n18.6.0\n2024-03\nCT#103\nCP-240053\n0180\n2\nF\nProtection of Sensitive Information in Request Line\n18.6.0\n2024-03\nCT#103\nCP-240055\n0163\nB\nAddressing the limitations per TS 33.501\n18.6.0\n2024-03\nCT#103\nCP-240055\n0169\nF\nEditor Note's on handling of error delivery failure over N32-f\n18.6.0\n2024-03\nCT#103\nCP-240055\n0173\nB\nRouting the N32-c Error Reporting Request from the Roaming Intermediary\n18.6.0\n2024-03\nCT#103\nCP-240240\n0170\n2\nB\nN32-c connection establishment to support roaming intermediaries for 5GS roaming\n18.6.0\n2024-03\nCT#103\nCP-240055\n0171\n1\nB\nN32-c connection establishment rejection by Roaming Intermediaries\n18.6.0\n2024-03\nCT#103\nCP-240055\n0172\n1\nB\nN32-f message format for RI originated messages and related data types\n18.6.0\n2024-03\nCT#103\nCP-240055\n0179\n1\nB\nError Handling for Roaming Intermediary Generated N32-f Related Error Request\n18.6.0\n2024-03\nCT#103\nCP-240055\n0165\n2\nB\nApplicative request message originated by roaming intermediary over N32-f\n18.6.0\n2024-03\nCT#103\nCP-240056\n0181\nF\n29.573 Rel-18 API version and External doc update\n18.6.0\n2024-06\nCT#104\nCP-241028\n0187\nF\nABNF corrections\n18.7.0\n2024-06\nCT#104\nCP-241051\n0182\nF\nEN on handling the applicative errors for termination of session and deregistration of the UE by RI\n18.7.0\n2024-06\nCT#104\nCP-241051\n0183\n1\nF\nEN on the clash of the message ID created by the RI and any messages initiated by the c-SEPP\n18.7.0\n2024-06\nCT#104\nCP-241051\n0184\n4\nF\nN32-f connection and/or N32-f context termination initiated by Roaming Intermediary\n18.7.0\n2024-06\nCT#104\nCP-241051\n0186\n2\nF\nSupport of Modified PRINS in earlier releases\n18.7.0\n2024-06\nCT#104\nCP-241051\n0188\nF\nCorrecting the figure heading\n18.7.0\n2024-06\nCT#104\nCP-241051\n0189\nF\nCorrections on modificationsBlock\n18.7.0\n2024-06\nCT#104\nCP-241051\n0190\n1\nF\nModification on the definition of Roaming Hub\n18.7.0\n2024-06\nCT#104\nCP-241051\n0191\n1\nF\nReplacing IPX with Roaming Intermediary\n18.7.0\n2024-06\nCT#104\nCP-241051\n0192\n1\nF\nClarification on the usage of N32-f message ID\n18.7.0\n2024-06\nCT#104\nCP-241050\n0194\nF\nFeature negotiation correction\n18.7.0\n2024-06\nCT#104\nCP-241050\n0195\n1\nF\nReplacing Roaming Intermediary with RI\n18.7.0\n2024-06\nCT#104\nCP-241050\n0196\n1\nF\nDescription of N32Purpose, ProblemDetailsMsgForwarding and AdditionInfoMsgForwarding\n18.7.0\n2024-06\nCT#104\nCP-241050\n0197\n4\nF\nN32-c and N32-f Correlation\n18.7.0\n2024-06\nCT#104\nCP-241041\n0199\n3\nB\nExchanging data or analytics between PLMNs\n18.7.0\n2024-06\nCT#104\nCP-241050\n0202\nF\nCorrect table references\n18.7.0\n2024-06\nCT#104\nCP-241052\n0204\nF\n29.573 Rel-18 API version and External doc update\n18.7.0\n2024-09\nCT#105\nCP-242039\n0206\n2\nF\nIndication on support of senderN32fFqdn and senderN32fPortList/senderN32fport\n18.8.0\n2024-09\nCT#105\nCP-242039\n0208\n2\nF\nHTTP redirection for multiple SEPPs per PLMN\n18.8.0\n2024-09\nCT#105\nCP-242053\n0210\n1\nF\nProtection policy for recursive non-leaf IE\n18.8.0\n2024-09\nCT#105\nCP-242054\n0214\nF\n29.573 Rel-18 API version and External doc update\n18.8.0\n2024-12\nCT#106\nCP-243023\n0207\n3\nF\nAutonomous correlation of N32-c and N32-f\n18.9.0\n2024-12\nCT#106\nCP-243023\n0217\n2\nF\nKeepalive of TLS Session for N32-f\n18.9.0\n2024-12\nCT#106\nCP-243068\n0223\nF\n29.573 Rel18 API version and External doc update\n18.9.0\n2024-12\nCT#107\nCP-250023\n0225\nF\nCorrection on Encrypted Block Locations in SEPP Service Description\n18.10.0",
      "chunk_type": "general",
      "cross_references": [
        "ts_29.501_clause_5.3.1",
        "ts_29.501_clause_5",
        "ts_29.501_clause_4.4",
        "ts_29.500_clause_6.1.4.3",
        "clause_5.2.2",
        "ts_23.003_clause_28.5.2",
        "ts_29.501_clause_4.3.1.6",
        "clause_7.3",
        "clause_5.1",
        "clause_18.3.0",
        "table_7.4.2-1",
        "table_16.3.0",
        "table_17.4.0",
        "ts_29.501",
        "ts_21.900",
        "ts_29.573",
        "ts_29.500",
        "ts_33.501",
        "ts_23.003",
        "ts_16.0"
      ]
    }
  ]
}