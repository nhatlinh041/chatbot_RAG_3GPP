{
  "metadata": {
    "specification_id": "ts_23.057",
    "version": "18.0.0",
    "title": "3GPP TS 23.057",
    "file_path": "/content/drive/MyDrive/RAG_thesis/data/23_series/23057-i00/23057-i00.docx"
  },
  "export_info": {
    "export_date": "2025-07-26T09:42:40.073343",
    "total_chunks": 145
  },
  "chunks": [
    {
      "chunk_id": "ts_23.057_1",
      "section_id": "1",
      "section_title": "Scope",
      "content": "The present document defines the stage 2 and stage 3 description of the Mobile Execution Environment (MExE). Stage 2 identifies the functional capabilities and information flows needed to support the service described in stage 1.\nThe present document includes information applicable to network operators, service providers and terminal, switch and database manufacturers.\nThe present document contains the core functions for a Mobile Execution Environment (MExE) which are sufficient to provide a complete service.\nMExE uses a number of technologies to realise the requirements of the stage 1 description (TS 22.057 [2]). The present document describes how the service requirements are realised with the selected technologies. The TS is devised into clauses each covering the aspects relating to particular MExE technologies, it is intended that this specification will evolve along with the MExE technologies. A generic clause of the specification covers areas of MExE common to all technologies.\nImplementation of this specification outside the UE (User Equipment) is outside the scope of this specification.",
      "chunk_type": "general",
      "cross_references": [
        "ts_22.057"
      ]
    },
    {
      "chunk_id": "ts_23.057_2",
      "section_id": "2",
      "section_title": "References",
      "content": "-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non‑specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\tVoid.\n[2]\t3GPP TS 22.057: \"Mobile Execution Environment (MExE); Stage 1\".\n[3]\tPersonal Java 1.1.1 or higher: Sun Microsystems http://www.javasoft.com/products/personaljava/.\n[4]\tJavaPhone API version 1.0: http://java.sun.com/products/javaphone/.\n[5]\tVoid.\n[6]\tWireless Application Protocol (WAP) June 2000 Conformance Release: http://www.wapforum.org.\n[7]\tVoid.\n[8]\tVoid.\n[9]\tIETF RFC 2616:Hypertext Transfer Protocol - HTTP/1.1: http://www.w3.org/Protocols/rfc2616/rfc2616.\n[10]\tVoid.\n[11]\t3GPP TR 22.170: \"Universal Mobile Telecommunications System (UMTS); Service aspects; Provision of Services in UMTS - The Virtual Home Environment\".\n[12]\t3GPP TS 22.121: \"The Virtual Home Environment; Stage 1\".\n[13]\tVoid.\n[14]\t3GPP TS 22.101: \"Service Aspects; Service Principles\".\n[15]\tCC/PP Exchange Protocol based on HTTP Extension Framework; W3C http://www.w3.org/Mobile/CCPP.\n[16]\tComposite Capability/Preference Profiles (CC/PP): A user side framework for content negotiation:  http://www.w3.org/Mobile/CCPP.\n[17]\tUAProf Specification: http://www.wapforum.org/what/technical.htm.\n[18]\tJDK 1.1 security: http://www.javasoft.com/products/jdk/1.1/docs/guide/security/index.html.\n[19]\tJava 2 security: http://www.javasoft.com/products/jdk/1.2/docs/guide/security/index.html.\n[20]\tJava security tutorial: http://java.sun.com/docs/books/tutorial/security1.2/overview/index.html.\n[21]\tOCF 1.1: \"Smartcard API specified by OpenCard Consortium http://www.opencard.org.\n[22]\tRFC 1738: \"Uniform Resource Locators (URL)\" http://www.w3.org/pub/WWW/Addressing/rfc1738.txt.\n[23]\tThe MD5 Message Digest Algorithm\", Rivest, R., RFC 1321, April 1992.  URL: ftp://ftp.isi.edu/in-notes/rfc1321.txt.\n[24]\tISO/IEC 10118-3 (1996): \"Information technology - Security techniques - Hash-functions - Part 3: Dedicated hash-functions\".\n[25]\tIETF RFC 2368: \"The mailto URL scheme\".\n[26]\tITU-T Recommendation X.509: \"Information technology - Open Systems Interconnection - The Directory: Public-key and attribute certificate frameworks\".\n[27]\t3GPP TS 51.011: \"Specification of the Subscriber Identity Module - Mobile Equipment (SIM - ME) interface\".\n[28]\t3GPP TS 23.107: \"QoS Concept and Architecture\".\n[29]\t3GPP TS 24.007: \"Mobile radio interface signalling layer 3; General Aspects\".\n[30]\t3GPP TS 24.008: \"Mobile radio interface layer 3 specification, Core Network Protocols; Stage 3\".\n[31]\t3GPP TS 23.060: \"General Packet Radio Service (GPRS); Service Description; Stage 2\".\n[32]\tPKCS #15: \"Cryptographic Token Information Syntax Standard\" version 1.1, RSA Laboratories, June 2000URL: ftp://ftp.rsa.com/pub/pkcs/pkcs-15/pkcs-15v1_1.doc.\n[33]\tRFC 2510 (1999): \"Internet X.509 Public Key Infrastructure Certificate Management Protocols\".\n[34]\tConnected Limited Device configuration, J2ME version 1.0: http://java.sun.com/j2me/docs/.\n[35]\tMobile Information Device Profile, J2ME version 1.0: http://java.sun.com/j2me/docs/.\n[36]\teXtensible Markup Language (XML) 1.0: W3C Recommendation. http://www.w3.org/XML.\n[37]\tResource Definition Framework (RDF) Model and Syntax:W3C Recommendation. http://www.w3.org/RDF.\n[38]\tUML Partners: Unified Modelling Language: http://www.omg.org.\n[39]\t3GPP TS 31.102: \"Characteristics of the USIM applications\".\n[40]\tRFC 2396 (1998): \"Uniform Resource Identifiers (URI): Generic Syntax\". T. Berners-Lee, R. Fielding, L. Masinter.\n[41]\tRFC 2616 (1999): \"Hypertext Transfer Protocol -- HTTP/1.1\". R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, T. Berners-Lee.\n[42]\tDescription of the \"JAR Manifest\" file encoding, Sun Microsystems. URL: http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html.\n[43]\tRFC 2459 (1999): \"Internet X.509 Public Key Infrastructure Certificate and CRL Profile\". R. Housley, W. Ford, W. Polk, D. Solo.\n[44]\t3GPP TR 21.905: Vocabulary for 3GPP Specifications.\n[45]\tWAP Binary XML Content Format Specification (WBXML): http://www.wapforum.org/what/technical.htm.\n[46]\tRFC 1766: \"Tags for the Identification of Languages\".\n[47]\tWAP Certificate and CRL Profiles: WAP-211-WAPCert http://www.wapforum.org/what/technical.htm.\n[48]\t3GPP TS 23.227: \"Applications and User interaction in the UE-Principles and specific requirements\".\n[49]\tPKCS#1 \"RSA Cryptographic Standard\"  version 2.0: RSA Laboratories, October 1998 http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/index.html.\n[50]\tCommon Language Infrastructure: ECMA specification ECMA-335, http://www.ecma.ch/ecma1/STAND/ecma-335.htm.\n[51]\tSimple Object Access Protocol version 1.1, (SOAP): http://www.w3.org/TR/2000/NOTE-SOAP-20000508/.\n[52]\tPKCS#7 \"Cryptographic Message Syntax Standard\" version 1.5: RSA Laboratories, November 1993 http://www.rsasecurity.com/rsalabs/pkcs/pkcs-7/index.html.\n[53]\t3GPP TS 23.040: \"Technical realization of the Short Message Service (SMS)\".",
      "chunk_type": "general",
      "cross_references": [
        "ts_22.057",
        "ts_22.170",
        "ts_22.121",
        "ts_22.101",
        "ts_51.011",
        "ts_23.107",
        "ts_24.007",
        "ts_24.008",
        "ts_23.060",
        "ts_31.102",
        "ts_21.905",
        "ts_23.227",
        "ts_23.040"
      ]
    },
    {
      "chunk_id": "ts_23.057_3.1",
      "section_id": "3.1",
      "section_title": "Definitions",
      "content": "For the purposes of the present document, the following terms and definitions apply:\nadministrator: administrator of the MExE device is the entity that has the control of the third party trusted domain, and all resources associated with the domain\nNOTE 1:\tThe administrator of the MExE device could be the user, the operator, the manufacturer, the service provider, or a third party as designated by the owner of the MExE device.\nbest effort QoS (Quality of Service): best effort QoS refers to the lowest of all QoS traffic classes\nNOTE 2:\tIf the guaranteed QoS cannot be delivered, the bearer network delivers the QoS which can also be called best effort QoS, TS 23.107 [28].\ncertificate: entity that contains the issuer's public key, identification of the issuer, identification of the signer, and possibly other relevant information\nNOTE 3:\tAlso, a certificate contains a signed hash of the contents. The signer can be a 3rd. party other than the issuer.\ndelivered QoS: actual QoS parameter values with which the content was delivered over the lifetime of a QoS session, TS 23.107 [28].\nEnd Entity: user of PKI certificates and/or end user system that is the subject of a certificate.\nfine grain: refers to the capabilities of the Java security system to allow applications, sections of code or Java classes to be assigned permissions to perform a specific set of privileged operations\nNOTE 4:\tThe smallest programming element that can be given permission attributes is a Java class [19].\nkey pair: key pairs are matching private and public keys\nNOTE 5:\tIf a block of data is encrypted using the private key, the public key from the pair can be used to decrypt it. The private key is never divulged to any other party, but the public key is available, e.g. in a certificate.\nOperator: term operator as used in this specification refers to the term Home Environment, defined as \"Home Environment: The home environment is responsible for enabling a user to obtain UMTS services in a consistent manner regardless of the user's location or terminal used (within the limitations of the serving network and current terminal)\" in TR 21.905 [44].\nnegotiated QoS: response to a QoS request, the network shall negotiate each QoS attribute to a level that is in accordance with the available network resources\nNOTE 6:\tAfter QoS negotiation, the bearer network shall always attempt to provide adequate resources to support all of the negotiated QoS profiles, TS 23.060 [31].\npersonal certificate: certificate loaded by the user or a user application which is limited to the application that it is intended for, and is not a MExE Certificate\nNOTE 7:\tE.g. an e-mail application could load certificates for its usage. Personal certificates are out of scope for MExE.\nphonebook: dataset of personal or entity attributes\nNOTE 8:\tThe simplest form is a set of name-number pairs as defined by GSM SIMs. A phonebook may also be supported on a (U)SIM.\nMobile Execution Environment (MExE): is defined in detail in the present document, but the scope of MExE does not include the operating system, or the manufacturer's execution environment\nMExE API: consists of interfaces present in the MExE device and exposed to MExE executables\nNOTE 9:\tThe APIs which are outside of the scope of this specification, are not part of MExE API.\nMExE certificate: used in the realisation of MExE security domains\nNOTE 10:\tA MExE Certificate can be used to verify downloaded MExE executables. Use of the word \"certificate\" in this document implies a MExE certificate. Other varieties of certificate will be explicitly qualified as a e.g. \"Personal Certificate\".\nMExE device: UE (User Equipment) that supports MExE functionality in the ME (Mobile Equipment)\nNOTE 11:\tThe implementation of MExE shall be in the same physical device as the MT (Mobile Termination). Implementation of MExE functionality in the TE (Terminal Equipment) outside of the physical device containing the MT (Mobile Termination) is for further study.\nMExE executable: is one or more applet, application, or content, which conforms to the MExE specification and may execute on any MExE device, conforming to the appropriate classmark\nMExE Java VM: this is a standard Java virtual machine used to execute MExE Java applets and applications\nMExE native library: this is a downloaded native library that can be accessed by MExE executables\nMExE Server: node supporting MExE services in the MExE service environment\nNOTE 12:\tThe MExE server may be a web or WAP server providing services for users to download MExE executables. MExE server is not necessarily a special network element but may utilize the normal Internet service environment.\nMExE-(U)SIM: (U)SIM that is capable of storing a security certificate that is accessible using standard mechanisms\nMIDP application: MIDP application, or \"MIDlet\", is one that uses only the APIs defined by the MIDP and CLDC specifications.\nMIDlet suite: collection of MIDP Applications, or MIDlets packaged together and share resources within the context of a single Java Virtual Machine\nowner: owner of the MExE device\nNOTE 13:\tAn owner could be a user, operator (e.g. where the MExE device is obtained as part of a subscription and the cost of the MExE device is subsidised), service provider, or a third party (e.g. the MExE device is owned by the user's company and this company wishes to control how the MExE device is used)\npower up event: abstract event that occurs when the MExE device is cold started (i.e. switched on)\nQoS session: Lifetime of PDP context, the period between the opening and closing of a network connection whose characteristics are defined by a QoS profile\nNOTE 14:\tMultiple QoS sessions may exist, each with a different QoS profile, TS 23.107 [28].\nQoS profile: comprises of a number of QoS parameters\nNOTE 15:\tA QoS profile is associated with each QoS session.  The QoS profile defines the performance expectations placed on the bearer network, TS 23.107 [28].\nrequested QoS: QoS profile is requested at the beginning of a QoS session\nNOTE 16:\tQoS modification requests are also possible during the lifetime of a QoS session, TS 23.107 [28] and TS 23.060 [31].\nsandbox: sandbox is a safe area to run Java code. Untrusted Java code executing in a sandbox has access to only certain resources, JDK 1.1 security [18].\nservice: service (which may consist of an application or applet, and its related content) is a set of functions offered to a user by an organisation, and may be performed on the MExE device and/or remotely\nservice name: identifier associated with a service, which could be a string, a fully qualified Java class name, a unique URI or other identifier\nsession: period between the launching of a MExE executable and its execution termination\nNOTE 17:\tA WAP-session is established between the mobile and the WAP Gateway. The duration of a WAP-session can range from a second to years. The WAP-session can be associated with a particular subscription in the WAP Gateway.\nsignature: \"Signing\" is the process of encrypting a hash of the data using a private key\nNOTE 18:\tIf the signature can be decrypted using the public key, then the signature is valid.\nsigned JAR file: archives of Java classes or data that contain signatures that also include a way to identify the signer in the manifest [42] (the Manifest contains a file which has attributes defined in it)\nsubscribed QoS: network will not grant a QoS greater than that subscribed\nNOTE 19:\tThe QoS profile subscription parameters are held in the HLR.  An end user may have several QoS subscriptions. For security and the prevention of damage to the network, the end user cannot directly modify the QoS subscription profile data, TS 23.060 [31].\nuser: user of the MExE device\nvalid (U)SIM application: identification by the MExE ME that a valid SIM card, or USIM application on the UICC, has been detected (e.g. through insertion of (U)SIM card, power up of MExE device etc.)\nNOTE 20:\tWhenever this specification refers to valid (U)SIM, it implies a valid SIM card or USIM application on the UICC.\nFurther definitions specific to MExE are given in TS 22.057 [2].",
      "chunk_type": "definition",
      "cross_references": [
        "ts_23.107",
        "ts_21.905",
        "ts_23.060",
        "ts_22.057"
      ]
    },
    {
      "chunk_id": "ts_23.057_3.2",
      "section_id": "3.2",
      "section_title": "Abbreviations",
      "content": "For the purposes of the present document the following abbreviations apply:\nAA\tAttribute Authority\nAPI\tApplication Programming Interface\nAPDU\tApplication protocol data unit\nARPK\tAdministrator Root Public Key\nCA\tCertification Authority\nCC/PP\tComposite Capability/Preference Profiles\nCGI\tCommon Gateway Interface\nCCM\tCertificate Configuration Message\nCLDC\tConnected Limited Device Configuration\nCLI\tCommon Language Infrastructure\nCP-Admin\tCertificate Present (in the MExE (U)SIM) - Administrator\nCP-TP\tCertificate Present (in the MExE (U)SIM) - Third Party\nCRL\tCertificate Revocation List\nDiff-serv\tDifferentiated Services\nDTMF\tDual Tone Multiple Frequency\nGSM\tGlobal System for Mobile Communication\nGPRS\tGeneral Packet Radio Service\nHTTP\tHyperText Transfer Protocol\nHTTPS\tHyperText Transport Protocol Secure (https is http/1.1 over SSL, i.e. port 443)\nIETF\tInternet Engineering Task Force\nIP\tInternet Protocol\nISDN\tIntegrated Services Digital Network\nJAD\tJava Application Descriptor\nJ2ME\tJava 2 Micro Edition\nJ2SE\tJava 2 Standard Edition\nJTAPI\tJava Telephony Application Programming Interface\nJAR file\tJava Archive File\nME\tMobile Equipment\nMIDP\tMobile Information Device Profile\nMIDlet\tMIDP Application\nMMI\tMan-Machine Interface\nMRPK\tManufacturer Root Public Key\nMSE\tMExE Service Environment\nMSISDN\tMobile Subscriber ISDN Number\nMT\tMobile Termination\nOCF\tOpenCard Framework\nOEM\tOriginal Equipment Manufacturer\nOCSP\tOnline Certificate Status Protocol\nORPK\tOperator Root Public Key\nQoS\tQuality of Service\nPDP\tPacket Data Protocol\nPKI\tPublic Key Infrastructure\nRDF\tResource Description Format\nRFC\tRequest For Comments\nRPK\tRoot Public Key\nSCVP\tSimple Certificate Verification Protocol\nSIM\tSubscriber Identity Module\nSMS\tShort Message Service\nSOAP\tSimple Object Access Protocol\nSSL\tSecure Socket Layer\nTE\tTerminal Equipment\nTLS\tTransport Layer Security\nTP\tThird Party\nUDP\tUser Datagram Protocol\nUE\tUser Equipment\nUI\tUser Interface\nUMTS\tUniversal Mobile Telecommunications System\nURL\tUniform Resource Locator\nURI\tUniform Resource Identifier\nUSIM\tUniversal Subscriber Identity Module\nUSSD\tUnstructured Supplementary Service Data\nVM\tVirtual Machine\nWAE\tWireless Application Environment\nWAP\tWireless Application Protocol\nWBXML\tWAP Binary XML\nWDP\tWireless Datagram Protocol\nWMLS\tWireless Markup Language Script\nWSP\tWireless Session Protocol\nWTA\tWireless Telephony Applications\nWTAI\tWireless Telephony Applications Interface\nWTLS\tWireless Transport Layer Security\nWTP\tWireless Transaction Protocol\nWWW\tWorld Wide Web\nXML\tExtensible Markup Language\nFurther abbreviations are given in TS 22.057 [2] and TR 21.905 [44].",
      "chunk_type": "general",
      "cross_references": [
        "ts_22.057",
        "ts_21.905"
      ]
    },
    {
      "chunk_id": "ts_23.057_4.1",
      "section_id": "4.1",
      "section_title": "Generic MExE aspects",
      "content": "Support of at least one MExE classmark is mandatory. A MExE device may also include optional support for applications from any other MExE classmark (refer to clause 4.3 \"Multiple Classmark support\").\nThis clause defines the common aspects of all MExE compliant devices, independent of MExE technology.\nConsidering the wide and diverse range of current and future technology and devices that (will) use wireless communication and provide services based thereon a one-size-fits-all approach is unrealistic. Instead the present document categorises devices by giving them different MExE classmarks. In this specification the following MExE classmarks are defined:\n-\tMExE classmark 1 - based on WAP (Wireless Application Protocol) [6] - requires limited input and output facilities (e.g. as simple as a 3 lines by 15 characters display and a numeric keypad) on the client side, and is designed to provide quick and cheap information access even over narrow and slow data connections.\n-\tMExE classmark 2 - based on PersonalJava [3] - provides and utilises a run-time system requiring more processing, storage, display and network resources, but supports more powerful applications and more flexible MMIs.\n-\tMExE classmark 3 - based on J2ME CLDC and MIDP environment [34] and [35] - supports Java applications running on resource-constrained devices.\n-\tMExE classmark 4 - based on Common Language Infrastructure [50] Compact Profile - supports CLI based applications running on a broad range of connected devices.\nContent negotiation allows for flexible choice of formats available from a server or adaptation of a service to the actual classmark of a specific client device.\nBi-directional capability negotiation between the MExE Service Environment and MExE device (including MExE classmark), supports the transfer of capabilities between the client and the server.",
      "chunk_type": "general",
      "cross_references": [
        "clause_4.3"
      ]
    },
    {
      "chunk_id": "ts_23.057_4.2",
      "section_id": "4.2",
      "section_title": "High level architecture",
      "content": "The following architectural model shows an example of how standardised transport mechanisms are used to transfer MExE services between the MExE device and the MExE service environment, or to support the interaction between two MExE devices executing a MExE service.\nThe MExE service environment could, as shown in figure 1 \"Generic MExE architecture\", consist of several service nodes each providing MExE services that can be transferred to the MExE device using mechanisms such as (but not limited to) fixed/mobile/cordless network protocols, Bluetooth, infrared, serial links, wireless optimised protocols, standard Internet protocols. These service nodes may exist in the circuit switched domain, packet switched domain, IP multimedia core network subsystem or in the internet space (e.g. SMS service centres, multimedia messaging servers, internet servers etc.). The MExE service environment may also include a proxy server to translate content defined in standard Internet protocols into their wireless optimised derivatives.\nFor the versatile support of MExE services, the wireless network shall provide the MExE device with access to a range of bearer services on the radio interface to support application control and transfer from the MExE service environment. As MExE also applies to fixed and cordless environments, MExE device may also access MExE services via non‑wireless access mechanisms.\nFigure 1: Generic MExE architecture",
      "chunk_type": "general",
      "cross_references": [
        "figure_1"
      ]
    },
    {
      "chunk_id": "ts_23.057_4.3",
      "section_id": "4.3",
      "section_title": "Multiple classmark support",
      "content": "Support of multiple MExE classmarks on a MExE device is optional.\nA given MExE Classmark identifies support by a MExE device for a defined level of MExE functionality as defined by that classmark. Support of MExE classmarks by a MExE device shall enable flexible support of MExE functionality.  A MExE device may support any multiple combinations of MExE classmarks.\nThe support of any other functionality by a MExE device is also possible, and is out of scope of this specification.\nNOTE:\tSome implementation issues may arise from the multiple support of classmarks on a device, e.g.:\n1)\tIn conforming to all of the requirements, how are mandatory requirements in one classmark compatible with optional requirements for another?\n2)\tWith KJava and pJava on one device, MIDP can be on top of  a JavaVM. Which of the classmarks will it be then? In conforming with both Classmark 2 and 3 requirements, are 2 VMs required in one device?",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_4.3.1",
      "section_id": "4.3.1",
      "section_title": "Classmark 1 service support in non-Classmark 1 MExE devices",
      "content": "Support of Classmark 1 executables in non-classmark 1 MExE devices is optional.\nTo allow access to services designed for MExE Classmark 1 devices, MExE devices other than Classmark 1 will need to support full or a subset of WAP protocol as identified below. Due to the fast evolution of new technologies, support of WAP in Classmarks other than Classmark 1 is not mandated by MExE specification.  However WAP is a possibility for the integrity of service provisioning as well as quick access to information by feature rich devices (e.g. Java devices).\nIf Classmark 1 services are supported by non-Classmark 1 devices, Classmark 1 services shall execute in the same manner as they execute in a MExE Classmark 1 device.  For that purpose, a MExE non-Classmark 1 device shall comply with data profile class (Class C) of WAP Class Conformance Requirement Specification [6].\nNOTE:\tA more specific reference to the WAP Class Conformance Requirement Specification shall be supplied when available.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_4.3.2",
      "section_id": "4.3.2",
      "section_title": "Classmark 2 service support in non-Classmark 2 MExE devices",
      "content": "Support of Classmark 2 executables in non-classmark 2 MExE devices is optional.\nIf Classmark 2 services are supported by non-Classmark 2 devices, Classmark 2 services shall execute in the same manner as they execute in a MExE Classmark 2 device.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_4.3.3",
      "section_id": "4.3.3",
      "section_title": "Classmark 3 service support in non-Classmark 3 MExE devices",
      "content": "Support of Classmark 3 executables in non-classmark 3 MExE devices is optional.\nIf Classmark 3 services are supported by non-Classmark 3 devices, Classmark 3 services shall execute in the same manner as they execute in a MExE Classmark 3 device.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_4.3.4",
      "section_id": "4.3.4",
      "section_title": "Classmark 4 service support in non-Classmark 4 MExE devices",
      "content": "Support of Classmark 4 executables in non-classmark 4 MExE devices is optional. If Classmark 4 services are supported by non-Classmark 4 devices, Classmark 4 services shall execute in the same manner as they execute in a MExE Classmark 4 device.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.1",
      "section_id": "5.1",
      "section_title": "User profile",
      "content": "Support of the user profile is optional.\nNOTE:\tThe user profile is not yet specified in an interoperable way. Support of the user profile will be defined when it has been fully specified in a fully interoperable way.\nThe user profile (which may consist of sub user profiles for a user) contains the characterisation of the MExE device as defined by the user and service provider. Further, it is also possible for multiple users of a MExE device to each have their own user profiles. The user profile is not unique to the MExE device, and this clause identifies the usage and content of the user profile from a MExE perspective only, and does not identify the generic support of user profiles in general. Refer to TS 22.101 [14] for further details on the user profile.",
      "chunk_type": "general",
      "cross_references": [
        "ts_22.101"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.1.1",
      "section_id": "5.1.1",
      "section_title": "Location of, access to, and security of, the user profile",
      "content": "As multiple user profiles may be defined, the user is able to set up or receive calls/connections associated with different user profiles simultaneously by securely activating a user profile (with each user profile being associated with at least one unique identifier). Refer to table 5 \"Security domains and actions\" in the Security clause 6.3 \"MExE executable permissions\" for further details on user profile activation.\nThe user's characterisation of the MExE device in the user profile may be modified at any time by the user and the service provider, and changes affected at the earliest possible opportunity.\nThe security clause shall apply to all user profiles at all times, whether activated or not\nThe user profile shall be securely managed by the MExE device, and stored in a secure area of the MExE device (either (U)SIM or ME). The service provider may also retain the user profile in the network for service optimisation. User private data in the user profile may also be stored in the network, however only with the user permission.\nThe support of more than one user profile is not mandatory.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.3",
        "table_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.1.2",
      "section_id": "5.1.2",
      "section_title": "Support of the user profile",
      "content": "The user profile acts as a repository (which is always available in the MExE device) defining the MExE device behaviour.\nMExE preferences and personalisation are supported in the user profile (e.g. UMTS portability and support of VHE defined in TS 22.121 [12] and other 22-series specifications), which in turn is based on the Composite Capability/Preference Profile (CC/PP) specification from W3C [16].\nMExE preferences and personalisation may not only be recorded directly in the user profile as supported by CC/PP (the direct referencing mechanism), but may also be retrieved from a URL (the indirect referencing mechanism) [22].\nGenerally, the user profile's CC/PP framework provides the mechanism for the standardised format of preferences, and its use of Resource Description Framework (RDF) permits the interoperable encoding of MExE preferences and personalisation. Future extensions will be supported by the W3C mechanism, allowing for evolution and development of MExE preferences and personalisation.\nThe set of preferences which are supported in the user profile consists of the following:\n-\tuser interface personalisation;\n-\tthe user's personalisation of the user interface;\n-\tservice personalisation and management;\n-\tthe user's generic service management information.\nThe coding and presentation of the above characteristics in the user profile is defined by the Composite Capability/Preference Profile (CC/PP) specification from W3C [16], and referenced by the MExE capability negotiation in clause 5.2 \"Capability and content negotiation\".\nThe following user preference information is supported by UAProf [17]. A MExE device shall support the following property in table 1 \"Mandatory UAProf properties\" of the UAProf schema for user preference information.\nTable 1: Mandatory UAProf properties\nAttribute\nDescription\nResolutionRule\nType\nSample Values\nAcceptDownloadableSoftware\nIndicates the user's preference on whether to accept downloadable software\nLocked\nBoolean\n\"Yes\", \"No\"\nIt is recommended that a MExE device supports the following UAProf properties in table 2 \"Recommended UAProf properties\":\nTable 2: Recommended UAProf properties\nAttribute\nDescription\nResolutionRule\nType\nSample\nCcppAccept-Language\nUser's preference for document language. Property value is a list of natural languages, where each item in the list is the name of a language as defined by RFC 1766 [46].\nAppend\nLiteral (Bag)\n\"zh-CN\", \"en fr\"\nPreferenceForFrames\nUser's preference for displaying frames\nLocked\nBoolean\n\"Yes\", \"No\"\nWapPushMsgPriority\nUser's settings for WAP Push message priorities\nLocked\nLiteral\n\"critical\", \"low\", \"none\"\nAlso, there is in UAProf [17] support for indicating MExE device's capabilities related to UI features, e.g. capability for displaying images or frames, as well as capability information about input and output methods.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2",
        "table_1",
        "table_2",
        "ts_22.121"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.1.3",
      "section_id": "5.1.3",
      "section_title": "User interface personalisation",
      "content": "Support of user interface personalisation as detailed in this clause is optional.\nThe MExE device interface consists of the buttons, menus, screens and MMI as designed and provided by the MExE device manufacturer; the nature of this MExE device interface is naturally evolving, MExE device specific and proprietary to the individual manufacturers of the industry. This interface is the one normally seen by the user in normal operation of his MExE device. This specification does not place any requirements or limitations on the individual manufacturers' MExE device interface.\nThe MExE MMI, in turn, is the interface available to the user to support MExE services and functionality on the MExE device. The nature of the MExE MMI interface, like the normal MExE device interface described above, is not standardised in any way, to allow for manufacturer innovation, cater for evolving market needs, and permit manufacturer differentiation. The MExE MMI, depending on different manufacturer implementations, may consist of the normal MExE device interface, the normal MExE device interface with modifications, a different interface to the normal MExE device interface, or some combinations thereof etc. MExE services operate within, and using the capabilities of, the MExE MMI.\nUser interface personalisation consists of two parts. The first part refers to the user's ability to request, and verify, the preferred changes to the user interface; thus the user's preferences, as supported by the specific MExE device, require to be recorded. The second part refers to the MExE device's support of the user's preferences for the interface, within the capabilities of an MExE device. By defining the user interface personalisation to consist of two stages, the preferences which have been recorded by the user may be transferred (as part of the user profile, e.g. CcppAccept-Language and/or PreferenceForFrames), and thereby provide portability of the user's preferences.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.1.3.1",
      "section_id": "5.1.3.1",
      "section_title": "MExE user interface personalisation",
      "content": "Personalisation of the user interface offers the MExE Service Environment and or the user, the ability to inform the MExE device of the desired extent of personalisation. All support of the user interface personalisation is optional, not mandatory on any class of MExE device, and subject to the capabilities of the MExE device. Depending on the capability of the MExE device, the personalisation may be fully supported, partially supported, interpreted or ignored.\nPersonalisation of the user interface is not restricted to modifying the appearance of the MMI, but also the modification of MMI parameters (e.g. programming of the voicemail number). The user's personalisation of the interface is retained as part of the user profile.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.1.3.2",
      "section_id": "5.1.3.2",
      "section_title": "Support of MExE user interface personalisation",
      "content": "MExE user interface personalisation is supported via the preferences in the user profile, which in turn is based on the Composite Capability/Preference Profile (CC/PP) specification from W3C [16].\nUser interface personalisation may not only be reported in the CC/PP request to the server (the direct referencing mechanism), but indeed the client may point to a URL (the indirect referencing mechanism) from where the user interface personalisation preferences may be retrieved.\nGenerally, the user profile's CC/PP framework provides the mechanism for the standardised format of preferences, and its use of Resource Description Framework (RDF) permits the interoperable encoding of user interface personalisation. Future extensions will be supported by the W3C mechanism, allowing for evolution and development of MExE user interface personalisation.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.1.4",
      "section_id": "5.1.4",
      "section_title": "Virtual home environment",
      "content": "Virtual Home Environment (VHE) (see TR 22.170 [11] and TS 22.121 [12]) is defined as a concept for personalised service portability across network boundaries and between terminals. MExE is identified by VHE as one of the mechanisms which may be used to support VHE.\nThe characteristics of the VHE (to reflect any user or home environment modification of the user's VHE) shall be stored as part of the user profile.",
      "chunk_type": "general",
      "cross_references": [
        "ts_22.170",
        "ts_22.121"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.2",
      "section_id": "5.2",
      "section_title": "Capability and content negotiation",
      "content": "Support of capability negotiation for all MExE devices is mandatory, while support of content negotiation is optional.\nInteraction between the MExE device and the MSE for WWW/WAP browsing and service discovery shall be supported by the use of the hypertext transfer protocol HTTP/1.1 [9], or an HTTP/1.1 derived protocol (e.g. WSP as defined in Wireless Application Protocol [6]). Communication between the MExE device and the MSE supports:\n-\tCapability negotiation\nThe MExE device connects to the MSE by using HTTP/1.1 or an HTTP/1.1 derived protocol.  Capability negotiation between the MExE device and the MSE only takes place for the first time after the MExE device has connected to the MSE, and the MSE is informed about the MExE device.  Without this first initial contact from the MExE device, the MSE has no knowledge of the MExE device. After the first initial contact the MSE may connect to the MExE device by using HTTP/1.1 or an HTTP/1.1 derived protocol.\nCapability negotiation represents the mechanism by which the MExE device and the MSE interact to inform each other of the specific mechanisms, capabilities and support which each is able to provide or support within the scope of a MExE service interaction.  The capability negotiation normally takes place prior to any content transfer between the two entities.\nCapability negotiation is used by the MExE device to inform the MSE of its capabilities.  The MExE device may be informed by the MSE of its use of the MExE device's capabilities.  The MExE device may also spontaneously inform the MSE of its capabilities (i.e. following a change in MExE support, such as removal of MExE device from a docking station with its keyboard, mouse and monitor).  A subset of characteristics which may be transferred between the MExE device and the MSE during the capability negotiation are identified in clause 5.2.1 \"Capability negotiation characteristics\".\n-\tContent negotiation\nContent negotiation represents the means by which the MExE device and the MSE inform each other of the requested and available form of content. If needed, the content negotiation may take place following capability negotiation between the two. The methods for content negotiation are the basic HTTP/1.1. or WSP methods explained in [9] and [6].\nContent negotiation is used to select the best representation of an entity when there are multiple representations of the entity available from the MSE.  The entity (e.g. a service, an image, etc) is located behind a URI, and the application in the MExE device connects to the URI by using HTTP/1.1 or an HTTP/1.1 derived protocol. The best representation of an entity can be decided by the server (server-driven negotiation) or by the client application (agent-driven negotiation).\nBoth the capability and the content negotiation has the same purpose: to optimise the content according to client's capabilities. The term \"content negotiation\" has been used e.g. in the HTTP specification and the HTTP/1.1. and the WSP contain headers to perform the content negotiation. However, the capability negotiation in MExE aims at extending the basic HTTP and WSP methods for content negotiation by using CC/PP framework.\nThe content negotiation transferred between the MExE device and the MSE is identified in clause 5.2.3 \"Client content capability report\" onwards.",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.2.1",
        "clause_5.2.3"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.2.1",
      "section_id": "5.2.1",
      "section_title": "User profile and capability negotiation relationship",
      "content": "The user profile contains the user's preferences. Support of the user's preferences will depend on the capabilities of the MExE device. If the capabilities change, then the degree of support of the user's preferences may change too.\nThe capability negotiation between the MExE device and the MSE, as shown in figure 2 \"Model of user profile and capability relationship\", contains those user preferences which the MExE device is able to support.\nIn this way the MSE will serve a MExE device with the lowest common denominator of the users preferences, the MExE device capabilities and the provided service characteristics and support the user's preferences to the maximum degree.\nFigure 2: Model of user profile and capability relationship",
      "chunk_type": "general",
      "cross_references": [
        "figure_2"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.2.2",
      "section_id": "5.2.2",
      "section_title": "Capability negotiation characteristics",
      "content": "The method for capability negotiation is based on the Composite Capability/ Preferences Profiles (CC/PP) specification made by W3C [16]. The properties and the actual schema, table 3\"UAProf properties supported by MExE\", is based on the WAP UAProf specification [17]. The CC/PP framework is intended to provide an efficient mechanism for enabling enhanced content and service negotiation through a standardised format for user agent profiles. The use of Resource Description Framework (RDF) [37] in CC/PP allows for interoperable encoding of the profile metadata in XML [36] and supports multiple vocabularies to provide for future extensibility. The WAP UAProf is based on the CC/PP framework. The purpose of the UAProf outlined in this document is to specify:\n-\tan RDF based schema and vocabulary for CC/PP in the context of the WAP UAProf that includes the class definitions and semantics of attributes described in a user agent profile, and\n-\tguidelines for schema extensibility to support a composite profile that enables future additions to the vocabulary and schema.\nNot all capabilities have to be reported in the request to the server but instead, the client may point to URL(s) where the server may fetch the properties. An MSE may, or may not, use the client capability information.\nThe generic set of capabilities which may be negotiated between the client and the server consists of the subsequently identified properties in the UAProf schema [17].\nA MExE device shall support the properties in the UAProf schema for capability negotiation defined in table 3 \"UAProf properties supported by MExE\" as \"mandated properties\".\nIt is recommended that MExE device supports the properties defined in the table 3\"UAProf properties supported by MExE\" as \"recommended properties\". It is not required that a MExE device shall send all the \"recommended properties\", when sending a request, however it should be possible for the MExE device to send one or more of the \"recommended properties\", with user permission.\nThe mandatory and recommended properties in table 3\"UAProf properties supported by MExE\" are specified in WAP UAProf [17].\nSupport of the properties of the UAProf schema in this specification shall not be limited to those listed in table 3 \"UAProf properties supported by MExE\". A MExE device may support any other properties from WAP UAProf specification [17].\nTable 3: UAProf properties supported by MExE\nMandated Properties\nAttribute\nDescription\nType\nSample\nMexeClassmarks\nList of supported MExE classmarks (Note 1)\nLiteral (bag)\n\"1\", \"2\", \"3\"\nMexeSpec\nThe first two digits of the MExE Specification version that the MExE device conforms to\nLiteral\n\"3.3\", \"4.1\"\nMexeSecureDomains\nIndicates whether the device supports the MExE security domains\nBoolean\n\"Yes\", \"No\"\nRecommended Properties\nVendor\nMExE device vendor\nLiteral\n\"Lexus\", \"Ford\"\nModel\nMExE device model number\nLiteral\n\"Mustang 90\", \"Q10\"\nSoftwareNumber\nThe number of the MExE device specific software.\nLiteral\n\"1.0\", \"2.7.0\"\nScreenSize\nThe size of the MExE device's screen in units of pixels.\nDimension\n\"160x160\", \"640x480\"\nScreenSizeChar\nSize of the MExE device's screen in units of characters (based on  the standard font).\nDimension\n\"12x4\", \"16x8\"\nColorCapable\nWhether the MExE device display supports colour\nBoolean\n\"Yes\", \"No\"\nAudioInputEncoder\nList of audio input encoders supported by the MExE device\nLiteral (bag)\n\"G.711\"\nVideoInputEncoder\nList of video input encoders supported by the MExE device\nLiteral (bag)\n\"MPEG-1\",  \"MPEG-2\", \"H.261\"\nPointingResolution\nType of resolution of the pointing accessory supported by the MExE device\nLiteral\n\"Character\", \"Line\", \"Pixel\"\nCcppAccept-Language\nList of preferred document languages\nLiteral (bag)\n\"zh-CN\" \"en fr\"\nKeyboard\nType of keyboard supported by the MExE device as an indicator of ease of text entry.\nLiteral\n\"Disambiguating\", \"Qwerty\", \"PhoneKeypad\"\nSupportedBearers\nList of bearers supported by the MExE device.\nLiteral (Bag)\n\"GPRS\", \"GUTS\", \"SMS\", CSD\", \"USSD\"\nJavaPlatform\nList of Java platforms and profiles installed on the device\nLiteral (Bag)\n\"Pjava/1.1.3-compatible\", \"MIDP1.0-compatible\", \"J2SE/1.0-compatible\"\nProposed New Recommended Property\nCLIPlatform (Note 2)\nList of CLI profiles installed on the device\nLiteral (Bag)\n\"CLI-Compact/1.0-compatible\", \"CLI-Standard/1.0-compatible\nNOTE 1:\tIn pre-release 4.0.0 specifications the attribute MexeClassmark (as opposed to MexeClassmarks) which was a literal (as opposed to as Literal, Bag) indicating only one MExE classmark was notified.\nNOTE 2:\tThe property name \"CLIPlatform\" is proposed as a placeholder. Once a decision has been made the final property name will be proposed to UAProf for UAProf approval.\nGenerally, the combination of user profile and MExE device logic will determine the information sent in the capability negotiation from the MExE device to the MExE Service Environment. As an example, for the support of VideoInputEncoder information the user's profile controls if and when VideoInputEncoder information may be sent to the MExE Service Environment (e.g. never sent, always sent, only after user confirmation).\nThe capability negotiation process shall be used by the client to permit transfer of capabilities from the client to the server.  By transferring its capabilities, the client will support efficient use of resources both over the radio interface as well as in the client or server. Capability negotiation shall be performed prior to transfer over the radio interface to verify as far as possible the ability of the client to support any services to be downloaded.\nIn order to transfer the capability information between the MExE device and the MSE, CC/PP method is used with the schema defined in the WAP UAProf working group.",
      "chunk_type": "general",
      "cross_references": [
        "table_3"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.2.3",
      "section_id": "5.2.3",
      "section_title": "Client content capability report",
      "content": "The client may perform content negotiation capabilities to the server by using appropriate HTTP/1.1 or WSP request headers. The following methods are available for content negotiation:\n-\tClient software (product): User-Agent header;\n-\tMIME media types: Accept header;\n-\tCharacter set: Accept-Charset header;\n-\tContent encoding: Accept-Encoding header;\n-\tLanguage: Accept-Language header.\nThere is no need for MExE to specify any tokens for content negotiation, as these headers are already defined in HTTP and WSP. The formats for these headers are specified in [9] and [6].",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.2.4",
      "section_id": "5.2.4",
      "section_title": "Server role in capability negotiation",
      "content": "The server may request the capabilities of a client whenever required, and shall enquire of the client's capabilities prior to making each transaction resulting in a set of transfers to the client; the characteristics which may be reported in the client capability report are identified in the list above.\nIn server-driven negotiation the server signals to the client that the response entity was selected from a set of available representation.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.2.5",
      "section_id": "5.2.5",
      "section_title": "Client-driven negotiation",
      "content": "If the server cannot specify an optimal version for the client basing on the CC/PP sent over to the server, the server may also indicate to client which type of versions are available and let the client make the decision. This method is already available in HTTP1.1. In client-driven negotiation the client selects the best representation after having received an initial response from the server.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.3",
      "section_id": "5.3",
      "section_title": "Provisioning and management of services",
      "content": "Support of management of services as detailed in this clause is mandatory.\nThe MExE device shall be capable of supporting services in a standard (WAP or Java) execution environment independently of the MExE device manufacturer.  Service provisioning provides a standardised method for a MExE device to discover and install services. It includes download and installation of the service's client application. Once discovered and delivered, services are managed by the user, under the principles stated in TS 23.227 [48]. Management of services provides the user with the capability to:\n-\tcontrol the transfer of services;\n-\tinstall and configure services;\n-\tcontrol the execution of services;\n-\tterminate or suspend executing services;\n-\tdelete services;\non his MExE device.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_23.227"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.3.1",
      "section_id": "5.3.1",
      "section_title": "Service discovery",
      "content": "A MExE user is able to request (or be informed about) the range of MExE services available from the MExE server to which it is connected. To be able to interactively discover the services via standard mechanisms such as WSP or HTTP, a MExE device should feature a browser which is a common tool for service discovery. The request, and transfer of information on MExE services from the MExE server is supported by the use of the capability negotiation mechanism.\nAll services available in the network continue to be available to the user, in addition to MExE services.\nAn example of an alternative means of receiving information on MExE services, is the use of an application on the MExE device which the user interrogates to provide services information (from various sources), and which in turn then obtains such information and presents it to the user. Such an example is not subject to standardisation.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.3.2",
      "section_id": "5.3.2",
      "section_title": "Service transfer",
      "content": "The standardisation of the transferral of MExE services to a MExE device is outside the scope of this specification.\nExamples of possible ways of supporting service transfer are from a MExE server or from another user MExE device (e.g. using wireless and standard protocols and mechanisms such as HTTP, FTP, proprietary protocols and mechanisms, via a serial link, infrared, Bluetooth data exchange, etc.).\nThe above examples are not exhaustive.  Regardless of the means of transfer, all services are required to conform with the security requirements in clause 8 \"Security\".",
      "chunk_type": "general",
      "cross_references": [
        "clause_8"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.3.3",
      "section_id": "5.3.3",
      "section_title": "Service installation and configuration",
      "content": "Installation of a service may result in changes to the MExE device user interface using icons, browsers or menus as applicable depending on the capability of the MExE device to support them. The name of the installed service may be contained in the package in which it was received (i.e. a JAR file or script), assigned by the user during configuration, or some other means. After installation, the service may be configured. Configuration of the service includes setting the user permissions that apply to the service (e.g. blanket permission for call origination). Configuration may be performed automatically based on the user profile.\nThe user controls whether a service transferred to the MExE device is automatically configured and installed in the MExE device. If automatic configuration and/or installation is enabled, the user is notified once it is completed. In the event that there is no authorisation for the automatic installation and/or configuration of a transferred service, the user is notified.\nSubsequent user modification of a service's configuration (e.g. by modification of user profile settings) shall take effect at the earliest possible opportunity thereafter.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.3.4",
      "section_id": "5.3.4",
      "section_title": "Service management",
      "content": "The MExE device shall support the ability to determine which services are transferred to, resident, installed or executing on the MExE device. The information relating to the services shall include the name as a minimum and the version number if available.\nThe user controls which services are permitted or denied to be transferred, resident, installed, configured or executing on the MExE device via the user profile, e.g. AcceptDownloadableSoftware. The user profile permits characteristics such as security level, identification of specific services etc. to manage services on the MExE device.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.3.5",
      "section_id": "5.3.5",
      "section_title": "Service termination",
      "content": "A MExE device shall support the termination of services.\nA service may terminate by itself, or be terminated by the provider of the service or by the user. The user is in charge of the service, except when the service provider may appropriately control the service as part of user support.\nThe mechanism for terminating a service is out of scope of standardisation and shall be provided on a service by service basis by the provider of the service.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.3.6",
      "section_id": "5.3.6",
      "section_title": "Service deletion",
      "content": "A MExE device shall support the deletion of services.\nA service may be deleted (i.e. removed) from the MExE device with the authorisation of the user. The deletion may be initiated by the authoriser of the service or by the user.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.4",
      "section_id": "5.4",
      "section_title": "User control of application connections",
      "content": "Support of the user control of application connections is mandatory and shall follow the principles and requirements stated in TS 23.227 [48].\nThis clause addresses the generic aspects of connection control supported by both WAP and Java classmark MExE devices.\nIn order to allow the user to maintain control over connections on his MExE device and the ability to initiate connections, the user shall be able to terminate or suspend any active connection associated with an application in the MExE environment of the MExE device. The user shall be able to obtain information about all connections associated with applications on the MExE device (e.g. requesting information, being informed by the MExE device etc.). Behaviour of the application following termination or suspension of its connection is undefined.\nThe specific support of connection control by WAP classmark MExE devices is identified in subsequent clause 7.3.1 \"Call control\", the security aspects of connection control are identified in clause 8 \"Security\", and the user control of connection authorisation is identified in clause 5.1 \"User profile\".",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_7.3.1",
        "clause_8",
        "clause_5.1",
        "ts_23.227"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.4.1",
      "section_id": "5.4.1",
      "section_title": "Journaling of network events",
      "content": "Support of the journaling of network events is mandatory.\nTo support the user in monitoring (potentially chargeable) network events initiated by services in the MExE environment, the MExE device shall maintain a record of network events initiated by MExE executables on the MExE device.\nNetwork events for the purposes of journaling, are defined as events which result in the origination of connections by a service in the MExE environment of the MExE device. Examples of such events (any (potentially chargeable) network event initiated by services in the MExE environment) are:\n-\tSending an SMS message;\n-\tSending an USSD message;\n-\tInitiating a circuit switched connection;\n-\tInitiating a packet switched connection;\n-\tSending data over a packet switched connection.\nThe length, format and longevity of the journal is undefined and subject to manufacturers' discretion.\nThe journal shall be managed by the MExE device, and not be accessible by MExE executables.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.4.2",
      "section_id": "5.4.2",
      "section_title": "User notification",
      "content": "Support of user notification is optional.\nIt is recommended that the MExE device should clearly display an indicator whenever network activity is in progress.\nIdeally, this would be an icon on the phone's screen which is displayed whenever the MExE device is sending/receiving SMS, USSD, data call, voice call, or packets.\nHowever, there are certain cases when this indicator need not be displayed, especially if it is obvious by some other means that the MExE device is performing network actions.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.5",
      "section_id": "5.5",
      "section_title": "Quality of service",
      "content": "Support of Quality of Service is optional.\nQuality of Service (QoS), TS 23.107 [28] is seen by the end user as a measure of the amount of network resources given to an application by the underlying network. The network may employ a number of QoS mechanisms, but the end user / MExE executable is not involved in these. The end user / MExE executable requires an interface into the network QoS through a visible set of standard parameters.\nA QoS aware MExE executable may request a QoS from the network at the beginning of a QoS session. Changes in the level of QoS provided shall be notified to the end user / MExE executable. An end user may request a change in the QoS through the MExE device MMI. A MExE executable may have several QoS streams open simultaneously.\nWhen the MExE execution environment supports QoS, the MExE executable shall be able to dynamically request a change in the level of QoS at connection setup request or subsequently during the connection. The end user / MExE executable may receive a rejection to a QoS modification request, upon which the end user / MExE executable must be notified.\nThe end user's service level QoS subscription parameters are stored in the network, they identify the maximum permissible QoS that a user may negotiate with the network. Several QoS subscriptions may be possible for one user. MExE is neither aware nor able to determine or modify the end user's service level QoS subscriptions.\nClause 9 \"Quality of Service\" defines the necessary functions for a MExE device to accommodate QoS management and provisioning. QoS management may be available directly to the MExE executables themselves, or to the MExE environment.",
      "chunk_type": "general",
      "cross_references": [
        "clause_9",
        "ts_23.107"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.5.1",
      "section_id": "5.5.1",
      "section_title": "Introduction",
      "content": "Support of quality of service for MExE devices supporting bearers defined by QoS as defined in this clause is optional.\nQoS aware MExE executables may be executing on the MExE device. To ensure correct operation with the QoS provisioning of the bearer network(s) the associated API's and the MExE QoS manager shall be supported by MExE device supporting bearers defined by QoS - see figure 3 \"Logical MExE device QoS manager elements\". Non QoS aware MExE executables shall operate with the defined QoS by the user or the network.\nFigure 3: Logical MExE device QoS manager elements",
      "chunk_type": "general",
      "cross_references": [
        "figure_3"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.5.2",
      "section_id": "5.5.2",
      "section_title": "MExE QoS support",
      "content": "In the logical architecture depicted in figure 3 \"Logical MExE device QoS manager elements\", a conceptual entity, a MExE QoS manager exists between the MExE executable and the Network Control API. A QoS API for MExE executables is provided and an API to the network is provided. The MExE QoS functions accommodate standard methods of end to end QoS provisioning.\nFor a MExE device supporting bearers defined by QoS, it is recommended that the MExE device shall support the following basic QoS operations:\n-\tThe end user should be able to manage the QoS directly via the MMI.\nFor MExE devices supporting bearers defined by QoS, the MExE device shall optionally support the following basic QoS operations:\n-\ta mapping between the QoS requirements of the MExE executable and the network layer;\n-\tMExE executables shall be able to indicate and interpret QoS values of the network via the MExE QoS Manager;\n-\tMExE executables shall be able to modify the QoS dynamically;\n-\tMExE executables shall be able to react to changes in the provided QoS;\nMExE introduces two new elements to cater for QoS - the MExE QoS manager and the QoS API. The MExE QoS manager shall handle the fact that the network may not have QoS capabilities.",
      "chunk_type": "general",
      "cross_references": [
        "figure_3"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.5.3",
      "section_id": "5.5.3",
      "section_title": "MExE QoS manager",
      "content": "As a conceptual entity, the MExE QoS manager is responsible for:\n-\tManaging the QoS streams for MExE executables;\n-\tNotification of the negotiated and delivered QoS to the end user / MExE executable.\nThe MExE QoS manager shall support the MExE QoS API according to the bearer supported by the MExE device, and provide functions such as:\n-\tinsert additional QoS signalling parameters;\n-\tadd the functionality of the MExE QoS API at best effort, if the network does not support it directly;\n-\ttranslate between the QoS parameters from the MExE executable and those of the network;\n-\tmonitor the QoS delivered by the network and manage QoS requests between the MExE executable and the network;\n-\tbe informed by the MExE executable of the requested QoS traffic class;\n-\tbe informed by the MExE executable of the lowest QoS traffic class which can be accepted by the MExE executable;\n-\tattempt to re-negotiate the QoS if it falls below the lowest QoS traffic class.\nThe MExE QoS manager may request information from the network regarding the QoS available.\nThe MExE QoS manager does not need to know the end user's subscribed QoS, this is held within the network and used to validate a requested QoS level.\nThe MExE QoS manager may also be accessed through the MExE device's MMI.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.5.4",
      "section_id": "5.5.4",
      "section_title": "Network control API",
      "content": "The network control API shall provide the QoS manager with access to the network specific QoS control (e.g. as defined for GPRS/UMTS in TS 24.007 [29] and TS 24.008 [30]).\nThe MExE QoS manager may perform some QoS control, even if it is not provided in the network control.",
      "chunk_type": "requirement",
      "cross_references": [
        "ts_24.007",
        "ts_24.008"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.5.5",
      "section_id": "5.5.5",
      "section_title": "MExE QoS API",
      "content": "The MExE QoS API provides the MExE executable with an interface to the QoS management. It does not require the MExE executable to have any knowledge of the underlying network, or how QoS is implemented in the network.\nThe QoS API shall provide the MExE executable with a standard set of parameters. Refer to TS 23.107 [28] for details of these parameters (see note 1).\nNOTE 1:\tThe FLOWSPEC parameters, defined by the IETF Integrated Services Working Group, provide the QoS information required by QoS capable network elements.\nTable 4 \"Example parameters\" shows the set of example parameters.\nTable 4: Example parameters\nParameter\nUnits\nType\nToken Bucket Rate\nbytes /sec\n32-bit IEEE floating point number\nToken Bucket Size\nbytes\n32-bit IEEE floating point number\nPeak Data Rate\nbytes/sec\n32-bit IEEE floating point number\nMinimum Policed Unit\nbytes\n32-bit integer\nMaximum Packet Size\nbytes\n32-bit integer\nLatency\nmicro secs\n32-bit integer\nDelay Variation\nmicro secs\n32-bit integer\nService Type\nservice type\nAs a minimum the following three parameters shall be supported by the MExE QoS manager:\n-\tToken Bucket Rate;\n-\tToken Bucket Size;\n-\tPeak Data Rate.\nNOTE 2:\tThe discussion of UMTS bearer service parameters as well as radio access bearer parameters is still going on. Especially the bitrate parameters and reliability parameter are under discussion, TS 23.107 [28].\nIf the MExE executable does not provide a full set of QoS parameters, then the MExE QoS manager shall the provide QoS parameters based on information available to it (e.g. from the MMI settings), see clause 5.5.6 \"Sources of Bearer Service Parameters\".",
      "chunk_type": "general",
      "cross_references": [
        "clause_5.5.6",
        "table_4",
        "ts_23.107"
      ]
    },
    {
      "chunk_id": "ts_23.057_5.5.6",
      "section_id": "5.5.6",
      "section_title": "Sources of bearer service parameters",
      "content": "A set of QoS parameters (QoS profile) specify the service provided to the user by the network. At bearer service establishment or modification different QoS profiles have to be taken into account. This is based on:\n-\tThe MExE device capabilities;\n-\tThe MExE device or the TE within the terminating network;\n-\tA QoS profile in the QoS subscription (describes the upper limits);\n-\tDefault QoS profile (of the user or network);\n-\tA Network specific QoS profile characterising for example the current resource availability or other network capabilities.",
      "chunk_type": "parameter",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.5.7",
      "section_id": "5.5.7",
      "section_title": "QoS streams",
      "content": "Several MExE executables may be executing in the MExE device, each with a different QoS requirement. Also, a MExE executable may operate several QoS streams, each with different parameter settings. The MExE QoS manager within the MExE device shall be able to deal with each stream independently.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.5.8",
      "section_id": "5.5.8",
      "section_title": "QoS security",
      "content": "Only the end user, MExE executable or the network using a QoS stream should be able to modify the QoS of that stream.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.6",
      "section_id": "5.6",
      "section_title": "Charging",
      "content": "Support of charging is outside the scope of MExE standardisation.\nThe following informative clauses provide a brief overview of the charging possibilities enabled by MExE.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_5.6.1",
      "section_id": "5.6.1",
      "section_title": "Generic charging support",
      "content": "The standard GSM/UMTS charging records contain information sufficient to associate bearer usage and SMS/USSD messages with a subscriber.\nThird party service providers and/or service providers may define charging regimes for MExE services (e.g. on a MExE or WAP server).",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.1",
      "section_id": "6.1",
      "section_title": "Introduction",
      "content": "In order to manage the MExE and prevent attack from unfriendly sources or transferred applications unintentionally damaging the MExE device a security system is required. This clause defines the MExE security architecture.\nThe basis of MExE security is:\n-\ta framework of permissions which defines the permissions transferred MExE executables have within the MExE device;\n-\tthe secure storage of these permissions (and permission type as defined in clause 6.5 \"User permission types\");\n-\tconditions within the execution environment that ensure that MExE executables can only perform actions for which they have permission.\nThe MExE permissions framework is defined in TS 22.057 [2] and is as follows (there is no implied hierarchy):\n-\tMExE Security Operator Domain (MExE executables authorised by the HPLMN operator, as described in clause 6.3.1 \"MExE executable permissions for operator, manufacturer and third party security domains\");\n-\tMExE Security Manufacturer Domain (MExE executables authorised by the ME manufacturer, as described in clause 6.3.1 \"MExE executable permissions for operator, manufacturer and third party security domains\");\n-\tMExE Security Third Party Domain (trusted MExE executables authorised by trusted third parties, as described in clause 6.3.1 \"MExE executable permissions for operator, manufacturer and third party security domains\");\n-\tMExE Untrusted Area. Untrusted MExE executables are not permitted to execute in a security domain (i.e. Operator domain, Manufacturer domain or Third Party domain) and execute in the Untrusted area, and have very reduced privileges as described in clause 6.3.2. \"MExE executable permissions for untrusted MExE executables\".\nA MExE device shall support either all three security domains or no domains. If the security domains are not supported, then all applications shall be untrusted. The MExE device shall not support any subset of the three security domains.  Support of the MExE Untrusted area is mandatory.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.5",
        "clause_6.3.1",
        "clause_6.3.2",
        "ts_22.057"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.2",
      "section_id": "6.2",
      "section_title": "MExE executable integrity",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the pre-verification of MExE executables at launch time described in this clause is optional.\nA potential threat is that MExE executables may be securely authenticated at the time of download, but tampered with or corrupted prior to being launched. Further a certificate may be compromised or expired. Authentication of a MExE executable at the time of download does not ensure that the MExE executable has not been modified when it is subsequently launched. Furthermore, authentication of a MExE executable at the time of launch does not ensure that the MExE executable is not modified during execution. Similarly, verification of the certificate at the time of download may not ensure that the certificate is valid at time of application launch, and verification of the certificate at the time of launch does not ensure that the certificate remains valid during execution.\nTherefore, the MExE device shall ensure application integrity immediately prior to application execution.\nApplication integrity is defined as the state in which:-\n-\tapplication code has not been modified since authentication; and\n-\tthe certificate containing the root public key is checked and known to be valid.\nThe mechanism by which the device preserves integrity is an implementation detail, dependant on the application storage mechanism and access. Examples of mechanisms that contribute to such application integrity could include:\n-\tStorage of applications in a memory area that cannot be compromised on the device;\n-\tPreventing launch of the application when the MExE device becomes aware that the certificate is invalidated;\n-\tFull signature verification prior to each application invocation (see clause 6.2.1 \"Full signature verification\");\n-\tOptimised pre-launch signature verification (see clause 6.2.2 \"Optimised pre-launch signature verification\");\n-\tPeriodic full signature verification by separate process during application execution.\nThe list of examples is not exhaustive and any other mechanisms ensuring application integrity may be equally considered.\nA MExE device may furthermore ensure that the application code has not been modified during application execution.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1",
        "clause_6.2.1",
        "clause_6.2.2"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.2.1",
      "section_id": "6.2.1",
      "section_title": "Full signature verification",
      "content": "Full signature verification assumes that the procedure of validation for downloaded MExE executables and certificates is used. For more details see clause 6.7 \"Certification and Authorization Architecture\".",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.7"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.2.2",
      "section_id": "6.2.2",
      "section_title": "Optimised pre-launch signature verification",
      "content": "This is an optional feature which is used to eliminate the potentially excessive overhead of checking a signature again after initial full certificate verification has already been performed.\nTo use this process the MExE device shall create a hash of the executable object (executable object fingerprint) as if checking the signature. This shall be stored in a protected verified application list, along with indication of the domain permissions for the application. The hash used shall be the same type as that used for signing the object. When launching an application or downloading an applet, the hash shall be performed as for when computing the signature. The verified application list shall then be checked; if the hash value is present and the entry has not expired then the application or applet may execute. If no list entry exists for this object, or the entry has expired, the process shall then proceed with the full signature verification. Note that the lists for applications and applets should be separate and that an implementation determines management policy for the lists (e.g., ageing policy, which entries to delete when trying to add a new entry to a full list etc.). One restriction imposed that shall be enforced is that the maximum number of uses for an entry before it is marked invalid is limited to some maximum value.\nIn the event that a new CCM is received by the MExE device, all verified application list entries shall be marked invalid unless some mechanism to determine the validity of an authorising certificate entry for each application is provided by the MExE device implementation.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.3",
      "section_id": "6.3",
      "section_title": "MExE executable permissions",
      "content": "Support of MExE executable permissions as detailed in this clause is mandatory.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.3.1",
      "section_id": "6.3.1",
      "section_title": "MExE executable permissions for operator, manufacturer and third party security domains",
      "content": "The following table 5 \"Security domains and actions\" specifies the permissions of operator, manufacturer and third party security domains in the order of restriction.\nThe actions listed in the security table 5 \"Security domains and actions\" are generic actions. These actions can only be performed by MExE executables via application programming interfaces (APIs) (which are intrinsically part of the MExE implementation) The security restrictions shall apply to MExE executables whether the API functionality is called directly or indirectly by the MExE executable. Explicit user permission is required for all actions by MExE executables in all domains. Types of user permission are defined in clause 6.5 \"User permission types\".\nUntrusted MExE executables are not permitted access to any actions which access the phone functionality (phone functionality includes all the actions in table 5 \"Security domains and actions\") except for the exceptions identified in clause 6.3.2 \"MExE executable permissions for untrusted MExE executables\".\nActions available using interfaces giving access to the phone functionality (either in existence at the time of approval of this specification or not) that are not listed in the security table 5 \"Security domains and actions\" shall be categorised into one of the groups in the security table 5 \"Security domains and actions\" by comparing its action against the groups in order as they are listed in the table 5 \"Security domains and actions\". If an action can be categorised into a more restrictive group near the top of the table, then it shall not be again categorised into another, less restrictive, group further down in the table. For example, if a new action eventually results in forwarding a call, it shall be categorised into Network access. If the action is totally new, it shall be categorised into some of the groups by comparing its functionality to the group description below and by comparing with the list of actions listed in the table within the group.\n1.\tDevice core function access includes functions, which are an essential part of the phone functionality .\n2.\tSupport of core software download, which allows updating the ME radio, characteristics and properties by changing the core software in the ME (e.g. a new CODEC may be loaded into a ME, a new air interface, etc.)\n3.\t(U)SIM smart card low level access includes functions, which allow communications at the transport service access point (send and receive application protocol data unit).\n4.\tNetwork security access includes all functionalities which relate to CHV, CHV2, UNBLOCK CHV and UNBLOCK CHV2 (verification, management, reading or modifying), GSM authentication, GSM ciphering.\n5.\tNetwork property access includes functions, which enable the management of operator-related data parameters and network settings.\n6.\tNetwork services access includes all functionalities which result in or need interaction via the operator's network.\n7.\tUser private data access includes all functionalities which relate to management, reading or modifying of data that the user has stored in the MExE device including user preferences.\n8.\tMExE security functions access includes all functionalities which, through an API relate to certificate handling in the MExE device; end to end encryption, signed content, hashing, access to public, private, secret keys stored in the MExE device or in a smart card.\n9.\tApplication access includes the functionalities which relate to launch provisioned functionality, MExE executables, external executables ((U)SIM tool kit application,…) usage.\n10.\tLifecycle management includes the functionalities which are needed for installing or removing MExE executables in the MExE device.\n11.\tTerminal data access includes the functions which relate to accessing terminal data, i.e. not user data.\n12.\tPeripheral access includes the functionalities related to peripherals other than user interface peripherals usage through a high level software application interface.\n13.\tInput output user interface access includes the functionalities related to the user interface and user notification means usage.\nTable 5: Security domains and actions\nMExE Security Domains\nActions\nOperator\nManufacturer\nThird Party\nDevice core function access\nStart/stop radio\nTurn on/off device\nWrite time and/or date\nActivate a user profile\nModify a user profile\nNo\nSupport of Core Software Download\ne.g. Update ME software\nNo\nYes\nNo\n(U)SIM smart card low level access11\nSend APDU\nSlot management (power on/off, reset, port lock…)\nNo\n11 - Access to (U)SIM is provided using more high level API as phonebook, application launching\nNetwork Security access\nRun algorithm\nVerify CHV/2 or UNBLOCK CHV/2\nActivate/deactivate CHV\nModify CHV/2\nNo\nNetwork property access\nGet IMSI\nGet home network\nSelect network\nYes\nNo\nNetwork services access\nInitiate a voice/data connection 3\nAccept a voice/data connection 3\nCall forward 4\nMultiparty call 4\nCall deflection 4\nExplicit call transfer 4\nTerminate an existing connection\nHold an existing connection\nResume an existing connection\nSend point-point message (e.g. SMS, USSD) 4\nQuery network status\nGet signal level\nGet call list\nQoS management\nYes\nYes 6\n3 - A network connection may be via any supported bearer service\n4 - Multiparty, deflection, and explicit call transfer shall be permitted only to numbers explicitly supplied by the user to the MExE Executable. Modification of call forward numbers stored in the network shall only be permitted to numbers explicitly supplied by the user to the operator.\n6- The Third Party domain's permission to access the networking action depends on the provisioning mechanism as described in clause 6.13.3  \"Determining the administrator of the MExE device\"\nUser private data access 1\nRead\nWrite\nGet properties\nDelete\nGet Location Information\nRead stored SMS\nDelete stored SMS\nModify user preferences\nYes2\nYes2\nYes2\nYes2\nYes2\nYes2\nYes2\nYes7\n1 - User private data includes user files, phonebook, MSISDN, etc located on the MExE device.\n2 - The user shall be able to specify data access permissions within the capabilities of the MExE device. It is not applied to user preferences\n7 - Trusted applications only have permission to modify user preferences, and not to activate or de-activate them. The user shall be able to specify for each domain, the preferences that applications in that domain can access. All other preferences shall not be accessible to that domain. The default shall be that there is no access. Single action user permission is the only type of user permission that shall be possible for changes to User Preferences.\nMExE security functions access\nInstall a certificate for a given domain\nUninstall a certificate for a given domain\nReplace a certificate for a given domain\nData encryption API\nVerify a signature API\nCompute a digital signature API\nHash a content API\nNon repudiation API\nYes 5\nYes 5\nYes 5\nYes\nYes\nYes\nYes\nYes\n5 - Only the organisation whose public key is certified (or the organisation that certified the public key) can add, delete or replace a particular certificate.\nApplication access\nGet application list\nLaunch an application\nGet application status\nStop, suspend, resume an application\nYes8\nYes8\nYes8\nYes9\n8 - ME provisioned functionality access is limited to manufacturer domain. (U)SIM tool kit application access is limited to operator domain.MExE executable access is limited to MExE executable issued by the same issuer (identify by the certificate) of launched MExE executable\n9 - Access is limited to MExE executable which launch the application. But the end user, shall have a way to stop the launched application, MExE environment may stop the launched application or launched application may stop itself.\nLifecycle management\nInstall a MExE Executable\nUninstall a MExE executable\nYes\nTerminal data access\nGet manufacturer software version\nRead time and date\nYes\nYes\nPeripheral access\nSound generation to speaker (e.g. via stream)\nSet speaker volume\nprinter access\nMonitor the power state\nChange the power state\nActivate/ access Serial port (RS232, IrDA, Bluetooth, USB …) access\nActivate/access Parallel port\nActivate/access Smart card other than (U)SIM card (Send APDU, Slot management)\nYes\nInput output User interface access\nInput device (keyboard, mouse …)\nOutput device (display )\nOutput notification device(smart icon, sound, light, vibrator …)\nYes10\nYes10\nYes\n10 - Access request requires no user permission.\nThe lists in the groups in table 5 \"Security domains and actions\" are not exhaustive, and other actions which are of the same category shall be included in the group for the purposes of requesting user permission.\nThis clause identifies the permissions for MExE executables in the 3 security domains (operator,  manufacturer and Third Party). The permissions do not apply to untrusted MExE executables which are not permitted to execute within the domains.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.5",
        "clause_6.3.2",
        "clause_6.13.3",
        "table_5",
        "table_9"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.3.2",
      "section_id": "6.3.2",
      "section_title": "MExE executable permissions for untrusted MExE executables",
      "content": "When the Security Domains are not supported then all executables are untrusted and they execute in the untrusted area for which the executable permissions are defined as follow in table 6 \"Executable permissions for untrusted MExE executables\".\nIn order to facilitate untrusted MExE executables having some limited access to MExE device functionality beyond their very limited privileges, some of the access permissions in the previous table 5 \"Security domains and actions\" are extended to untrusted MExE executables and described in table 6 \"Executable permissions for untrusted MExE executables\" as well as in clause 6.11 \"Separation of I/O streams\".\nThe untrusted MExE executables permitted to use these facilities shall be MExE executables the user has downloaded him or herself, and not be MExE executables that have been pushed to the user. MExE executables on the MExE device due to the user having visited a particular Web site are considered to be MExE executables that the user had downloaded him or herself.\nUntrusted MExE executables shall not be permitted access to any other functions.\nTable 6: Executable permissions for untrusted MExE executables\nClassmark 1\nClassmark 2\nClassmark 4\nClassmark 3\nUser Interface\nAn untrusted, uninstalled MExE executable (e.g. an applet) can access the user interface output and input without user permission, but the sending of user data to a server to which the MExE executables has a session connection (e.g. as part of a browser session) requires user permission.\nAn installed untrusted MExE executable shall only be able to access the user interface output and input with user permission (clearly, for the usability of untrusted MExE executables such as games, blanket user permission should be sought and given, and this is permissible).\nUntrusted MExE executables can access the user interface output and input without the user permission.\nFile, Persistent\nFile access is not permitted for untrusted MExE executables.\nData\nBut, untrusted MExE executables can access files only in the MExE executable's own directory.\nBut, persistent data may be stored via the MIDP record management system (stores are shared between MIDlets in the same MIDlet Suite).\nTransmission  over the Access Network\nUntrusted MExE executables shall be able to exchange data, voice, HTTP requests, etc. over the Access Network under the following conditions:\nThe recipient of a transmission (e.g. a phone number, a URL, a server name, etc.) shall be presented to the user for permission by a provisioned functionality of the MExE device itself, even if this recipient was already presented by the executable (this facility would support, for example, \"click to dial\" buttons/links in untrusted MExE executables).\nIt shall not be possible for an application to use a transmission channel that it did not initiate (except for MIDlets within the same MIDlet suite).\nGenerate DTMF\nUntrusted MExE executables shall be able to generate DTMF tones under the following conditions:\nAn untrusted MExE executable is only permitted to send DTMF tones in a currently active call. The request to generate DTMF tones in the currently active call, shall result in the characters which the tones represent being presented to the user for permission by a provisioned functionality of the MExE device.\nAdd Phonebook Entry\nUntrusted MExE executables shall be able to add a phonebook entry (i.e. name and number only) under the following conditions:\nThe name and the number to be added shall be displayed to the user for permission by a provisioned functionality of the MExE device and not by the MExE executable itself. The phonebook entry shall not be added without user permission.  The function shall not be able to modify or delete any phonebook entry.\nExecutable Interaction\nExecutable interaction is not permitted for untrusted MExE executables (except for MIDlets within the same MIDlet suite).\nNOTE:\tThe functionality of \"Generate DTMF tones\" and \"Add Phonebook Entry\" is not supported by the MIDP at the moment.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.11",
        "table_6",
        "table_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.4",
      "section_id": "6.4",
      "section_title": "Handling of MExE executables when their valid root public key is not available",
      "content": "This clause considers the effect on MExE executables when the root public key of a secure domain (e.g. operator, manufacturer, third party) is no longer available (e.g. when the UICC is being physically removed, or the root public key is no longer valid).",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.4.1",
      "section_id": "6.4.1",
      "section_title": "Launching of MExE executables when their valid RPK is not available",
      "content": "It shall not be possible to launch a MExE executable to run in a security domain unless the root public key of that security domain is available and valid.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.4.2",
      "section_id": "6.4.2",
      "section_title": "Currently executing secure MExE executables when their valid RPK is no longer available",
      "content": "On detection that the valid root public key of a secure domain is no longer present, the MExE device shall permit MExE executables currently executing in the secure domain controlled by that root public key to continue executing. Furthermore, if the same RPK is available again, the executable is allowed to keep on executing. However, if a different RPK is validated, the currently running MExE executables (under the old RPK) in that secure domain shall be terminated.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.5",
      "section_id": "6.5",
      "section_title": "User permission types",
      "content": "Support of user permission types is mandatory.\nThe term \"user permission\" is defined to mean that the user can give permission for a specific action in one of the ways defined in table 7 \"User Permissions\". Support single action permission is mandatory, but support of blanket permission and session permission is optional.\nAny request for user permission as described in table 7 \"User Permissions\" must display a user friendly name identifying the signer of the corresponding MExE executable, if available. The \"subject\" field of the certificate of the signer (\"subject\" here refers to the \"subject\" fields of WTLS and X.509 certificates and an equivalent field for any other format of certificate) shall be made available to the user upon request. If an application, for which user permission is being sought, is untrusted, the fact that the application is untrusted shall be at least visually indicated to the user, if the MExE device is capable of visual indication, whenever user permission is sought. Other means of indication are additionally permitted.  If the MExE device is not capable of visual indication, or is not designed for use by a human user, other means of indication shall be used.\nThe MExE device shall allow user control of permissions relating to all action groups listed in the table 5 \"Security domains and actions\" that are required by the MExE executable and supported by the MExE device.\nMultiple action group permissions may be controlled in a single user action on the MExE device regardless of the permission type as listed in table 7 \"User Permissions\". In such case, these action group permissions shall be made explicit to the user.\nNote that blanket permission cannot be used for uninstalled MExE executables e.g. applets, WMLS.\nTable 7: User Permissions\nUser Permissions\nPermission Type\nDescription\nInvocation\nRevocation\nblanket permission\nThe user gives blanket permission to the MExE executable for the specified action, and the MExE executable subsequently uses the user's original permission for the identified subsequent actions whenever the MExE executable is running.\nTypically such permission would be given at MExE executable configuration or run time.\nThe blanket permission maybe revoked by the user at any time. The user permission no longer applies once the MExE executable has been removed.\nsession permission\nThe user gives permission to the MExE executable for the specified action during a specific run time session of an MExE executable, and the MExE executable subsequently uses the user's permission for the identified subsequent actions whilst the MExE executable session is still running.\nTypically such permission would be given at MExE executable run time.\nThe session permission maybe revoked by the user at any time. The user permission no longer applies once the MExE executable run time session has terminated.\nsingle action permission\nThe user gives a single permission to the MExE executable for the specified action; if the MExE executable subsequently wishes to repeat the action it must again request the user's permission for the identified subsequent action.\nTypically such permission would be given at MExE executable run time.\nThe user permission no longer applies once the action has terminated.",
      "chunk_type": "general",
      "cross_references": [
        "table_7",
        "table_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.6",
      "section_id": "6.6",
      "section_title": "Root Public keys",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the root public key management described in this clause is optional.\nThe definition of the secure mechanism in this clause to mark as valid a root public key certificate on the ME, is out of the scope of this specification.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.6.1",
      "section_id": "6.6.1",
      "section_title": "Operator root public key",
      "content": "The ME may support secure storage for one or more certificates, each of which contains an operator root public key. The ME shall support the use and management of a certificate containing an operator root public key stored on the MExE-(U)SIM and in the ME. The ME shall behave according to clause 6.6.1.2 \"ME actions on SIM insertion and/or power up\". For support of public key management on the SIM and the USIM refer to TS 51.011 [27] and TS 31.102 [39] respectively. The certificate contains a root public key generated either by the operator, or by a CA trusted by the operator.\nIf the MExE device does not contain a valid operator root public key, then the certificate chain to MExE executable previously executing in the Operator Domain will be invalid, and the MExE executables will be excluded from the operator domain.\nThe user shall not be able to add or delete any type of operator public key (root or contained in a certificate).\nOptionally, the operator may install a corresponding disaster-recovery root public key stored in the MExE device, enabling the operator to use a secure mechanism (involving the disaster-recovery key) to replace the certificate containing the standard operator root public key. It shall not be possible to use the disaster recovery operator root public key to replace the operator root public key unless both public keys are from the same operator.\nThere shall be no more than one valid operator root public key on the MExE device at any one time. A valid operator root public key on the (U)SIM shall always have precedence over any operator root public key on the ME. Any operator root public key(s) on the ME shall be marked invalid when a valid operator root public key is present on the (U)SIM.\nAn application signed by an operator shall not be able to execute in the Operator Domain unless the root public key of that operator is installed in the MExE device (either ME or MExE-(U)SIM) and is marked as trusted.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.6.1.2",
        "ts_51.011",
        "ts_31.102"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.6.1.1",
      "section_id": "6.6.1.1",
      "section_title": "Caching of root public keys",
      "content": "The ME shall behave as if it reads the operator root public key from the secure area every time the ME needs the key to verify a signature. Examples of the secure area include an area on a (U)SIM or a secure, persistent area on the ME.\nIf the ME uses a mechanism for caching public keys, it shall do so in a way that maintains the integrity of the secure area and is consistent with the keys stored in the secure area. With the exception of improved performance, the operation of the device using cached public keys must be indistinguishable from that of a device that reads the key from the secure area every time it uses the key for verification.\nNo cached version of a key may exist beyond the expiration or termination of the key in the secure area. For example, if the ME caches a root public key held on the (U)SIM, the ME shall purge the cache when the (U)SIM application is stopped (or the SIM card is withdrawn).",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.6.1.2",
      "section_id": "6.6.1.2",
      "section_title": "MExE device actions on detection of valid (U)SIM application and/or power up",
      "content": "This clause defines the sequence of actions on identification by the MExE ME that a valid SIM card, or USIM application on the UICC, has been detected (e.g. through insertion of (U)SIM card, power up of MExE device etc.).  More specifically, these actions relate to the enabling or disabling of the operator domain and the status of the operator applications on the ME.\nThe requirements in this clause ensure that the operator domain on the ME belongs to the same operator as the operator that issued the valid (U)SIM application (if detected) in the MExE device and, if there is an operator root public key (ORPK) on the MExE-(U)SIM, that trusted operator applications on the MExE device were verified using that ORPK.\nThe ME shall support the use and management of an Operator root public key (ORPK) on the MExE-(U)SIM.\nOn power up the MExE device shall behave as dictated by figure 4 \"MExE device behaviour on power up\" below.\nFigure 4: MExE device behaviour on power up\nNote that the procedure in Figure 4 \"MExE device behaviour on power up\" checks for a match between the Operator ID on the (U)SIM and the Operator ID from the ORPK in the ME. Currently, one mechanism for defining the Operator ID on the (U)SIM is through use of the MCC+MNC. As an additional note, on DCS1900, the MCC+MNC is 6 digits, but elsewhere it is 5 digits. The MExE device needs to know how many digits to use. However, this is outside the scope of this specification.  The implementations of MExE devices need to establish agreements on using the MCC+MNC as the Operator ID on the (U)SIM. Likewise, the implementations of MExE devices need to establish agreements on how to define the Operator ID belonging to the ORPK.\nThe ME shall only read the ORPK from the MExE-(U)SIM when required and shall not store a ORPK from the MExE-(U)SIM on the ME in a manner inconsistent with that detailed in clause 6.6.1.1 \"Caching of root public keys\".\nWhen an operator root public key stored on the ME is marked as invalid, all operator applications verified using that root public key or by certificates verified by a chain that terminates with that root public key, shall cease operation as soon as possible and shall be marked as untrusted.\nRemoval of the (U)SIM shall not cause the status (i.e. valid or invalid) of any operator root public key on the MExE device to change.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.6.1.1",
        "figure_4"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.6.2",
      "section_id": "6.6.2",
      "section_title": "Manufacturer root public key",
      "content": "The ME shall support secure storage for a certificate containing a manufacturer root public key. The certificate contains a root public key generated by the manufacturer of the MExE device, or by a CA trusted by the manufacturer of the MExE device.\nIf the ME does not contain a valid manufacturer root public key, then the certificate chain to MExE executable previously executing in the Manufacturer Domain will be invalid, and the MExE executables will be excluded from the manufacturer domain and marked as untrusted.\nThe user shall not be able to add or delete any type of manufacturer public key (root or contained in a certificate).\nThe Manufacturer shall put a root public key and optionally its corresponding disaster-recovery key in the ME at the time of manufacture, and use a proprietary secure mechanism (e.g. using the disaster-recovery key) to replace the certificate containing the manufacturer root public key. It shall not be possible to use the disaster recovery manufacturer root public key to replace the standard manufacturer root public key unless both public keys are from the same manufacturer.\nAn application signed by a manufacturer shall not be able to run in the Manufacturer Domain unless the root public key of that manufacturer is installed in the ME and is marked as trusted.\nThe manufacturer, and only the manufacturer, may use a secure mechanism to mark as valid/invalid a certificate containing the manufacturer root public key on the ME. It shall only be possible to use this mechanism to mark a certificate containing a new manufacturer root public key on the ME as valid, when all manufacturer root public keys are marked as invalid.\nThere shall be no more than one valid manufacturer root public key on the ME at any one time. Any other manufacturer root public key(s) on the ME device shall be marked invalid when a different manufacturer root public key is marked as valid on the ME.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.6.3",
      "section_id": "6.6.3",
      "section_title": "Third party root public key",
      "content": "The ME shall support secure storage for at least one certificate containing a third party root public key. The ME shall support the use and management of certificates containing Third Party root public keys stored on the MExE-(U)SIM and in ME. For support of public key management on the SIM and the USIM refer to TS 51.011 [27] and TS 31.102 [39] respectively. The MExE device may contain root public key (s) generated by CA(s) implicitly trusted by the user. The user will be able to securely install (using a secure transport) or remove Third Party root public keys at any time using a system administrative tool.\nThe Manufacturer, Operator and Administrator may at their discretion, securely install certificates containing Third Party root public key(s) on behalf of the user, e.g. at the time of manufacture by the Manufacturer. See clause 6.10 \"Certificate management\" for details of Administrator control of Third Party certificate download.\nIf a Third Party public key is deleted or becomes invalid, then the certificate chain to MExE executables previously executing in the Third Party Domain certified by that public key will become \"untrusted\".\nThere may be any number of Third Party root public keys on the MExE device.\nThe third party domain administrator, i.e. the Administrator (user or other body) shall be able to enable and disable Third Party root public keys by using CCM, see clause 6.10.1 \"Certificate configuration message (CCM)\". The process of adding/removing public keys and enabling/disabling public key are independent.\nAll third party certificates shall be subject to restrictions imposed by valid certificate configuration messages.\nSee clause 6.10 \"Certificate management\" for the management of Third Party root public keys.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.10",
        "clause_6.10.1",
        "ts_51.011",
        "ts_31.102"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.7",
      "section_id": "6.7",
      "section_title": "Certification and authorisation architecture",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the certificate and authorisation architecture described in this clause is optional.\nIn order to enforce the MExE security framework a MExE device is required to operate an authentication mechanism for verifying downloaded MExE executables. A successful authentication will result in the MExE executable being trusted; and able to be executed in a security domain (as determined by the root public key of its certification tree).\nAs the MExE device may want to authenticate content from many sources, a public key based solution is mandatory. Before trusting MExE executables, the MExE device will therefore check that the MExE executable was signed with a private key, for which the MExE device has the corresponding public key. The corresponding public key held in the MExE device must either be a root public key (securely installed in the MExE device, e.g. at manufacture) or a signed public key provided in a certificate. The MExE device must be able to verify certificates, i.e. have the public key (as a root key or in a certificate) corresponding to the private key used to sign the certificate. Support of certificate chains is therefore mandatory.\nThe requirements on authorisation and certification are given in clause 6.7.1 \"Certification requirements\". An example authorisation and certification process is described in clause 6.7.3 \"Example certification process\".",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1",
        "clause_6.7.1",
        "clause_6.7.3"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.7.1",
      "section_id": "6.7.1",
      "section_title": "Certification requirements",
      "content": "A MExE device cannot verify certified MExE executables of a particular domain unless it has a root public key for that particular domain.\nRoot public keys shall be securely installed in the MExE device, say, at the time of manufacture.\nIt is recommended that a \"disaster recovery\" root public key be securely installed on the MExE device, to be used to install new root public keys when all other root public keys on the MExE device are invalid.\nThird Party Domain root public keys will typically be installed along with and integrated into the MExE device browser, as is done for PC-based browsers.\nA MExE executable can only be verified if the MExE device contains a valid root or certified public keys corresponding to the private key used to sign the MExE executable.\nA MExE device shall support at least one level of certificate under operator, manufacturer or Third Party root public keys. The MExE device shall support at least one level of certificate chain analysis in a signed content package, as shown in figure 5 \"Trust hierarchy\".\nA certificate (other than one containing a root public key) shall only be considered valid if the signature on the certificate is verified by a valid public key (root or contained in a certificate) already present on the MExE device and if the certificate being verified has not expired.\nPublic keys shall not be shared between domains.",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.7.1.1",
      "section_id": "6.7.1.1",
      "section_title": "MExE terminal requirements for certificate processing",
      "content": "A MExE device shall support the processing of X509 certificates profiled in the \"WAP Certificate and CRL Profile\" [47] together with additional requirements defined in the MExE specification, see clause 6.9.1.1 \"X509 version 3\". The certificate chain depth is still mandated to be one level only, as mentioned in clause 6.7.1 \"Certificate requirements\" and indicated in figure 5 \"Trust hierarchy\".\nA MExE device shall support the SHA1WithRSA signature algorithm. The object identifier value can be found in  [49]. A MExE device may also support other signature algorithms.\nMExE devices may also support the processing of other certificate formats.\nFigure 5: Trust hierarchy\nThe boxes below the root keys represent individual public key certificates. The solid boxes represent the minimum MExE, and the dotted boxes represent possible further support for public key certificates (either at the first or subsequent levels).",
      "chunk_type": "procedure",
      "cross_references": [
        "clause_6.9.1.1",
        "clause_6.7.1",
        "figure_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.7.2",
      "section_id": "6.7.2",
      "section_title": "Certification administration requirements",
      "content": "For control of third party certificates, the MExE device supports storage of a certificate containing an administrator root public key as detailed in clause 6.13.1 \"Administrator root public key\".\nThis certificate is managed separately from the hierarchy of Figure 5  \"Trust Hierarchy\" discussed in clause 6.7.1 \"Certification requirements\".  The administrator root public key in this certificate is primarily used for designating an administrator of the third party certificates. Note, the administrator root public key does not implicitly define a security domain, and is used in complement with the root public keys of the operator, manufacturer, and third party domains.\nThe relationship of the administrator certificate (and root public key) to the management of third party certificates is detailed in part of clause 6.10 \"Certificate management\".\nThe relationship of the administrator certificate to the mechanism for determining if a third party certificate is trusted is detailed in part of clause 6.10.1 \"Certificate configuration message (CCM)\".\nMechanisms for designating an administrator are detailed in clause 6.13.2 \"Provisioned mechanism for designating administrative responsibilities and adding third parties in a MExE device\".",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.13.1",
        "clause_6.7.1",
        "clause_6.10",
        "clause_6.10.1",
        "clause_6.13.2",
        "figure_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.7.3",
      "section_id": "6.7.3",
      "section_title": "Example certification process",
      "content": "The following processes might be followed in order to securely download a Third Party application to a MExE device.\nRoot public keys for a number of Certification Authorities (CAs) are installed in the MExE device, along with the MExE device browser, at manufacture. These root public keys can be used to verify certificates for Third Party MExE executables.\n1.\tA third party software developer generates a private and public key pair (or obtains such a pair from a CA).\n2.\tThe third party software developer obtains a certificate for the public key from a CA. The certificate contains the developer public key, signed with the private key of the CA.\n3.\tThe 3rd party software developer adds all the certificates required in the key chain in the JAR.\n4.\tThe MExE device downloads a MExE executable of the third party software developer.\n5.\tThe MExE device verifies the certificate using the root public key, contained in the browser, of the relevant CA, and extracts the third party software developer public key and may store it in the certificate store for future use.\n6.\tThe MExE device verifies that the MExE executable was signed using the private key corresponding to the third party software developer public key and installs or rejects the MExE executable accordingly.\nAll downloaded applications shall follow the procedure described in clause 6.7.4 \"Certificate Chain Verification\" in order to verify the application signature and the certificate chain. If the 3 security domains are not supported, the procedure described in the next clause is optional.",
      "chunk_type": "procedure",
      "cross_references": [
        "clause_6.7.4"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.7.4",
      "section_id": "6.7.4",
      "section_title": "Certificate Chain Verification",
      "content": "This clause presents the procedure of validation of any downloaded MExE executable. It checks for the presence of the signature used to sign the application as well as the presence and integrity of all the certificates needed to successfully verify the signature. As a result, the application under scrutiny is deemed trusted or untrusted, i.e. will be allowed execution in one of the secure domains or in untrusted area, or otherwise the application will not be allowed to be executed and will be deleted. In any outcome of the verification, the user is notified about the result. The user also may wish to see certificate details if the application is allowed to be executed on the MExE device.\nThe MExE device shall follow \"certificate verification\" procedure as described below. The procedure shall contain at least the following logical phases (not necessarily in the order stated below):\nSignature and Certificate Verification Supported: Checks whether signature and certificate verification procedure is supported on the MExE ME.\nExecutable with Signature and End Entity Certificate (note): Checks whether the executable contains a signature together with the corresponding end entity certificate.\nValid Application Signature (note): This phase comprises the following checks:\n-\tCheck if the signature and the end entity certificate formats are supported by the device. If this check fails, the application is classified as untrusted.\n-\tCheck if the signature algorithm is supported/known by the device. If this check fails, the application is classified as untrusted.\n-\tCheck if the signature can be cryptographically verified by using the accompanying end entity certificate . If this check fails, the application is not allowed execution and is deleted.\nComplete set of Intermediate Certificates Available (note): Checks if all the necessary intermediate certificates (certificates between the RPK and the end entity certificate) are available.\nValid RPK on (U)SIM/ME: Checks if a valid RPK (not expired) exists on the (U)SIM or on the ME that could verify a certificate chain originating from the end entity certificate accompanying the application.\nNOTE:\tThese steps could include validation (e.g. expiration, revocation, etc.) checking by means of e.g. OCSP, SCVP, CRL-Consultation, and etc. The use of certificate revocation checking is recommended but is not mandated or defined in this specification.\nCertificate Chain Cryptographically Verified: Checks if all the certificates from the end entity certificate to the RPK can be verified cryptographically. Certificate verification shall be performed according to the functional requirements given in clause 6.1 \"Basic Path Validation\" of RFC 2459 [43] excluding revocation checking.\nSecure Domains Supported: Checks whether MExE ME supports secure domains.\nOnly if all the above checks are successful, the downloaded application is deemed trusted and is allowed to be executed in the designated trusted domain (operator, manufacturer, trusted third party). Otherwise, the application is either untrusted (execution in the untrusted area only is allowed) or deleted (execution is not allowed at all) as per the figure 6 \"Certificate Chain Verification Diagram\" and as explained above. The executable shall only be designated into one of the trusted domains, and it shall be possible to verify the certificate chain unambiguously to one and only one root public key.\nThe MExE ME shall allow for a \"user notification\" procedure as described below.\nIt shall be possible to display certificate details to the user if requested, however, since the terminal might not have a display or might not be meant for a human user the methods presented in \"user notification\" section are not discussed any further in this specification. Figure 6 \"Certificate Chain Verification Diagram\" shows an example of the certificate chain verification procedure.\nFigure 6: Certificate Chain Verification Diagram",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1",
        "figure_6"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.8.1",
      "section_id": "6.8.1",
      "section_title": "Signed packages used for installation",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the signed packages used for installation, described in this clause, are optional.\nThe Java Archive (JAR) file format shall be supported on classmark 2 and 3 MExE devices for securely packaging objects that are to be downloaded and installed on the ME. The method for securely packaging objects for MExE classmark 1 devices may be referenced from the WAP specifications in a future release of this specification. A MExE device may support other proprietary means of downloading and installing objects.\nThe JAR file shall contain a manifest file that has at least the following attribute:\nMExE-Implementation-Type\nThe information contained within the manifest file is represented as so-called \"name: value\" pairs, where \"name\" is represented by MExE-Implementation-Type. Groups of name-value pairs are known as a \"section\", where sections are separated from other sections by empty lines.\nThe MExE-Implementation-Type value shall be one of the following:-\n-\t\"MExENativeLibrary\"\nin the case of a MExE Native Library (as described in 8.3.2 \"Installing MExE native libraries\");\n-\t\"TTPCertificate\"\nin the case of a certificate containing a 3rd party root public key (as described in 6.8.2  \"Installation of root certificates in a signed data package\");\n-\t\"ManufacturerCertificate\"\nin the case of a certificate containing a manufacturer root public key (as described in 6.8.2 \"Installation of root certificates in a signed data package\");\n-\t\"OperatorCertificate\"\nin the case of a certificate containing an operator root public key (as described in clause 6.8.2 \"Installation of root certificates in a signed data package\");\n-\t\"AdminCertificate\"\nin the case of an administrator certificate, which shall consist of a section containing both the administrator certificate and a CCM (as described in clause 6.8.2 \"Installation of root certificates in a signed data package\"); or\n-\t\"OrdinaryTTPCertificate\"\nin the case of a certificate or certificate list containing 3rd party public key(s). An example of a certificate list syntax can be found in [52]\n-\t\"OrdinaryManufacturerCertificate\"\nin the case of a certificate or certificate list containing manufacturer public key(s). An example of a certificate list syntax can be found in [52]\n-\t\"OrdinaryOperatorCertificate\"\nin the case of a certificate or certificate list containing operator public key(s). An example of a certificate list syntax can be found in [52]\n-\t\"CCM\"\nin the case of a CCM (as described in clause 6.8.2 \"Installation of root certificates in a signed data package\"); or\n-\t-free-format-value-\nin the case of proprietary binaries or Java classes such as native DSP code, provisioned functionality upgrades and patches (as described in clause 6.8.3 \"Installation of other signed data\").\nRefer to [42] for full details of how to encode the \"name: value\" pairs and \"section\" in a JAR manifest file.\nSee figure 7 \"Signed packages\". When a download of a JAR file is completed, the system installer shall read the manifest to determine what types of files are contained in the JAR, and install them appropriately.\nNote that a signed package containing a library which does not have a manifest attribute \"MExE-Implementation-Type: MExENativeLibrary\" shall be considered to be some type of upgrade to libraries that are intrinsically part of the MExE device implementation rather than a \"MExE native library\". E.g.\nMExE-Implementation-Type: ManufacturerUpgrade (something.dll)\n(Recommended behaviour for the server is that it uses the capability information supplied from the MExE device to determine how to offer appropriate upgrades.)\nFigure 7: Signed packages",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1",
        "clause_6.8.2",
        "clause_6.8.3",
        "figure_7"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.8.2",
      "section_id": "6.8.2",
      "section_title": "Installation of root certificates in a signed data package",
      "content": "Root certificates in a signed package (whose signature verifies as described in clause 6.6 \"Root Public keys\" to the Manufacturer root, Operator root, or the Administrator root), may be installed to the root public key store on the MExE device. Note that the certificate thus packaged does not necessarily belong to the manufacturer domain. The types of certificate that can be present and installed by packages are given in table 8 \"Allowed certificate types in signed packages\". The MExE device shall store the root public key as indicated by the certificate type.\nWhen a certificate containing an Administrator root public key is thus contained in a signed package, the signed package (e.g. a JAR file in the case of Java based MExE classmarks) shall contain two files: the Administrator root public key and the CCM.\nTable 8: Allowed certificate types in signed packages\nSignature on Package\nAllowed Certificate types in package\nAdministrator\nThird Party\nManufacturer\nAdministrator, Manufacturer, Operator, Third Party\nOperator\nAdministrator, Operator, Third Party",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.6",
        "table_8"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.8.3",
      "section_id": "6.8.3",
      "section_title": "Installation of other signed data",
      "content": "A signed package of proprietary binaries or Java classes such as native DSP code, provisioned functionality upgrades and patches, whose signature verifies as described in clause 6.6.2 \"Manufacturer root public key\" as belonging to the Manufacturer Domain may be installed. The use of such binaries is outside the scope of MExE, but the manufacturer shall be responsible for ensuring that the integrity of MExE is not compromised.\nSupport of this feature is optional.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.6.2"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.9.1",
      "section_id": "6.9.1",
      "section_title": "Certificate extension for removal of network access",
      "content": "MExE defines the certificate extension (attribute) \" access-Restriction\". If the access-Restriction extension is present in a certificate used to verify the signature on a trusted application or in any certificate in the certificate chain used to verify that signature, then the application shall not be permitted the capabilities listed under \"network service access\" in the security table, (table 5 \"Security domains and actions\"). This restriction applies irrespective of any user permission for network service access that may or may not be requested by the application and/or given by the user.\nThe extension prevents the trusted applications of developers who do not need network service access from writing applications that can perform network service access.\nThe support of this extension in the operator domain is mandatory. The support of this extension in the manufacturer and third party domains is optional.\nThe extension is defined for X.509 version 3 only. Support for WTLS, X9.68 certificate formats is for further study.",
      "chunk_type": "general",
      "cross_references": [
        "table_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.9.1.1",
      "section_id": "6.9.1.1",
      "section_title": "X.509 version 3",
      "content": "The MExE certificate format as specified in clause 6.7.1.1 \"MExE terminal requirements for certificate processing\" shall support the X.509 version 3 access-Restriction  extension.\nX509 version 3 provides a mechanism to define extensions. An Object identifier (OID) is defined for each private extension as defined in ITU-T Recommendation X509 [26]. The extension is defined to be within the ETSI Object Identifier (OID) name space.\nThis extension shall apply irrespective of the presence or otherwise of any other X.509 key usage or extended key usage field.\nNormal use of the \"critical\" flag for extensions apply. That is, if this extension is marked as critical in the certificate used to verify the signature on the application or in any certificate in the chain used to verify the signature and this extension cannot be processed in the MExE device then the certificate shall be considered invalid.\nThe syntax of the extension is defined in annex C \"Access restriction certificate extension\".",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.7.1.1"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.10",
      "section_id": "6.10",
      "section_title": "Certificate management",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the certificate management described in this clause is optional. The manufacturer may load initial third party certificates on the ME. Downloaded certificates shall be verified by an existing trusted certificate and placed in the domain defined by the root public key at the top of the verification chain for the downloaded certificate.\nThe administrator root certificate shall be provided on the (U)SIM if support for certificate storage on the (U)SIM exists (e.g. MExE-(U)SIM) or in the MExE device. For (U)SIMs not having certificate storage the administrator root may be downloaded using the root download procedure described in clause 6.13.4 \"Administrator root certificate download mechanism\".\nThe actions that may be performed for a given certificate are:\n-\taddition;\n-\tdeletion;\n-\tmark un-trusted (un-trusted certificates cannot be used to verify applications or other certificates. This process may be preferred to certificate deletion as there is a chance that the certificate may become trusted again in the near future);\n-\tmark trusted (marking as trusted is the process of allowing an untrusted certificate to come into use again);\n-\tmodify fine grain access permissions (proposed as a future enhancement).\nThe ability to perform these actions depend on the certificate type being modified as well as the access level of the entity performing the operation.\nUsers may add a third party certificate as long as it is certified by an existing trusted certificate. Using a provisioned functionality, users may delete Third Party certificates.\nThe Administrator may mark trusted/untrusted Third-Party certificates using Certificate Configuration Messages (see clause 6.10.1 \"Certificate configuration message (CCM)\".\nUsers cannot add or delete any Operator or Manufacturer certificate containing a root public key.\nAn example of public key infrastructure certificate management protocols can be found in RFC 2510 [33].",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1",
        "clause_6.13.4",
        "clause_6.10.1"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.10.1",
      "section_id": "6.10.1",
      "section_title": "Certificate configuration message (CCM)",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the certificate configuration message described in this clause is optional.\nThe MExE device shall use the CCM to determine the third party certificates (and only the Third Party certificates) that are trusted for use on the MExE device. The CCM shall only be used to enable or disable third party certificates and can not be used to delete certificates. The CCM may be periodically fetched or downloaded to a MExE device by the Administrator to dynamically configure the third party list using the mechanisms defined in clause 6.10.1.4 \"Authorised CCM download mechanisms\".\nThe Certificate Configuration Message shall be as shown in figure 8 \"Format of a CCM\". This message is essentially a simplified version of a certificate revocation list to satisfy a particular use case. More complex usage requires a full certificate revocation list.\nThe MExE device may additionally support other means of enabling/disabling root certificates.\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nOctet\nVersion\n0\nCertificate Advice\n1\nIssue Timestamp\n.\n.\n2 - 8\nExpiry Timestamp\n.\n.\n9 -15\nSignerInfo\n16\nListlength\n17 -18\nFingerprint 1 Hashtype\n19\nHashvalue\n(Variable length k according to hash type)\n.\n.\n20\nFingerprint 2 Hashtype\nk+20\nHashvalue\n(Variable length m according to hash type)\n.\n.\nFingerprint 3 Hashtype\n(k+20)+m+1\nHashvalue\n(Variable length)\n.\n.\nFingerprint n Hashtype\netc.\nHashvalue\n(Variable length)\n.\n.\nCCM Signature Hashtype\nListlength+19\nCCM signature\n(Variable length according to CCM signature type)\nFigure 8: Format of a CCM\nVersion = The CCM format version is 0. All other values are reserved for future use.\nCertificate Advice = enumerated { enable all present and future Third Party certificates (0), disable all present and future Third Party certificates (1), enable present list only (2),enable CCM list (3), disable CCM list (4) }. All other values are reserved for future use.\nIssue and Expiry Timestamps = Fields used to identify the issue and expiry date of the CCM. The issue timestamp indicates a time before the current time of day (GMT) when a CCM message must be considered invalid. The expiry timestamp (GMT) identifies the time when a CCM is to be deemed no longer valid. The receiver shall use these parameters to detect a replay attack. A MExE device maintains information on the last valid CCM message received. A replay attack is an attacker replaying a previous valid CCM message to a MExE device in order to change the security settings. This is particularly dangerous for CCM messages used to enable certificates. Administrators should try and set the expiration time to be no longer than the next expected system update time of CCM information. CCM messages used to enable-all (rather than disable-all) certificates should be very short lived as the danger of these being used in a replay attack should be considered serious.\nThe encoding of time (GMT) shall be coded as an OCTET SEQUENCE of seven octets in length as follows:\nOctet 0\n1\n2\n3\n4\n5\nOctet 6\nYear\nMonth\nDay\nHour\nMinute\nSecond\nElement\nSize (bits)\nRange\nYear\n16\n(0 - 65535)10\nMonth\n8\n(1 - 12) 10\nDay\n8\n(1 - 31)10\nHour\n8\n(0- 23)10\nMinute\n8\n(0 - 59)10\nSecond (see note)\n8\n(0 - 60)10\nNOTE:\tThe second field range includes the value 60 in order to accommodate leap seconds.\nFor example, 1st January, 2001 00:00:30 would be encoded as: 07 d1 01 01 00 00 1E.\nSignerInfo = one octet indicating the type of signer information for this CCM. The only currently defined value is device-admin = 0. In this case, no further signer information follows as it is implicit. All other values are reserved for future use.\nListlength = The total length of the fingerprint list not including the final CCM signature. Shall be zero when certificateAdvice = enable-all, disable-all or enable present list.\nHashtype = enumerated { signature (0), MD5 (1), SHA-1 (2) } All other values are reserved for future use.\nThe length of the Hashvalue field, number of octets output by the selected hash type, is 16 for MD5 [23] or 20 for SHA-1, ISO/IEC 10118-3 [24].\nThe list entries shall contain certificate fingerprints in the form of hashes of the encoded signed certificates. The full hash output for the specified algorithm shall be used to generate the fingerprint. A list generator shall check to insure that no two list entries match when creating a list. For an ITU-T Recommendation X.509v3 [26] or X9.68 (currently being drafted) certificate the fingerprint hash shall be computed over the ASN.1 encoded signed certificate object, first octet to last octet. For WTLS certificates the hash shall be computed over the signed WTLS certificate in network transmission format, first octet to last octet.\nThe signature type and length shall be indicated by the administrator certificate, which shall be present on the MExE device. If no administrator certificate is on the MExE device or if the signature is not verified, the message shall be rejected.\nUpon receipt of a valid certificate configuration message the MExE device shall go through the third party certificate list, computing fingerprints if they are not stored with the certificate and enabling or disabling each certificate according to the following conditions:\n-\tcertificateAdvice is enable-all\nall Third Party certificates shall be enabled;\n-\tcertificateAdvice is disable-all\nall Third Party certificates shall be disabled;\n-\tcertificateAdvice is enable present list only\nenable all Third Party certificates currently on MExE device, do not enable any future certificates (this option allows the list to be frozen at time of manufacture) until Administrator changes;\n-\tcertificateAdvice is enable-list\nif its fingerprint occurs in the CCM, it shall be enabled, otherwise it shall be disabled;\n-\tcertificateAdvice is disable-list\nif its fingerprint occurs in the CCM, it shall be disabled, otherwise it shall be enabled.\nFor future releases, the setting of fine grained permissions for each certificate is expected to be supported.\nAn implementation shall keep track of the domain that authorised a given executable. If a CCM message is received while MExE executables are currently executing, the implementation shall check to ensure that any executables no longer in the Third Party domain, have their permissions re-configured appropriately and actions that are no longer permissible are terminated.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.1",
        "clause_6.10.1.4",
        "figure_8"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.10.1.1",
      "section_id": "6.10.1.1",
      "section_title": "CCM numbering convention",
      "content": "Bits are grouped into octets. The bits of an octet are shown horizontally and are numbered from 0 to 7. Multiple octets are shown vertically and are numbered from 0 to n.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.10.1.2",
      "section_id": "6.10.1.2",
      "section_title": "CCM order of transmission",
      "content": "Frames are transferred in units of octets, in ascending numerical octet order (i.e., octet 0, 1, …, n-1, n). The order of bit transmission is specific to the underlying protocols used to transport the CCM.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.10.1.3",
      "section_id": "6.10.1.3",
      "section_title": "CCM field mapping convention",
      "content": "When a field is contained within a single octet, the lowest bit number of the field represents the lowest-order value. When a field spans more than one octet, the order of bit values within each octet progressively decreases as the octet number increases. In that part of the field contained in a given octet the lowest bit number represents the lowest-order value.\nFor example, a 16 bit number can be represented as shown in figure 9 \"Field mapping convention\".\nBit\n7\n6\n5\n4\n3\n2\n1\n0\n215\n214\n213\n212\n211\n210\n29\n28\n1st Octet of field\n27\n26\n25\n24\n23\n22\n21\n20\n2nd Octet of field\nFigure 9: Field mapping convention",
      "chunk_type": "general",
      "cross_references": [
        "figure_9"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.10.1.4",
      "section_id": "6.10.1.4",
      "section_title": "Authorised CCM download mechanisms",
      "content": "The download of third party certificate lists by a remote administrator shall be performed by using a secure mechanism as defined below. The download mechanisms shall use HTTP over IP and/or the WAP Protocol. The URL from which the CCM is downloaded shall be in the administrator certificate if the CCM was not downloaded with the Administrator certificate. The format for storing the URL information with the certificate shall be as shown in figure 10 \"CCM Message URL storage format\":\nFigure 10: CCM Message URL storage format\nUrltype= one byte, enumerated {WAP (0), HTTP (1)}. All other values are reserved for future use.\nCharacterSet = one byte, Internet Assigned Numbers Authority assigned character set.\nUrlLength = one byte unsigned integer, length of the URL in octets.\nURL = a field where the format for storing the URL information in the certificate shall be defined as part of the enhanced administrator mechanism.\nWhen the administrator is changed, then the CCM shall also be changed. If there is URL information with the certificate as described in figure 10 \"CCM Message URL storage format\", then the new CCM shall be obtained using the URL. If the Administrator certificate was downloaded in a JAR file, the CCM shall be obtained from the same JAR file.",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_10"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.11",
      "section_id": "6.11",
      "section_title": "Separation of I/O streams",
      "content": "Support of the separation of I/O streams is mandatory.\nExcept for the MExE Classmark 3 executables (MIDlets) from the same MIDlet Suite, there shall be strict separation of the user interface input and output streams between different MExE executables, i.e. it shall not be possible for one MExE executable to access the user interface input or output of another MExE executable. In particular, it shall not be possible for an untrusted MExE executable to access the user interface input and output destined for or proceeding from a trusted MExE executable. (This requirement is to prevent a long lived malicious MExE executable from eavesdropping upon on interfering with the user to MExE executables communications, for instance PINs, of a trusted MExE executable).",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_6.12",
      "section_id": "6.12",
      "section_title": "Core software download",
      "content": "Support of core software download is optional.\nCore software download enables the MExE device radio, characteristics and properties to be updated by changing the software in the MExE device. E.g. a new CODEC may be loaded into a MExE device, a new air interface, etc. This process could include the transfer of executable code and software patches over the air.\nThis updating of core software (e.g. the Software Defined Radio (SDR) concept) can in principle be generically supported within the MExE framework by a MExE service that executes in the manufacturer security domain, and uses handset manufacturer proprietary APIs.  Possible scenarios for the support of this functionality include:\n-\tA MExE service that can be transferred to, and executed in, the manufacturer domain. The service would use manufacturer APIs to perform the software update, radio re-configuration, etc.\n-\tA core software download application that executes in the manufacturers' domain that acts like a user agent in conjunction with a server to transfer software as needed or requested by the user. The core software download application uses manufacturer APIs to perform the software update, radio re-configuration, etc.\nSimilar functionality may be supported by a downloaded MExE service using manufacturer's OEM classes. All such OEM classes shall comply with the MExE security requirements in table 5 \"Security domains and actions\" and table 6 \"Executable permissions for untrusted MExE executables\".\nThe support of core software download functionality in a MExE device shall only be under the control of the MExE device manufacturer.",
      "chunk_type": "general",
      "cross_references": [
        "table_5",
        "table_6"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.1",
      "section_id": "6.13.1",
      "section_title": "Administrator root public key",
      "content": "To help with the control of Third-Party certificates, the ME shall support secure storage for a certificate containing an administrator root public key. The ME shall support the use and management of a certificate containing an Administrator root public key stored on the MExE-(U)SIM and in the ME. The ME shall behave according to clause 6.13.3 \"Determining the administrator of the MExE MS\". For support of public key management on the SIM and the USIM refer to TS 51.011 [27] and TS 31.102 [39] respectively.\nA secure mechanism may be used to mark as valid/invalid a certificate containing the administrator root public key on the MExE device. It shall only be possible to use this mechanism to mark a certificate containing a new administrator root public key on the ME as valid, when all administrator root public keys are marked as invalid.\nThere shall be no more than one valid administrator root public key on the MExE device at any one time. A valid administrator root public key on the (U)SIM shall always have precedence over any administrator root public key on the ME. Any administrator root public key(s) on the ME shall be marked invalid when a valid administrator root public key is present on the (U)SIM.\nThe MExE device shall support the administrator designation mechanism explained in clause 6.13.2 \"Provisioned mechanism for designating administrative responsibilities and adding third parties in a MExE device\" and the secure downloading of CCMs explained in clause 6.10.1.4 \"Authorised CCM download mechanisms\".\nThe user shall not be able to delete an administrator root public key or certificate.\nThe system shall support a mechanism (as part of a provisioned functionality and/or inherently part of the MExE implementation) allowing the owner of the MExE device to manage the administrator root public key (including the download of a new administrator root public key) as defined in clause 6.13.3.2.1 \"Administrator of the MExE device is the user\". This mechanism shall be secure so that only the owner can use this functionality.\nThe administrator root public key can be downloaded to the MExE device as described in clause 6.13.4 \"Administrator root certificate download mechanism\".\nIf the Administrator root public key is stored in the (U)SIM, the ME shall only read the Administrator root public key from the MExE-(U)SIM when required and shall not store the Administrator root public key from the MExE-(U)SIM on the ME in a manner inconsistent with that detailed in clause 6.6.1.1 \"Caching of root public keys\".\nSee clause 6.10 \"Certificate management\" for the management of Administrator root public keys.\nThe same root public key may be used for both the Administrator role and the operator or manufacturer domain. This facility does not imply any increased right of the manufacturer or operator to take the Administrator role.\nIf the same root public key is used for the operator domain and Administrator role and this root public key is stored on the MExE-(U)SIM (see TS 51.011 [27] and TS 31.102 [39]), there shall be separate entries relating to each use of the root public key in the operator and administrator trusted certificate directory files. These entries in the operator and Administrator trusted certificate directory files may point to the same root public key in the certificate data file.\nIf the root public key to be shared is not stored on the (U)SIM, then procedures relating to this are out of the scope of this specification.",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.13.3",
        "clause_6.13.2",
        "clause_6.10.1.4",
        "clause_6.13.3.2.1",
        "clause_6.13.4",
        "clause_6.6.1.1",
        "clause_6.10",
        "ts_51.011",
        "ts_31.102"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.2",
      "section_id": "6.13.2",
      "section_title": "Provisioned mechanism for designating administrative responsibilities and adding third parties in a MExE device",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the administrator concept described in this clause is optional.\nAll applications in the Third-Party security domain are to be signed by a key which shall be verified back to a Third Party root public key on the MExE device. The Third Party root public keys shall be managed (e.g. addition/mark trusted/mark untrusted) by an administrator that is designated by the owner of the MExE device using the MExE administrator provisioning mechanism. A mechanism is required to be provided to enable the owner of the MExE device to dynamically assign an administrator. The mechanism shall support the following cases:\n-\tthe user is the owner;\n-\tthe owner is at a remote location. In this case the owner could be the operator, a service provider or a third party;\n-\tthe owner of the MExE-(U)SIM wants to be a temporary administrator.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.3",
      "section_id": "6.13.3",
      "section_title": "MExE administrator determination mechanism",
      "content": "The administrator of the MExE device shall be determined by a two part logical process with the first part shown in the flowchart in figure 11 \"MExE administrator determination mechanism\". The second part of the logical process is in figure 12 \"MExE administrator determination mechanism, for MExE-(U)SIM supporting third party certificates\".\nDuring power-up or MExE-(U)SIM insertion event, the provisioned mechanism shall look for an administrator root public key that is stored on the MExE-(U)SIM.",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_11",
        "figure_12"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.3.1",
      "section_id": "6.13.3.1",
      "section_title": "Determining the administrator of the MExE device",
      "content": "If an administrator root public key cannot be found on the MExE-(U)SIM, the provisioned mechanism shall look for one on the MExE device. This leads to the following two cases:\n-\tadministrator root public key is absent\nif the administrator root public key is absent, then the user shall automatically become the administrator of the MExE device.\n-\tadministrator root public key is present\nif an administrator root public key is present, this root public key shall be used for all remote administration authentication, implying that the owner of the administrator root public key is the administrator. Note that the owner of the administrator root public key could be the user.\nFigure 11: MExE administrator determination mechanism",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_11"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.3.2",
      "section_id": "6.13.3.2",
      "section_title": "Determining the administrator of the MExE device, for MExE-(U)SIM supporting third party certificates",
      "content": "The second part of the administrator determination mechanism is subsequently defined (see figure 12 \"MExE administrator mechanism, for MExE-(U)SIM supporting third party certificates \"), and shall be initiated after a power-up or MExE-(U)SIM insertion event is processed.\nThe following clauses 6.13.3.2.1 \"Administrator of the MExE device is the user\" and 6.13.3.2.2 \"Administrator of the MExE device is not the user\" assume that Third Party certificates can be added using the MExE-(U)SIM, however Third Party certificates may be added using a non-(U)SIM approach (e.g. inserted at the time of manufacture, signed package download etc.).",
      "chunk_type": "requirement",
      "cross_references": [
        "figure_12"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.3.2.1",
      "section_id": "6.13.3.2.1",
      "section_title": "Administrator of the MExE device is the user",
      "content": "If the administrator is the user, then a check shall be made to determine whether there is a MExE-(U)SIM. If a MExE-(U)SIM is present, then a check shall then be made to determine whether there is a Third Party or an Administrator certificate containing a root public key in the MExE-(U)SIM. The second part of the administrator determination mechanism shall allow the MExE device to determine (via a format) what type of certificate is present:\n-\tcertificate present - third party (CP-TP)\nIf a Third Party certificate containing a root public key is present in the MExE-(U)SIM then this certificate shall be considered by the MExE device as a Third Party certificate, whilst that valid MExE-(U)SIM application is present in the MExE device. The user shall be queried to allow or disallow the certificate as a Third Party.\n-\tcertificate present - administrator (CP-Admin)\nIf a temporary Administrator certificate containing a root public key is present in the MExE-(U)SIM, the user shall be queried whether to allow the certificate on the MExE-(U)SIM to take temporary control of the third party domain. By temporary control, it is meant that once the card is removed the administrator reverts back to the user administrator settings (i.e. the Administrator becomes the User). The above mechanism implies that the previous configuration settings for the administrator shall be saved, so that they may be restored. If the user disallows the MExE-(U)SIM certificate, the Third Party Domain shall not be able to use any of the network capabilities in the third party domain as identified in the network access section of the security table 5 \"Security domains and actions\".\nIf an administrator certificate is not present on the MExE-(U)SIM and the administrator is the user, the user shall continue to be the administrator and may make use of all functionality.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.3.2.2",
      "section_id": "6.13.3.2.2",
      "section_title": "Administrator of the MExE device is not the user",
      "content": "If the administrator is not the user, then a check is made to determine if there is a MExE-(U)SIM. If a MExE-(U)SIM is present, then a check is made to see if there is a Third Party or an Administrator certificate containing a root public key in the MExE-(U)SIM.\nIf an Administrator certificate containing a root public key is present in the MExE-(U)SIM, then a comparison is made of this certificate's root public key with the Administrator root public key on the MExE device for the following cases:\n-\tCase (a): they are the same;\n-\tCase (b): they are not the same, but the MExE device certificate is cross-certified with the MExE-(U)SIM certificate (a cross-certificate exists on the MExE device);\n-\tCase (c): they are not the same, but the MExE device certificate has a line of trust back to the MExE-(U)SIM certificate domain;\n-\tCase (d): they are not the same.\nIf the owner of the public key in the certificate on the MExE-(U)SIM is to be a temporary administrator (CP-Admin), then in cases (a), (b) and (c), the temporary administrator shall be the owner of the CP-Admin root public key. In case (d), the Third Party domain shall not use any of the network capabilities in the third party domain as identified in the network access section of the security table 5 \"Security domains and actions\".\nIf the certificate is to be a Third Party certificate containing a root public key, then the certificate (CP-TP) shall be verified with the CCM and based on the content and permissions of the CCM, the certificate shall be added to the Third Party list or rejected.\nFigure 12: MExE administrator determination mechanism,for MExE-(U)SIM supporting third party certificates",
      "chunk_type": "general",
      "cross_references": [
        "table_5",
        "figure_12"
      ]
    },
    {
      "chunk_id": "ts_23.057_6.13.4",
      "section_id": "6.13.4",
      "section_title": "Administrator root certificate download mechanism",
      "content": "MExE devices supporting (U)SIMs without certificates shall at least support the following procedure to download the administrator root certificate.\n1.\tUpon sign-up with an administrator the user and administrator will make contact.\n2.\tThe administrator service centre will obtain any required information from the user and inform the user by SMS or other means of the location of the administrator root certificate.\n3.\tThe user will initiate the download of the Administrator root certificate using a signed package.\n4.\tOnce the procedure is complete the MExE device shall compute the hash of the received Administrator certificate containing root public key.\n5.\tThe user will contact the administrator and enters on the MExE device at least the first 8 bytes using decimal value of the hash of the Administrator root public key information provided by the administrator . The MExE device compares the beginning of computed hash value and the abbreviated hash value entered by the user If these two values are the same ,the provisioning process will be complete. If the two values are different this shall be indicated to the user who should inform the administrator of this.\nAlternative methods to download an administrator root certificate may be used where appropriate but must insure that the certificate is received by the MExE device unaltered.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.1",
      "section_id": "7.1",
      "section_title": "Introduction",
      "content": "Classmark 1 MExE devices are based on Wireless Application protocol (WAP).\nThe Wireless Application Protocol is a standard to present and deliver wireless information and telephony services on mobile phones as well as other wireless terminals. Supporting mandatory features of WAP, WAP enabled devices provide access to the World Wide Web based content for small mobile devices.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.1.1",
      "section_id": "7.1.1",
      "section_title": "WAP MExE devices",
      "content": "Support of WAP in a MExE classmark 1 device as detailed in this clause is mandatory.\nWAP MExE devices shall be based on the WAP specifications [6]. In addition to the base specifications in [6], further developments made in the WAP specifications shall form part of this MExE specification.\nWAP MExE devices shall implement the WAP version as specified in reference [6], or a later version, under the condition that the version of WAP is backward compatible with the version specified in reference [6].\nThe existing WAP specification covers security, creation and transfer of WAP executables and content, access, and execution.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.1.2",
      "section_id": "7.1.2",
      "section_title": "High level architecture",
      "content": "The WAP architecture provides a scalable and extensible environment for application development for mobile communication devices. This is achieved through a layered design of the entire protocol stack.\nThe key features of WAP include:\n-\tMarkup language (WML) and a script language (WMLScript) designed to create applications on the small displays of handheld devices. WML does not assume that a QWERTY keyboard or a mouse is available for user input. Unlike the flat structure of HTML documents, WML documents are divided into a set of well defined units of user interactions. One unit of interaction is called a card, and services are created by letting the user navigate back and forth between cards from one or several WML documents. WML has a smaller set of markup tags that makes it more appropriate to implement in handheld devices, than, say, HTML.\n-\tLight-weight protocol stack to minimise the required bandwidth and to guarantee that a maximum number of wireless network types can run WAP applications. For example, GSM SMS/USSD, circuit switched data (CSD), and GPRS.\n-\tA framework for Wireless Telephony Applications (WTA) allows access to telephony functionality such as call control, phone book and messaging from within WMLScript scripts. This allows operators to develop telephony applications integrated into WML/WMLScript services.\nSince WAP is based on a scalable layered architecture, each layer can develop independently of the others. This makes it possible to switch onto new bearers, to use new transport protocols, without major changes in the other layers.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.1",
      "section_id": "7.2.1",
      "section_title": "WAP components",
      "content": "Mandatory and optional components of WAP are specified in the WAP specifications. Services and applications shall be able to determine the presence of optional parts of the functionality.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.2",
      "section_id": "7.2.2",
      "section_title": "Services",
      "content": "WAP is a general purpose application based on World Wide Web (WWW) technologies and philosophies. Many services can be provided to both WAP clients and traditional WWW clients, from the same server. Services are created based on the same information space. The major difference is the user interface. The user interface of WAP services is realised by the Wireless Markup Language, WML [6], and has a menu tree oriented structure, instead of the traditional flat structure of HTML pages.\nTypical WAP services provided to mobile phones may include (this list is not exhaustive):\n-\tNews\n-\tWeather information\n-\tPackage Tracking\n-\tStocks\n-\tTelephony Services\n-\tTime Tables\n-\tAccess to corporate databases\n-\tSports",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.2.1",
      "section_id": "7.2.2.1",
      "section_title": "User interface",
      "content": "The user interface of WAP services is realised by the Wireless Markup Language, WML [6]. WML does not define the user interface itself, the implementation of the browser defines how the WML data is presented to the user (e.g. hyperlinks are blue and underlined). The script language, WMLScript [6], may be used to enhance the standard browsing and presentation facilities of WML with behavioural capabilities, and to access the device and its peripheral functionality.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.2.2",
      "section_id": "7.2.2.2",
      "section_title": "Access points",
      "content": "Services may be hosted on standard HTTP servers and can be created with proven technologies; CGI, Java Servlets. URLs are used to address services.\nThe WAP network topology is shown in figure 13 \"WAP network topology\".\nFigure 13: WAP network topology\nMobile phones access services by sending a request with a URI to the WAP gateway. The URI is used to identify the origin server on which the service is available. The request is sent from the mobile phone by the WAP protocols over one of the available bearer networks. The WAP Gateway is a WAP to HTTP/1.1 proxy that translates the WAP request into an HTTP/1.1 request (from binary form to text). The HTTP/1.1 request is passed on to the server identified by the URI.\nThe HTTP server may have multiple access points to various databases and other services available in the infrastructure network. Once the request has been serviced a response is sent back to the WAP Gateway, which in turn translates it into a WAP response (from text to binary form) and sends it down to the mobile phone.\nNote that WAP does not specify anything \"behind\" the WAP Gateway. However it is assumed that the origin server is an HTTP/1.1 server, and that the WAP Gateway has access to the TCP/IP network on which the origin server is hosted.",
      "chunk_type": "general",
      "cross_references": [
        "figure_13"
      ]
    },
    {
      "chunk_id": "ts_23.057_7.2.2.3",
      "section_id": "7.2.2.3",
      "section_title": "Transferring",
      "content": "The core of WSP [6] is a binary version of the Hypertext Transfer Protocol - HTTP/1.1 [9]. The core function of WSP is the same as for HTTP/1.1. A client sends a request to the server using an appropriate request method with a URI and information about the client. The server responds with a status code and possibly (if success) the requested content.\nThere is a differentiation between an origin server and a WSP server. The origin server is where the content is stored, and the WSP server is where the WSP session terminates. The WSP server is also typically the WAP gateway.\nIn addition to the basic HTTP/1.1 function, WSP has some functions that can not be found in HTTP/1.1, they are:\n-\tSession Establishment and ManagementBefore a request is sent, the WSP client can establish a session with the server. During session establishment the client and server exchange static headers. The header are cached for the duration of the session, thus they need to be sent in every single request within the session. Static headers may be: Accept headers, User-agent header, etc. In addition, capabilities such as supported optional protocol functions, the maximum service data unit the protocol can handle, the maximum number of simultaneously outstanding requests, supported header code pages, etc. can also be exchanged during session establishment.\n-\tHeader encodingWSP is using a compact binary header encoding to minimise the number of bytes sent over the air.\n-\tAsynchronous transactionsWSP allows for multiple asynchronous transactions, that is, unordered transactions.\n-\tTransaction AbortWSP support abortion of an outstanding transaction.\n-\tDatagram transportWSP together with the helper protocol Wireless Transaction Protocol, WTP [9], can run over a datagram transport such as SMS or UDP. The WDP can also be used for non-IP bearers.\n-\tPushWSP supports the push of data from server to client. This can be done within and outside of a session. It can be done with and without acknowledgement from the client. Push of indications down to mobile phones is an essential function many wireless applications.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.2.3.1",
      "section_id": "7.2.2.3.1",
      "section_title": "WSP and HTTP/1.1 Proxy Function",
      "content": "The WAP Architecture is a client-proxy-server architecture. The client is typically a mobile phone, the data gateway is the WAP Gateway and the server is the origin server (a standard HTTP server). The WAP Gateway translates the binary WSP header into text formatted HTTP/1.1 headers and passes them on to the origin server. In the opposite direction the WAP Gateway translates the text formatted HTTP/1.1 header into binary WSP headers. If the WAP Gateway receives a header it does not recognise it simply passes it on as an unknown header. Unknown headers that are not part of the WSP Header Code page or Extended code pages (negotiated at session establishment) are sent in plain text for the client to interpret as best it can.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.3",
      "section_id": "7.2.3",
      "section_title": "WAP charging support",
      "content": "The WAP protocol suite in [6], with upgrades as identified in this specification, does not specify mechanisms for charging (e.g. charging records) or subscription management. WAP is bearer independent and is running as an application on top of the bearer network. However the WAP architecture suggests that appropriate charging information can be collected in the WAP Gateway; the point of convergence for all WAP traffic.\nThe WAP security protocol can be used for authentication of the subscriber.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.2.4",
      "section_id": "7.2.4",
      "section_title": "CC/PP over WSP (Classmark 1)",
      "content": "In Classmark 1, according to the WAP User Agent Profile Specification [17], the CC/PP description is encoded with WBXML [45] after which it is carried over by WSP [17].",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.3.1",
      "section_id": "7.3.1",
      "section_title": "Call control",
      "content": "WAP telephony services are written in WML and WMLScript. The WAP Telephony API (WTAI) exposes telephony functions to service authors as a set of libraries. The WTAI function libraries can be accessed from WML as URIs, and from WMLScript as script functions. The following libraries have been specified:\n-\tPublic libraryThis includes functions that are available in all networks, and can be provided by any third party service provider; and not only the network operator. The user must acknowledge the function before it is carried out. Functions have been specified, which can be used e.g. to initiate a mobile originated call, send DTMF tones and add phonebook entry.\n-\tNetwork Common libraryThis includes functions that are available in all networks, and can be provided only by the network operator. E.g. functions for advanced call control, accessing the phonebook, and sending and reading network text (SMS) have been specified.\n-\tNetwork Specific libraryFunctions that are only available in certain types of networks, and can be provided only by the network operator. For GSM, e.g. functions for call reject, call hold, call transfer, multiparty, getting location information and sending USSD have been specified.\nThe WML and WMLScript author uses the WTAI libraries to create web services for mobile phones with telephony capabilities.\nCall control shall be performed using WTA.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_7.3.2",
      "section_id": "7.3.2",
      "section_title": "Local phonebook",
      "content": "WAP Telephony API (WTAI) is used to access the information stored in the phonebook on the MExE device or the (U)SIM. Phonebook entries consist of name, number and identity. Phonebook entries can be read, written, deleted, and searched for.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.1",
      "section_id": "8.1",
      "section_title": "Introduction",
      "content": "Classmark 2 specifies Personal Java enabled devices with the addition of the JavaPhone API.\nThe Personal Java [3] application environment is the standard Java environment optimised for consumer electronic devices designed to support World Wide Web content including Java applets. The Personal Java API is a feature level subset of J2SE with some Java packages optional and some API modifications necessary for the needs of small portable devices (for example an optimised version of the Abstract Windowing Toolkit targeted to small displays).\nJavaPhone [4] is a vertical extension to the Personal Java platform that defines APIs for telephony control, messaging, address book and calendar information, etc.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.1.1",
      "section_id": "8.1.1",
      "section_title": "Classmark 2 MExE devices",
      "content": "Support of PersonalJava in a MExE classmark 2 device as detailed in this clause is mandatory.\nMExE Classmark 2 devices shall be based on the API for Personal Java, which defines the required and optional components of Personal Java /JavaPhone APIs that shall be used to realise a Classmark 2 compliant MExE device.\nThe APIs primarily define the functions available to a Personal Java based MExE device such that services (specified in the form of Java classes and interfaces) can control such a MExE device in a standardised way.\nMany aspects of the MExE Classmark 2 API specification are optional. Services and applications shall be able to determine the presence of optional parts of the functionality. When optional parts of the functionality are implemented, the API shall be supported.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.1.2",
      "section_id": "8.1.2",
      "section_title": "High level architecture",
      "content": "Figure 14: Basic functional architecture of a PersonalJava MExE device\nThe functional architecture of a Java MExE classmark 2 device is shown in figure 14 \"Basic functional architecture of a PersonalJava MExE device\". Java applets, applications, and services access functionality via the MExE PersonalJava API. The MExE PersonalJava API is based on a combination of optional Java APIs and the Wireless Profile of the JavaPhone API [4]. The JavaPhone API is based on the PersonalJava API [3].",
      "chunk_type": "general",
      "cross_references": [
        "figure_14"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.2.1.1",
      "section_id": "8.2.1.1",
      "section_title": "Optional Java packages",
      "content": "The use of Java encourages development of modular interfaces and minimal required functionality. Additional functionality is provided by optional APIs specified in terms of the Java language. Java packages are containers for the highest level of functionality in the Java language. In some cases, optional Java packages are specified in terms of Java classes and interfaces. Classes and interfaces are elements contained inside packages.\nThe following table 9 \"Optional Java packages of the Wireless Profile of the JavaPhone APIs\" specifies the defined optional Java packages of the Wireless Profile of the JavaPhone APIs [4]. Within some of the packages, certain classes and methods may be individually specified as optional by the JavaPhone API specification.\nWhere a mandatory package is identified, it is implicit that any packages called by that mandatory package are also mandatory.\nTable 9: Optional Java packages of the Wireless Profile of the JavaPhone APIs\nJavaPhone API\nJava package\nOptional/Mandatory\nAddressbook\nJavax.pim.addressbook\nMandatory\nUser Profile\nJavax.pim.userprofile\nMandatory\nCalendar\nJavax.pim.calendar\nMandatory\nNetwork\nJava.net\nMandatory\nDatagram\nJavax.net.datagram\nMandatory\nPower Monitor\nJavax.power.monitor\nMandatory\nPower Management\nJavax.power.management\nOptional\nInstall\nJavax.install\nOptional\nCommunications\nJava.comm\nOptional\nSSL\nJavax.net.ssl\nOptional\nJTAPI Core Package\nJavax.telephony\nMandatory\nJTAPI Core Capabilities Package\nJavax.telephony.capabilities\nMandatory\nJTAPI Core Events Package\nJavax.telephony.events\nMandatory\nJTAPI Call Control Package\nJavax.telephony.callcontrol\nOptional\nJTAPI Call Control Capabilities Package\nJavax.telephony.callcontrol.capabilities\nOptional\nJTAPI Call Control Events Package\nJavax.telephony.callcontrol.events\nOptional\nJTAPI Phone Package\nJavax.telephony.phone\nOptional\nJTAPI Phone Capabilities Package\nJavax.telephony.phone.capabilities\nOptional\nJTAPI Phone Events Package\nJavax.telephony.phone.events\nOptional\nJTAPI Mobile Package\nJavax.telephony.mobile\nMandatory\nJava.math\nOptional\nJava.rmi\nOptional\nJava.rmi.dgc\nOptional\nJava.rmi.registry\nOptional\nJava.rmi.server\nOptional\nJava.security\nOptional\nJava.security.interfaces\nOptional\nJava.sql\nOptional\nJava.io\nOptional",
      "chunk_type": "general",
      "cross_references": [
        "table_9"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.2.1.2",
      "section_id": "8.2.1.2",
      "section_title": "Required and optional PersonalJava APIs",
      "content": "MExE classmark 2 devices shall support the PersonalJava specification [3]. The PersonalJava APIs provide a standardised and readily implementable execution environment as a means for applications, applets, and content:\n-\tto access and personalise the user interface via the java.awt packages;\n-\tto utilise both Internet and Intranet connections via the java.net package.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.2.1.3",
      "section_id": "8.2.1.3",
      "section_title": "Required and optional JavaPhone APIs",
      "content": "The JavaPhone APIs extend the PersonalJava APIs to provide functionality unique to telephony devices. MExE classmark 2 devices shall support the Wireless Profile of the JavaPhone API specification [4]. MExE classmark 2 devices shall support all APIs specified as required by the Wireless Profile in the JavaPhone API specification. All APIs that are optional in the Wireless Profile shall be optional in MExE classmark 2 devices.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.2.1.3.1",
      "section_id": "8.2.1.3.1",
      "section_title": "Application installation",
      "content": "MExE classmark 2 devices shall support the following JAR file manifest entries (as described in the JavaPhone specification) as described below:\n-\tImplementation-Title\nthe Implementation-Title shall be used in any textual description of the application which is displayed in the UI element used to launch the application. E.g. the text displayed with an icon.\n-\tMain-Icon\nthe use of icons to launch applications is optional, however if icons are used as elements to launch the application, then the icon file within the JAR file named by the Main-Icon attribute shall be displayed, and may be scaled if desired.\n-\tMain-Class and Class-Path\nwhen the application is launched, the MExE Java VM shall be supplied with the classpath and shall call the main() method in the class named by the Main-Class attribute.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.2.1.3.2",
      "section_id": "8.2.1.3.2",
      "section_title": "Power",
      "content": "MExE classmark 2 devices shall support the Power Monitor package (javax.power.monitor) as specified by the JavaPhone API to access the power level of the MExE device and receive notifications concerning changes in power states.\nNote that the Power Monitor package does not specify the minimum required events that should be generated under certain circumstances. MExE classmark 2 device shall at least implement the following event generation:\n-\tBatteryCritical\nshall be generated when the battery is at a critically low level.\n-\tBatteryNormal\nshall be generated when the battery is no longer low.\nAll the other event generation should be supported by the implementation.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.2.1.3.3",
      "section_id": "8.2.1.3.3",
      "section_title": "Datagram recipient addressing",
      "content": "The syntax described in Concrete Addressing [4] specifies the format to be used for raw text-only GSM SMS messages, UDP datagram via IP, and WAP datagram via GSM SMS message(s).\nAs a minimum, the formats above shall be supported if the MExE device supports the relevant bearer/transport combination.\nNOTE:\tFor the purposes of this clause, \"GSM SMS\" means SMS as defined by the 3GPP specifications including TS 23.040 [53].",
      "chunk_type": "general",
      "cross_references": [
        "ts_23.040"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.2.1.4",
      "section_id": "8.2.1.4",
      "section_title": "Required and optional MExE PersonalJava  APIs",
      "content": "MExE classmark 2 devices shall not be required to support any other Java APIs.\nMExE classmark 2 devices may optionally support any other Java APIs which comply with the MExE security requirements in table 5 \"Security domains and actions\", such as:\n-\tOCF SmartCard API OpenCard, available from [21]. If the MExE device supports smartcards other than the (U)SIM, and the smartcard is open to 3rd party applications, then the opencard.core.terminal section of the OpenCard API may be used to access the card.",
      "chunk_type": "requirement",
      "cross_references": [
        "table_5"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.2.1.5.1",
      "section_id": "8.2.1.5.1",
      "section_title": "Network protocol support",
      "content": "Support for network protocols in MExE classmark 2 devices is specified in the following table 10 \"Support for network protocols\":\nTable 10: Support for network protocols\nProtocol\nOptional/Mandatory\nHTTP/1.1 [9]\nMandatory\nHTTPS\nMandatory\nGopher\nOptional\nftp\nOptional\nmailto [25]\nMandatory\nFile\nOptional",
      "chunk_type": "general",
      "cross_references": [
        "table_10"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.2.2",
      "section_id": "8.2.2",
      "section_title": "CC/PP over HTTP (Classmark 2)",
      "content": "In Classmark 2 the CC/PP is carried over by using CC/PP over HTTP [15] and optionally CC/PP over WSP [17].",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.2.3",
      "section_id": "8.2.3",
      "section_title": "Java charging support",
      "content": "MExE Java devices do not require any additional specific charging (e.g. charging records) or subscription management. Java usage of network resources is bearer independent and runs as applications on top of the bearer network.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.3",
      "section_id": "8.3",
      "section_title": "Security",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the Java security described in this clause is optional.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.3.1",
      "section_id": "8.3.1",
      "section_title": "PersonalJava security",
      "content": "There are two types of Java security [20]: sandbox, and fine grain.\nThe sandbox model [18] has just one domain; there is no concept of a partly trusted domain. The sandbox meaning of \"trusted\" means it is totally unrestricted to access all system resources.\nUsing the sandbox system, each MExE security domain shall be implemented as running in a sandbox, configured with different privileges corresponding to those of the domain. If the security domains are not supported then the Java sandbox security model shall be supported and it shall be configured for untrusted MExE executables support only, as defined in clause 6.3 \"MExE executable permissions\". Using the fine grain Java security system [19], each MExE security domain will be a set of constraints within which a Java fine grain security domain can be configured.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.3"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.3.1.1",
      "section_id": "8.3.1.1",
      "section_title": "Java applet certification in PersonalJava",
      "content": "Support for trusted applets is optional. Although a Java application shall be executed in a trusted domain if its certification can be validated, a Java Applet will not necessarily be executed in a trusted domain even if it does have a valid signature. It will be up to the implementers to decide if \"trusted\" Applets will be supported. (In certain implementations, all Applets may be always executed as \"untrusted\".)",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.3.1.2",
      "section_id": "8.3.1.2",
      "section_title": "Java application signature verification in PersonalJava",
      "content": "The verification of the certification of the application or applet shall be performed as described in clause 6.6 \"Root Public keys\" and clause 6.13.2 \"Provisioned mechanism for designating administrative responsibilities and adding third parties in a MExE MS\".",
      "chunk_type": "requirement",
      "cross_references": [
        "clause_6.6",
        "clause_6.13.2"
      ]
    },
    {
      "chunk_id": "ts_23.057_8.3.1.3",
      "section_id": "8.3.1.3",
      "section_title": "Java loading native libraries in PersonalJava",
      "content": "The MExE Java VM may be able to load native libraries that are intrinsically part of the MExE device implementation and MExE native libraries. The MExE Java VM shall not load other native libraries.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_8.3.2",
      "section_id": "8.3.2",
      "section_title": "Installing MExE native libraries",
      "content": "A signed native library whose signature verifies as describe in clause 6.6.2 \"Manufacturer root public key\" as belonging to the Manufacturer Domain may be installed as a \"MExE native library\".\nA MExE native library may be called by a MExE executable, and shall not compromise the MExE security system.\nSupport of MExE native library signed package installation is optional.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.6.2"
      ]
    },
    {
      "chunk_id": "ts_23.057_9.1",
      "section_id": "9.1",
      "section_title": "Introduction",
      "content": "Classmark 3 MExE devices are based on the Connected Limited Device Configuration (CLDC) with the Mobile Information Device Profile (MIDP).\nJava 2 Micro Edition (J2ME) is a version of the Java 2 platform targeted at consumer electronics and embedded devices. CLDC consists of a virtual machine and a set of APIs suitable for providing tailored runtime environments. The J2ME CLDC is targeted at resource constrained connected devices (e.g. memory size, processor speed etc.).",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.1.1",
      "section_id": "9.1.1",
      "section_title": "Classmark 3 MExE devices",
      "content": "Support of CLDC/MIDP in a MExE classmark 3 device as detailed in this clause is mandatory.\nMExE Classmark 3 devices are based on the J2ME Connected Limited Device Configuration (CLDC) with the Mobile Information Device Profile (MIDP).\nAll APIs defined by CLDC and MIDP shall be supported by a MExE classmark 3 device.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.1.2",
      "section_id": "9.1.2",
      "section_title": "High level architecture",
      "content": "Figure 15: Functional architecture of a Classmark 3 MExE device\nThe functional architecture of a Classmark 3 MExE device is shown in figure 15 \"Functional architecture of a Classmark 3 MExE device\". The MExE API is based on the combination of CLDC APIs and MIDP APIs. OEM specific APIs are outside the scope of MExE specification. CLDC and MIDP APIs are defined in J2ME [34] and [35].",
      "chunk_type": "general",
      "cross_references": [
        "figure_15"
      ]
    },
    {
      "chunk_id": "ts_23.057_9.1.3",
      "section_id": "9.1.3",
      "section_title": "High level functionality",
      "content": "J2ME CLDC and MIDP addresses  a large market of resource-constrained devices and is aimed to provide complete end-to-end solution for creating dynamically extensible networked products and applications. It allows the use of Java programming language as the standard platform for secure delivery of dynamic content for the extensible next‑generation devices.\nIn order to fit into various types of the devices and support extensibility, J2ME defines in Configuration a minimum platform with a virtual machine features and minimum libraries which are available on all devices of similar class. In a Profile J2ME addresses the specific demand of a certain category of the devices allowing additional APIs. Profile is implemented on top of configuration (see figure 15 \"Functional architecture of a Classmark 3 MExE device\"). Classmark 3 MExE device shall be based on the following types of configuration and profile: Connected Limited Device Configuration (CLDC) and Mobile Information Device Profile (MIDP).",
      "chunk_type": "general",
      "cross_references": [
        "figure_15"
      ]
    },
    {
      "chunk_id": "ts_23.057_9.2.1",
      "section_id": "9.2.1",
      "section_title": "Connected Limited Device Configuration (CLDC)",
      "content": "Classmark 3 devices shall support CLDC specification [34].\nCLDC provides only high level libraries without focus on any specific device categories. Defining \"the lowest common denominator\" of Java technology all features included in CLDC must be generally applicable to a wide variety of the devices. CLDC does not address to a certain device category. Such features are specified in a profile. CLDC does not define any optional features.\nThe classes provided by CLDC are either subset of J2SE (Standard Edition) classes or CLDC specific classes which can be mapped onto J2SE. Classes belonging to the packages: Java.io, Java.lang, Java.util are a subset of corresponding Java2SE libraries, while classes specified in Javax.microedition.io are specific CLDC classes, which, however, can be mapped onto Java2SE.\nJavax.microedition.io provides generic connection framework for supporting input/output and networking in a generalized and extensible manner. The framework is a functional subset of Java2SE classes which can be mapped to common low-level hardware or to any Java2SE implementation. It does not provide a set of different kinds of abstractions for different forms of communications, but rather a set of related abstractions are used at the application programming level.\nThe framework  uses a hierarchy of Connection interfaces that group together classes of protocols with the same semantics. The actual supported protocols or implementation of the specific protocols is outside the scope of CLDC Generic Connection Framework and is maintained at the profile level.\nThe basic set of available Connection interfaces is the following:\n-\tConnection;\n-\tContentConnection;\n-\tDatagram;\n-\tDatagramConnection;\n-\tInputConnection;\n-\tOutputConnection;\n-\tStreamConnection;\n-\tStreamConnectionNotifier",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.2",
      "section_id": "9.2.2",
      "section_title": "Mobile Information Device Profile (MIDP)",
      "content": "MExE classmark 3 devices shall support MIDP specification [35]. MIDP is based on CLDC. Some of the features of CLDC are modified or extended by MIDP [35].",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.2.1",
      "section_id": "9.2.2.1",
      "section_title": "Networking",
      "content": "While CLDC specifies only a generic Connector used for all types of connections, MIDP extends connectivity support by providing support of the subset of the HTTP protocol. HttpConnection API provides the additional functionality to set request header, parse response headers and perform HTTP specific functions. The API must support RFC 2396 [40] and RFC 2616 [41].\nThe MIDP does not provide support for datagrams. If a Datagram API is to be implemented, the DatagramConnection interface defined in CLDC shall be used.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.2.2",
      "section_id": "9.2.2.2",
      "section_title": "MID Applications (MIDlet)",
      "content": "A MIDP application (or MIDlet) uses the APIs defined by the MIDP and CLDC specifications. One or more MIDlets may be packed in one JAR file. Sharing of data between MIDlets is controlled by the individual APIs (e.g. Record Management System API).\nApplication Management Software provides an environment in which a MIDlet is installed, started, stopped and uninstalled. Each JAR file can be accompanied by an Application Descriptor (a text file consisting of name/value pairs), which is used to manage MIDlet and is used by MIDlet for configuration specific attributes. With the help of descriptor file, verification prior to software download is done to ensure that the MIDlet is suited to the device: Java Application Manager checks if the application already exists on the device, verifies the version number (whether an update is needed or not) and reading the JAR-file-size information ensures that there is sufficient amount of memory on the device to save the file. The minimum attributes which the Application Descriptor must contain are the following:\n-\tMIDlet-Name;\n-\tMIDlet-Version;\n-\tMIDlet-Vendor;\n-\tMIDlet-Jar-URL;\n-\tMIDlet-Jar-Size.\nMandatory and optional attributes are defined in [35]. If the mandatory attributes are not identical in the descriptor file and in the manifest file, the JAR file shall not be installed.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.2.3",
      "section_id": "9.2.2.3",
      "section_title": "MIDlet Suites",
      "content": "MIDlets may be packaged together in a single JAR file, forming a MIDlet suite. MIDlets in a MIDlet suite share the classes in the JAR file and the persistent storage is the MIDP Record Management System.\nMIDlets in a MIDlet suite may be discovered, transferred, installed and deleted together as a packaged set of MIDlets.  The deletion of a MIDlet in a MIDlet suite may result in the deletion of the entire MIDlet suite, in which case the user shall be notified of the deletion of the MIDlet suite.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.2.4",
      "section_id": "9.2.2.4",
      "section_title": "Record Storage",
      "content": "The MIDP provides a mechanism for MIDlets to persistently store data and later retrieve it. The persistent storage mechanism is called Record Management System. Record stores are created in platform-dependent locations and are not exposed to MIDlets. The record store maintains a version number, which is incremented each time the content of the record store is modified.  A record store is shared between all MIDlets in a MIDlet suite.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.3",
      "section_id": "9.2.3",
      "section_title": "Required and optional MExE APIs",
      "content": "Support of any other Java APIs besides CLDC and MIDP is not mandated in a Classmark 3 MExE device. A Classmark 3 MExE device may optionally support any other Java APIs which comply with the MExE security requirements.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.4",
      "section_id": "9.2.4",
      "section_title": "Service discovery and management",
      "content": "A browser installed on a MExE device should support MIME type text/vnd.sun.j2me.app-descriptor. This support allows the user to browse and discover a Java application which can then be downloaded. Capability negotiation information in the request header can determine which application to present.  MIDlets and MIDlet suites should be indicated to the user, and if the MExE device has a display, may be presented as an icon and a tag or as a textual tag only.\nA JAD file can be downloaded and used to determine if the MIDlet is deemed suitable for download and installation. If it is suitable, the JAR file can be downloaded and installed. If not, the MExE device should be able to prompt the user so that the user might choose to take such actions such as deletion of some existing applications if there is not enough space to install the new application. If the application chosen to be installed already exists on the device, the user should be notified so that he could take further actions either to download the chosen version or to retain the existing one.\nThe user should be able either to launch the MIDlet immediately or later.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_9.2.5",
      "section_id": "9.2.5",
      "section_title": "Transfer of capability negotiation information in Classmark 3",
      "content": "In Classmark 3 the CC/PP is carried over by using CC/PP over HTTP [15] and optionally CC/PP over WSP [17].\nAlso MIDP itself provides a simple mechanism for applications to indicate the capabilities they require. The Java Application Descriptor File (JAD), which is a file that can be stored and downloaded separately to the application itself, contains information such as application name, version number, JAR file size, data storage requirements etc. The Application Descriptor can accompany the JAR file and can be used to ensure prior to the actual application download that the application suits the MExE device. The JAD file is described in more details in the clause 9.2.2.2 \" MID Applications (MIDlet)\".",
      "chunk_type": "general",
      "cross_references": [
        "clause_9.2.2.2"
      ]
    },
    {
      "chunk_id": "ts_23.057_9.3",
      "section_id": "9.3",
      "section_title": "Security",
      "content": "If the 3 MExE security domains defined in clause 6.1 \"Generic security\" are not supported, then the Java security described in this clause is optional.",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1"
      ]
    },
    {
      "chunk_id": "ts_23.057_9.3.1",
      "section_id": "9.3.1",
      "section_title": "CLDC security",
      "content": "A Java execution environment running on a Classmark 3 MExE device shall comply with the security requirements defined in the CLDC specification [34]. That is, it shall comply with both the low-level virtual machine security requirements and the application-level security requirements.\nThe application-level CLDC security requirements define a sandbox security model where Java classfiles are verified. Java APIs available to the application are limited to those APIs which have been defined by the configuration and profiles supported by the MExE device.  Downloading and management of the Java applications on the MExE device takes place at the native level, no user-definable Java class loaders are provided and the set of APIs available to a MIDlet is closed.\nThe low-level CLDC virtual machine security requirements define a Java classfile pre-verification mechanism which takes place off- MExE device (e.g. on the server prior to downloading) and inserts a special attribute called a \"stack map\" into class files to facilitate runtime verification of the same classfiles.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_10.1",
      "section_id": "10.1",
      "section_title": "Introduction",
      "content": "Classmark 4 specifies CLI Compact Profile enabled devices.\nThe CLI [50] environment is a programming language neutral, OS and CPU portable environment. The CLI can support applications and services written in a wide range of programming languages, for example Visual Basic, ECMAScript and C#. The CLI Compact Profile specifies a minimal set of class libraries, supporting common runtime library features as well as web services infrastructure, including HTTP [9], TCP/IP, XML [36] & SOAP [51]. Such devices not only may have limited memory and CPU capability, but also limited (or no) display.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_10.1.1",
      "section_id": "10.1.1",
      "section_title": "High level architecture",
      "content": "Figure 16: Basic functional architecture of a CLI MExE device\nThe functional architecture of a CLI MExE classmark 4 device is shown in Figure 16 \"Basic functional architecture of a CLI MExE device\". CLI based applications and services access functionality via the MExE CLI Compact Profile API. Additional CLI APIs and OEM specific APIs are outside the scope of the MExE specification. The CLI Compact Profile APIs are defined in CLI specified by ECMA [50].",
      "chunk_type": "general",
      "cross_references": [
        "figure_16"
      ]
    },
    {
      "chunk_id": "ts_23.057_10.2",
      "section_id": "10.2",
      "section_title": "Non security",
      "content": "Support of CLI Compact Profile in a MExE classmark 4 UE as detailed in this clause is mandatory.\nMExE Classmark 4 devices shall be based CLI Compact Profile specifications [50]. The specifications define the runtime environment and APIs available to a CLI based MExE device such that services (specified in the form of language independent classes and interfaces) can control such a device in a standardised way.\nAll mandatory components of the CLI compact profile shall be included. Additional CLI APIs or OEM APIs may be available. It shall be possible for services and applications to determine the presence of additional parts of the functionality. When an additional optional CLI component is implemented, the component shall be fully implemented.",
      "chunk_type": "requirement",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_10.2.1",
      "section_id": "10.2.1",
      "section_title": "High level functionality",
      "content": "CLI provides a language-neutral, CPU and OS portable, secure infrastructure for executing applications and services that interoperate seamlessly with highly available web services. The CLI Compact Profile provides a mobile client-focussed subset of these services on a broad market of connected devices. Using multiple programming languages for application and service creation allows adoption of a large pool of programming talent, as well as interoperability between existing service components.\nFunctionality is exposed to applications and services in the form of classes and interfaces. Classes can be written in any supported language. APIs can be exposed to the developer using the language syntax of choice. Classes and interfaces are collected into namespaces, which aim to represent a coherent, mutually-dependant set of functionality.\nThe following Table 11 \"CLI Compact Profile Namespaces\" specifies the defined mandatory namespaces, i.e. the namespaces defined in the CLI Compact Profile containing classes which are required for CLI Compact Profile conformance.\nTable 11: CLI Compact Profile Namespaces\nCLI Compact Profile Namespaces\nSystem\nSystem.Collections\nSystem.Globalization\nSystem.IO\nSystem.Text\nSystem.Threading\nSystem.Runtime.CompilerServices\nSystem.Reflection\nSystem.Net\nSystem.XML\nThe namespaces outlined in Table 11 define the core of the CLI programming model.  The System namespace defines data types, including simple data types such as integers, collections such as arrays, and string data types with methods for textual manipulation. System.Globalization enables applications to adapt at runtime to user and cultural UI preferences by modifying list sorting order, currency symbol selection, date and calendar formats, input methods, and language presentation within text strings.  The programming model supports threads, with thread manipulation primitives defined in System.Threading.  System.Reflection enables programmatic inspection of application metadata such as class structure, properties, and data types on method parameters.  System.Net includes support for transport-independent sockets, HTTP connections, and infrastructure for consuming web services.  System.XML enables simple parsing and construction of XML objects.",
      "chunk_type": "general",
      "cross_references": [
        "table_11"
      ]
    },
    {
      "chunk_id": "ts_23.057_10.2.2",
      "section_id": "10.2.2",
      "section_title": "Network protocol support",
      "content": "Support for network protocols in MExE classmark 4 devices is specified in the following Table 12 \"Support for network protocols in Classmark 4 devices\":\nTable 12: Support for network protocols in Classmark 4 devices\nProtocol\nOptionality\nHTTP/1.1 [9]\nMandatory\nHTTPS\nMandatory\nSOAP [51]\nMandatory\nGopher\nOptional\nftp\nOptional\nmailto [25]\nOptional\nFile\nOptional",
      "chunk_type": "general",
      "cross_references": [
        "table_12"
      ]
    },
    {
      "chunk_id": "ts_23.057_10.2.3",
      "section_id": "10.2.3",
      "section_title": "Power Management",
      "content": "MExE Classmark 4 devices have no application or service accessible APIs to detect the power level of the device. Classmark 4 applications or services may be paused by the MExE device if power passes below a certain threshold. Such an activity is implementation dependant.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_10.2.4",
      "section_id": "10.2.4",
      "section_title": "CLI charging support",
      "content": "MExE CLI devices do not require any additional specific charging (e.g. charging records) or subscription management. Use of network resources from a CLI application or service is bearer independent and runs as applications on top of the bearer network.",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_10.2.5",
      "section_id": "10.2.5",
      "section_title": "CC/PP over HTTP or WSP (Classmark 4)",
      "content": "In Classmark 4 the CC/PP is carried over by using CC/PP over HTTP [15] and optionally CC/PP over WSP [17].",
      "chunk_type": "general",
      "cross_references": []
    },
    {
      "chunk_id": "ts_23.057_10.3.1",
      "section_id": "10.3.1",
      "section_title": "CLI Security",
      "content": "Support of CLI security in a MExE classmark 4 device, as detailed in this clause, is mandatory.\nThe CLI specification includes a detailed algorithm to verify the safety and integrity of CLI application code, known as \"application verification\" [50]. An application is either verified as \"safe\" or \"unsafe\". The result of the application verification process is presented to the rest of the CLI runtime environment before program execution. This is distinct from the certificate and signature verification that MExE performs before executing an application inside the MExE environment.\nApplications that are verified as unsafe may contain code that could potentially access the environment in an unauthorized manner. For example, code that uses pointer arithmetic or accesses arrays using out-of-bounds indices would be deemed unsafe. An unsafe application shall not be permitted to execute in the MExE environment. Once an application is verified as safe, this information is passed on to the rest of the CLI runtime environment, which will then apply the MExE security policy, as specified under clause 6.1, \"Generic Security\".\nThe CLI runtime environment may be able to load libraries that are intrinsically part of the MExE device implementation. Such intrinsic libraries may contain unsafe code, however other libraries containing unsafe code are prohibited.\nAnnex A (normative):MExE profile of PKCS#15\nA.1\tPKCS#15 certificate object attributes presentation\nDetails from PKCS#15 [32] in this Annex A.1 \"PKCS#15 certificate object attributes presentation\" are for information only.\nA.1.1\tObject common attributes\nLabel\thuman readable label to describe the certificate\nFlags\tindicates whether the object is private (e.g. CHV authentication request), whether the object is read only.\nAuthentication object identifier\ta cross-reference back to the authentication object, which describes the properties of a CHV, used to protect this object.\nA.1.2\tCertificate common attributes\nidentifier\tthe identifier is used for correlation between the public key contained in the certificate and the associated private key.\nAuthority\tindicates whether the certificate is for an authority (i.e. CA or AA) or not.\nRequest identifier\tused to search a certificate : Issuer and serial number SHA-1 hash, or issuer public key SHA-1hash, or public key subject SHA-1 hash.\nThumbprint\tused as secure way to verify that no one has tampered with a certificate: hash on to be signed certificate (internet). MExE uses the thumbprint to enable or disable a certificate through the certificate configuration message (CCM).\nA.1.3\tCertificate attributes\nType of certificate\tindicates the type of certificate: WTLS, X509, SPKI, PGP, X9.68.\nValue\tdirect value or indirect file path or URL.\nMExE only supports storage of WTLS, X509, X9.68 certificates.\nA.1.4\tSpecific X.509 certificate attributes\nFor information see PKCS#15 [32].\nA.2\tMExE profile of PKCS#15\nPKCS15CommonObjectAttributes.label must be present. The value content is unspecified.\nPKCS15CommonObjectAttributes.Flag must be present. The value shall be private, not modifiable by MExE device.\nPKCS15CommonObjectAttributes.Authentication must be present. The value shall be \"CHV1\". The certificates files are protected by CHV1, because MExE need also IMSI to manage domains availability.\nPKCS15CommonCertificateAttributes.Id must be present. The value content is unspecified.\nPKCS15CommonCertificateAttributes.Authority must be present if and only if certificate is a CA certificate. The value is true.\nPKCS15CommonCertificateAttributes.RequestId must be at least present if certificate is an operator or third party root certificate. The value shall be the same as the ones used in the issuer/authority key identifier field of the certificates, provided by this issuer (as in RFC 2459 [43]). The aim of this attribute is to give a easy way to search a key issuer of a received certificate without reading all certificates content.\nPKCS15CommonCertificateAttributes.Thumbprint must be at least present if certificate is a third party root certificate. The value shall be the same as the ones used in CCM. The aim of this attribute is to give a easy way to search a certificate with reference included in CCM message.\nDomain attribute presence and value shall be added as soon as it will be available in PKCS#15 v1.1.\nPKCS15(type)CertificateAttributes.value must be present Value is a indirect file path (path, index, offset). Index and offset default value is 0.\nSpecific X509 attributes are not supported:\nPKCS15X509CertificateAttributes.subject must not be present.\nPKCS15X509CertificateAttributes.issuer must not be present.\nPKCS15X509CertificateAttributes.serialNumber must not be present.\nThe MExE device shall recognise all optional present fields above. The MExE device shall accept and ignore all unused fields or new field extensions.\nA.3\tCoding and storage in MExE-(U)SIM\nSee detail of file hierarchy and file properties in (U)SIM document TS 51.011 [27] and TS 31.102 [39].\nSince the domain attribute is not available in PKCS#15 v1.0, MExE creates one directory file for each trusted domain. If the domain attribute is available in the next PKCS#15 versions, for future new domains, MExE may create a common directory file. See abstract syntax definition and coding detail in PKCS#15 document [32].\nThe address of the certificate descriptor Elementary File is fixed.\nAccording to PKCS#15 [32] clause 6.6 \"Certificates\" , the contents of a certificate descriptor Elementary File must be the value of the DER encoding of a SEQUENCE OF PKCS15Certificate (i.e. excluding the outermost tag and length bytes).\nThe address of the certificate data Elementary File is unspecified.\nAccording to PKCS#15 [32] clause 6.6 \"Certificates\", the certificate data value is coded according to the related certificate type (e.g. DER for X5.09, base64 for SPKI and PGP, WTLS network format for WTLS, DER or PER for X9.68).\nAnnex B (informative):PKCS#15 certificate objects ASN1 expanded syntax extract\n{  -- sequence of certificate\nx509Certificate,[0] x509AttributeCertificate,[1] spkiCertificate, [2] pgpCertificate, [3] wtlsCertificate,[4] x9-68Certificate : {\ncommonObjectAttributes {\nlabel  \"\" UTF8 string OPTIONAL,\nflags  {private (0), modificable (1)} bit string OPTIONAL, --\nauthId  octet string OPTIONAL, --\n},\nCommonCertificateAttributes {\niD      octet string,\nauthority boolean default not an authority,\nrequestId {\nidtype\tinteger\nIdValue\toctet string\npkcs15IssuerAndSerialNumber PKCS15KEY-IDENTIFIER::=\n{SYNTAX PKCS15-OPAQUE.&Type IDENTIFIED BY 1}\n-- As defined in RFC [CMS]\npkcs15SubjectKeyIdentifier PKCS15KEY-IDENTIFIER ::=\n{SYNTAX OCTET STRING IDENTIFIED BY 2}\n-- From x509v3 certificate extension\npkcs15IssuerAndSerialNumberHash PKCS15KEY-IDENTIFIER ::=\n{SYNTAX OCTET STRING IDENTIFIED BY 3}\n-- Assumes SHA-1 hash of DER encoding of IssuerAndSerialNumber\npkcs15SubjectKeyHash PKCS15KEY-IDENTIFIER ::=\n{SYNTAX OCTET STRING IDENTIFIED BY 4}\n-- Hash method defined in Section 7.\npkcs15IssuerKeyHash PKCS15KEY-IDENTIFIER ::=\n{SYNTAX OCTET STRING IDENTIFIED BY 5}\n-- Hash method defined in Section 7.\n} OPTIONAL,\nthumbprint \t[0] OOBCertHash OPTIONAL, -- hash on to be signed certificate, used for secure certificate identification as CCM using\n},\n[1] typeAttributes {\nvalue indirect : path : {\npath  \t\toctet string, -- '4331'H Reference by file identifier\nindex\t\tinteger OPTIONAL, -- 'XXXX'H offset in file\n[0] length \tinteger OPTIONAL, -- 'XXXX'H length in file\n}\n-- other optional attributes are defined for X509 certificate\n}\n},\n}\nAnnex C (normative):Access restriction certificate extension\naccess-Restriction extension\nid-ETSI OBJECT IDENTIFIER ::= {ITU identified-organization (3) ETSI } ::= {ETSI}\nid-mexe OBJECT IDENTIFIER ::= {ETSI MExE}\nId-mexe-accessRestriction ::= {id-mexe 1}\nAccessRestriction ::= BIT STRING {\nnetwork_service_access\t(0),}\nAnnex D (informative):MExE executable life cycle\nThis is a conceptual description of the life cycle of a MExE executable. There may be small deviations in a specific classmark.\nThe Unified Modelling Language (UML) [38] is used in the description. (This is a brief description of the symbols. A rounded rectangle is a state. An arrow is a transition between states. A dot is an initial state indicating the starting state when the enclosing state is entered. A circle with a dot is a final state. When a final state is activated the enclosing state ends.)\nFigures in parenthesis are references to clauses in the specification.\nD.1\tState of a MExE executable\nThe life cycle of MExE executables (clause 5.3 \"Provisioning and management of services\") is described using a state machine. In a MExE device a MExE executable can have the following states and transitions between states.\nState or Transition (=>)\nDescription\nInitial => Discovered\nThe MExE executable is discovered (clause 5.3.1 \"Service discovery\").\nDiscovered\nThe MExE executable is discovered and can be installed or executed without installation. (Only executables useable on the MExE device should enter this state.)\nDiscovered => Resident\nThe discovered executable is selected to be installed and the executable is transferred (clause 5.3.2 \"Service transfer\") to the MExE device for installation.\nDiscovered => Uninstalled Execution\nThe discovered executable is selected to be executed without installation.\nDiscovered => final state\nThe executable is undiscovered.\nResident\nThe executable is stored in the MExE device. It has been transferred or is pre-loaded.\nVerification\nThis is the initial sub-state of the Resident state. This is a composite state. There is a description of the Verification state in D.4.\nVerification => Configuration\nThe result of the verification indicates that the executable can be installed in one of the Domains.\nConfiguration\nThis is a sub-state of the Resident state. The executable can be configured, manually or automatically (clause 5.3.3 \"Service installation and configuration\").\nConfiguration => Released\nThe service is released for execution.\nReleased\nThis is a sub-state of the Resident state. The executable is resident, configured and released for execution. This is a composite state and there is a description of it in D.2.\nReleased => Configuration\nThe executable is blocked for execution or an executable has changes security domain (The user shall have the possibility to review the configuration before the executable is released for execution with different privileges.).\nResident => final state\nThe Resident state is left when the service is deleted (clause 5.3.6 \"Service deletion\"). From the MExE device point of view the executable does not exist any more. (The Integrity and Certification Validation (clause 6.10 \"Certificate management\") can also force a deletion)\nUninstalled Execution\nThe executable is executed without installation. This is a composite state. There is a description of the Uninstalled Execution state in D.3.\nUninstalled Execution => final state\nThe Uninstalled Execution state is left when the executable terminates by itself or when the user terminates the executable (clause 5.3.5 \"Service termination\"). From the MExE device point of view the executable does not exist any more.\nUninstalled Execution => Resident\nThis is a possible but unusual transition. A MExE executable that has been used for uninstalled execution is installed without retransferring.\nD.2\tReleased state\nA MExE executable in the Released state is resident, configured and released for execution.\nState or Transition (=>)\nDescription\nPassive\nThis is the initial state. The executable can be invoked.\nPassive => Verification\nThe MExE executable is invoked.\nVerification (or Optimised Verification)\nThe verification can either be done according to the Verification state described in D.4 or as an Optimised Verification described in (clause 6.2.2 \"Optimised application signature verification\").\nVerification => Executing\nThe result of the verification indicates that the executable may be executed. The Activated state and its sub-state Executing are entered.\nVerification => final state\nThe MExE executable has changed its security state and it must not be executed.\nActivated\nThe MExE executable is activated.\nExecuting\nThis is a sub-state of Activated. The executable executes (if it is not waiting for user permission).\nExecuting => final state\nThe Executing state is left when the executable terminates by itself. The Activated state is left and the Passive state is entered.\nWaiting for user permission\nThis is a sub-state to Executing. (If there is support for multi-threaded applications, this state can be a state concurrent to the Executing state.) The MExE executable is waiting for permission to perform some action (clause 6.3.1 \"MExE executable permissions for operator, manufacturer and third party security domains\").\nSuspended\nThis is a sub-state of Activated. The execution is suspended (clause 5.3 \"Provisioning and management of services\").\nActivated => Passive\nThe Activated state is left when the executable terminates by itself or when the user terminates the executable (clause 5.3.5 \"Service termination\").\nD.3\tUninstalled Execution state\nIn the Uninstalled Execution state a MExE executable is executed without installation.\nState or Transition (=>)\nDescription\nTransferring\nThis is the initial state of Uninstalled Execution. The MExE executable is transferred to the MExE device.\nTransferring => Verification\nIf the executable is signed the Verification state is entered after the transferring is finished.\nTransferring => Executing\nIf the executable is not signed the Executing state is entered. (To allow streaming, this can be done before the transfer is finished.)\nVerification\nThis is a composite state. There is a description of the Verification state in D.4.\nVerification => Executing\nThe result of verification indicates that the executable may be executed.\nVerification => final state\nThe result of verification indicates that the executable must not be executed and the Uninstalled Execution state is ended.\nExecuting\nThe MExE executable is executing.\nExecuting => final state\nThe Executing state is left when the execution terminates by itself (The Uninstalled Execution state is left.)\nWaiting for user permission\nThis is a sub-state to Executing. (If there is support for multi-threaded applications, this state can be a state concurrent to the Executing state.) The MExE executable is waiting for permission to perform some action (clause 6.3.1 \"MExE executable permissions for operator, manufacturer and third party security domains\").\nSuspended\nThe execution is suspended (clause 5.3 \"Provisioning and management of services\")\nD.4\tVerification\nThe integrity and certification validation (clause 6.10 \"Certificate management\") is done in the Verification state. The result of validation determines the change of state.\nState\nDescription\nValidation\nThis is the initial state. The integrity and certification validation (clause 6.10 \"Certificate management\") is done.\nUntrusted\nThe executable is untrusted (clause 6.1 \"Generic security\")\nTrusted in Operator Domain\nThe executable is verified to belong to the Operator Domain (clause 6.1 \"Generic security\").\nTrusted in Manufacturer Domain\nThe executable is verified to belong to the Manufacturer Domain (clause 6.1 \"Generic security\").\nTrusted in Third Party Domain\nThe executable is verified to belong to the Third Party Domain (clause 6.1 \"Generic security\").\nDeleted\nThe executable is not permitted in any Domain and it is deleted.\nAnnex E (informative):MExE conformance requirements\nThe table of Conformance Requirements define the minimum set of features that a conformant MExE device must implement.\nLegend:\nM\tMandatory feature/requirement.\nO\tOptional feature.\nN/A\tFeature is not applicable: the MExE specification does not prevent this feature from being implemented; however, support of this feature is not required for a MExE device to be regarded as being compliant with a specific MExE Classmark device. Therefore the specification does not indicate whether the feature is optional or mandatory.\nM/O\tSupport as such is required. Mandatory and Optional features are gathered into a table.\nID\nRequirement\nReference\nCM1\nCM2\nCM3\n4-1\nSupport of at least one MExE classmark on a MExE device\n4\nM\nM\nM\n4-2\nSupport of multiple combinations of MExE classmarks\n10.1\nO\nO\nO\n4-3\nSupport of WAP\n4.2.5\nM\nO\nO\n4-4\nIf Classmark 1 services are supported by non-Classmark 1 devices, Classmark 1 services shall execute in the same manner as they execute in a MExE Classmark 1 device\n4.5.1\nN/A\nM\nM\n4-5\nSupport of PersonalJava\n8.1, 8.1.1\nO\nM\nO\n4-6\nIf Classmark 2 services are supported by non-Classmark 2 devices, Classmark 2 services shall execute in the same manner as they execute in a MExE Classmark 2 device.\n4.5.2\nM\nN/A\nM\n4-7\nSupport of CLDC and MIDP\n9.1, 9.1.1\nO\nO\nM\n4-8\nIf Classmark 3 services are supported by non-Classmark 3 devices, Classmark 3 services shall execute in the same manner as they execute in a MExE Classmark 3 device.\n4.5.3\nM\nM\nN/A\n4-9\nSupport of capability negotiation process\n4.2\nM\nM\nM\n4-10\nSupport for interaction between the MExE device and the MSE by the use of HTTP/1.1or HTTP/1.1 derived protocol (e.g. WSP)\n4.2\nM\nM\nM\n4-11\nSupport of the properties in the UAProf schema for capability negotiation\n5.2.1\nM/O\nM/O\nM/O\n4-12\nSupport of content negotiation\n4.2\nO\nO\nO\n4-13\nSupport of user profiles\n5.2\nO\nO\nO\n4-14\nSupport of more than one user profile (if user profiles supported)\n5.2.2\nO\nO\nO\n4-15\nAbility to retain the user profile in the network (if user profiles supported)\n5.2.2\nO\nO\nO\n4-16\nUser permission for retaining the user profile in the network (if user profiles supported)\n5.2.2\nM\nM\nM\n4-17\nSupport of direct and indirect referencing mechanisms in retrieval of MExE preferences (if user profiles supported)\n8.2.2\nO\nO\nO\n4-18\nSupport of the properties in the UAProf schema for user preference information (if user profiles supported)\n8.2.2\nM\nM\nM\n4-19\nSupport of user interface personalisation\n5.1\nO\nO\nO\n4-20\nSupport of direct and indirect referencing mechanisms in retrieval of user interface personalisation preferences\n5.1.1\nO\nO\nO\n4-21\nAbility to support VHE\n9.2.5\nO\nO\nO\n4-22\nStorage of the VHE characteristics as a part of the user profile (if VHE and user profile is supported)\n9.2.5\nM\nM\nM\n4-23\nCapability to discover new services\n5.1.3.1\nM\nM\nM\n4-24\nSupport for a browser for service discovery\n5.1.3.1\nO\nO\nO\n4-25\nAbility to control service installation and configuration\n4.10.3\nN/A\nM\nM\n4-26\nAbility to determine which services are transferred to, resident, configured or executing on the MExE device (provide the name and, if available, version number)\n4.10.4\nM\nM\nM\n4-27\nService termination capability\n4.10.5\nM\nM\nM\n4-28\nCapability to delete a service\n4.10.6\nM\nM\nM\n4-29\nUser's ability to terminate or suspend any active connection associated with any MExE executable\n5.3\nM\nM\nM\n4-30\nUser's ability to obtain information on all connections associated with any MExE executable on the MExE device\n5.3\nM\nM\nM\n4-31\nSupport of journaling of network events by MExE executables\n5.4\nM\nM\nM\n4-32\nManagement of the journal by the MExE device, with no access to it by MExE executables\n5.4\nM\nM\nM\n4-33\nIndicate whenever network activity is in progress\n5.4.1\nO\nO\nO\n4-34\nSupport of QoS management by MExE\n5.4.2, 9\nO\nO\nO\n4-35\nSupport of core software download functionality\n5.5\nO\nO\nO\n4-36\nCore software download (if supported) only under control of the MExE device manufacturer\n5.5\nM\nM\nM\n5-1\nCall control using WTA scripts\n7.3.1\nM\nO\nO\n6-1\nSupport of the Wireless Profile of the JavaPhone API specification (Optional Java packages of Wireless Profile of the JavaPhone APIs as presented in Table 9 \"Optional Java packages of the Wireless Profile of the JavaPhone APIs\")\n8.2.1.1, 8.2.1.3\nO\nM/O\nO\n6-2\nSupport of the JAR file manifest entries as per JavaPhone specification\n8.2.1.3.1\nO\nM\nO\n6-3\nThe use of icons to launch applications\n8.2.1.3.1\nO\nO\nO\n6-4\nIf icons are used as elements to launch the application, then the icon file within the JAR file named by the Main-Icon attribute shall be displayed\n8.2.1.3.1\nO\nM\nO\n6-5\nImplementation of \"BatteryCritical\", \"BatteryNormal\" event generation\n8.2.1.3.2\nO\nM\nO\n6-6\nSupport for the following formats in Datagram recipient addressing: raw text-only GSM SMS message, UDP datagram via IP, and WAP datagram via GSM SMS message(s)\n8.2.1.3.3\nO\nM\nO\n6-7\nSupport any other Java APIs which comply with the MExE security requirements in Table 5 \"Security domains and actions\"\n8.2.1.4\nO\nO\nO\n6-8\nSupport for network protocols as per table 10 \"Support for network protocols\"\n8.2.1.5.1\nO\nM/O\nO\n6-9\nSupport of MIDlet discovery and management via a browser using MIME type text/vnd.sun.j2me.app-descriptor\n9.2.4\nO\nO\nO\n6-10\nIndication of MIDlets and MIDlet suites to the user (with a tag or icon and tag)\n9.2.4\nO\nO\nO\n7-1\nSupport of charging regimes of MExE services (charging mechanisms are outside the scope of MExE specification).\n5.6.1\nO\nO\nO\n8-1\nSupport of the untrusted area\n6.1\nM\nM\nM\n8-2\nSupport of all three security domains together (i.e. operator, manufacturer and third party), or no security domains at all\n6.1\nM\nM\nM\n8-3\nSecurity restrictions shall apply to MExE executables when API functionality is directly or indirectly called by MExE executables\n6.3\nM\nM\nM\n8-4\nSupport for permissions of operator, manufacturer and third party security domains in the order of restriction (as defined in table 5 of MExE specification).\n6.3.1\nM\nM\nM\n8-5\nAccess by MExE untrusted executables limited to the functionality specified in the table 6 of MExE specification\n6.3.2\nM\nM\nM\n8-6\nSeparation of the user interface input and output streams between different MExE executables (except for the MIDlets in the same MIDlet suite)\n6.11\nM\nM\nM\n8-7\nSupport of single action permission with a prompt for the user\n6.5\nM\nM\nM\n8-8\nSupport of session permission and blanket permission with a prompt for the user\n6.5\nO\nO\nO\n8-9\nIndication to the user whenever user permission is sought by an untrusted MExE executable\n6.5\nM\nM\nM\n8-10\nAbility of the user to request to be informed of the \"subject\" field of the certificate of the signer (if secure domains supported)\n6.5\nM\nM\nM\n8-11\nSupport for public key based solution of content authentication (if secure domains supported)\n6.7\nM\nM\nM\n8-12\nSupport of certificate chains (if secure domains supported)\n6.7\nM\nM\nM\n8-13\nSupport at least one level of certificate under operator, manufacturer or Third Party root public keys (if secure domains supported)\n6.7\nM\nM\nM\n8-14\nSecure installation of root public keys in the MExE device (if secure domains supported)\n6.7.1\nM\nM\nM\n8-15\nProhibition to share public keys between domains (if secure domains supported)\n6.7.1\nM\nM\nM\n8-16\nSupport the use and management of an operator root public key on the (U)SIM (if secure domains supported)\n6.6.1\nM\nM\nM\n8-17\nProhibition of the user to add or delete any type of operator public keys (if secure domains supported)\n6.6.1\nM\nM\nM\n8-18\nSupport of operator and manufacturer disaster recovery root public keys (if secure domains supported)\n8.5.\nO\nO\nO\n8-19\nSupport of the use and management of the operator root public key (if secure domains supported)\n8.5.1.\nM\nM\nM\n8-20\nSupport of the use and management of the manufacturer root public key (if secure domains supported)\n6.6.2\nM\nM\nM\n8-21\nSupport of the use and management of the third party root public keys (if secure domains supported)\n6.6.3\nM\nM\nM\n8-22\nSupport of the use and management of the administrator root public key (if secure domains supported)\n6.13.1\nM\nM\nM\n8-23\nSupport of the administrator designation mechanism (if secure domains supported)\n6.13.1\nM\nM\nM\n8-24\nSupport of the certificate configuration management (if secure domains supported)\n6.10\nM\nM\nM\n8-25\nUse of the CCM by MExE device to determine the third party certificates that are trusted for the use on the MExE device (if secure domains supported)\n6.10.1\nM\nM\nM\n8-26\nAdditional support of other means to enable/disable root certificates (if secure domains supported)\n6.10.1\nO\nO\nO\n8-27\nSupport of authorised CCM download mechanisms (if secure domains supported)\n8.7.\nM\nM\nM\n8-28\nWhen the administrator is changed, then the CCM shall also be changed.  (if secure domains supported)\n8.7.\nM\nM\nM\n8-29\nSupport of provisioned mechanism for designating administrative responsibilities and adding third parties in a MExE device (if secure domains supported)\n6.13.2\nM\nM\nM\n8-30\nSupport of the cases: the user is the owner, the user is at remote location, the owner of the MExE-(U)SIM wants to be a temporary administrator (if secure domains supported)\n6.13.2\nM\nM\nM\n8-31\nSupport for determining the administrator of the MExE device (if secure domains supported)\n6.13.3\nM\nM\nM\n8-32\nEither sandbox or fine grain Java security shall be supported\n8.3.1\nN/A\nM\nN/A\n8-33\nSupport for trusted applets (if secure domains supported)\n8.3.1\nN/A\nO\nO\n8-34\nVerification of the certification of the application or applet (if secure domains supported)\n8.3.1.2\nM\nM\nM\n8-35\nJava loading native libraries that are intrinsically part of the MExE device implementation, and MExE native libraries\n8.3.1.3\nO\nO\nO\n8-36\nNo loading of other native libraries\n8.3.1.3\nN/A\nM\nN/A\n8-37\nSupport of the JAR file format devices for securely packaging objects that are to be downloaded and installed on the MExE device\n10.3.1\nN/A\nM\nM\n8-38\nSupport for other proprietary means of downloading and installing objects\n10.3.1\nO\nO\nO\n8-39\nSupport of MExE native library signed package installation\n8.3.2\nN/A\nO\nO\n8-40\nSupport for the case when a certificate containing an Administrator root public key is thus contained in a signed package, the signed package (JAR) shall contain two files: the Administrator root public key and the CCM (if secure domains supported).\n6.8.2\nN/A\nM\nM\n8-41\nSupport of installation of other signed data (e.g. proprietary binaries or Java classes such as native DSP code, provisioned functionality upgrades and patches) (if secure domains supported).\n6.8.3\nO\nO\nO\n8-42\nSupport for administrator root certificate mechanism (if secure domains supported).\n6.13.4\nM\nM\nM\n8-43\nSupport of alternative methods to download an administrator root certificate (if secure domains supported).\n6.13.4\nO\nO\nO\n8-44\nSupport of optimised signature verification of applications (if secure domains supported).\n6.8.1\nO\nO\nO\n9-1\nSupport of QoS API by MExE device\n9\nO\nO\nO\n9-2\nSupport of a basic QoS operations\n5.5.2\nO\nO\nO\n9-3\nSupport of MExE QoS API by MExE QoS Manager\n5.5.3\nO\nO\nO\n9-4\nProvision of the MExE QoS Manager functions\n5.5.3\nO\nO\nO\n9-5\nAbility to manage QoS through the MExE device's MMI\n5.5.3\nO\nO\nO\n9-6\nQoS control by MExE QoS Manager, if it is not provided in the network control\n5.5.4\nO\nO\nO\n9-7\nProvision of a standard set of parameters by a QoS API to MExE executable\n5.5.5\nO\nO\nO\n9-8\nAbility of MExE QoS Manager to deal independently with each of the several simultaneous QoS streams\n5.5.7\nO\nO\nO\nAnnex F (informative):Change history\nChange history\nDate\nTSG #\nTSG Doc.\nCR\nRev\nCat\nSubject/Comment\nOld\nNew\n2002\nT#16\nTP-020102\n118\n-\n-\nRestructuring of the MExE-specification\n5.0.0\n6.0.0\n2002\nT#17\nTP-020202\n119\n-\n-\nCC/PP section cleanup\n6.0.0\n6.1.0\n2002\nT#17\nTP-020202\n120\n-\n-\nAdding new attributes to the JAR manifest file\n6.0.0\n6.1.0\n2003\nT#21\nTP-030169\n122\n-\n-\nCorrecting figure and table numbering\n6.1.0\n6.2.0\n2007-06\nSP-36\n-\n-\n-\n-\nUpdate to Rel-7 version (MCC)\n6.2.0\n7.0.0\n2008-12\nSP-42\n-\n-\n-\n-\nUpdate to Rel-8 version (MCC)\n7.0.0\n8.0.0\n2009-12\nSP-46\n-\n-\n-\n-\nUpdate to Rel-9 version (MCC)\n8.0.0\n9.0.0\n2011-03\nSP-51\n-\n-\n-\n-\nUpdate to Rel-10 version (MCC)\n9.0.0\n10.0.0\n2012-09\n-\n-\n-\n-\n-\nUpdate to Rel-11 version (MCC)\n10.0.0\n11.0.0\n2014-09\nSP-65\n-\n-\n-\n-\nUpdate to Rel-12 version (MCC)\n11.0.0\n12.0.0\n2015-12\n-\n-\n-\n-\n-\nUpdate to Rel-13 version (MCC)\n12.0.0\n13.0.0\n2017-03\n-\n-\n-\n-\n-\nUpdate to Rel-14 version (MCC)\n13.0.0\n14.0.0\n2018-06\nSP-80\n-\n-\n-\n-\nUpdate to Rel-15 version (MCC)\n14.0.0\n15.0.0\n2020-07\nSP-88E\n-\n-\n-\n-\nUpdate to Rel-16 version (MCC)\n15.0.0\n16.0.0\n2022-03\nSP-95E\n-\n-\n-\n-\nUpdate to Rel-17 version (MCC)\n16.0.0\n17.0.0\n2024-03\n-\n-\n-\n-\n-\nUpdate to Rel-18 version (MCC)\n17.0.0\n18.0.0",
      "chunk_type": "general",
      "cross_references": [
        "clause_6.1",
        "clause_6.6",
        "clause_7",
        "clause_5.3",
        "clause_5.3.1",
        "clause_5.3.2",
        "clause_5.3.3",
        "clause_5.3.6",
        "clause_6.10",
        "clause_5.3.5",
        "clause_6.2.2",
        "clause_6.3.1",
        "table_5.3",
        "table_9",
        "table_5",
        "table_10",
        "table_6",
        "table_6.5",
        "table_5.5.5",
        "ts_51.011",
        "ts_31.102",
        "ts_7.3",
        "ts_10.3"
      ]
    }
  ]
}